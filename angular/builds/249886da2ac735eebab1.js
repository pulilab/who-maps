(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[622],{

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2JhMTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy9cbi8vIFdlIHN0b3JlIG91ciBFRSBvYmplY3RzIGluIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGB+YCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBvdmVycmlkZGVuIG9yXG4vLyB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vLyBXZSBhbHNvIGFzc3VtZSB0aGF0IGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgbmFtZVxuLy8gaXMgYW4gRVM2IFN5bWJvbC5cbi8vXG52YXIgcHJlZml4ID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicgPyAnficgOiBmYWxzZTtcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIE9ubHkgZW1pdCBvbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIE1pbmltYWwgRXZlbnRFbWl0dGVyIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgeyAvKiBOb3RoaW5nIHRvIHNldCAqLyB9XG5cbi8qKlxuICogSG9sZCB0aGUgYXNzaWduZWQgRXZlbnRFbWl0dGVycyBieSBuYW1lLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzXG4gICAgLCBuYW1lcyA9IFtdXG4gICAgLCBuYW1lO1xuXG4gIGlmICghZXZlbnRzKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIGV2ZW50cykge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBXZSBvbmx5IG5lZWQgdG8ga25vdyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuICBpZiAoIWF2YWlsYWJsZSkgcmV0dXJuIFtdO1xuICBpZiAoYXZhaWxhYmxlLmZuKSByZXR1cm4gW2F2YWlsYWJsZS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdmFpbGFibGUubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gYXZhaWxhYmxlW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgRXZlbnRMaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcylcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGFuIEV2ZW50TGlzdGVuZXIgdGhhdCdzIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdlIHdhbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIHRoYXQgd2UgbmVlZCB0byBmaW5kLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSBsaXN0ZW5lcnMgbWF0Y2hpbmcgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uY2UgbGlzdGVuZXJzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgZXZlbnRzID0gW107XG5cbiAgaWYgKGZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgaWYgKFxuICAgICAgICAgICBsaXN0ZW5lcnMuZm4gIT09IGZuXG4gICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgLy9cbiAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIG9ubHkgdGhlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdhbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gIGlmIChldmVudCkgZGVsZXRlIHRoaXMuX2V2ZW50c1twcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XTtcbiAgZWxzZSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "./node_modules/lodash/_arrayEvery.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_arrayEvery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUV2ZXJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFdmVyeS5qcz82NjJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUV2ZXJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_arrayEvery.js\n");

/***/ }),

/***/ "./node_modules/lodash/_baseEvery.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseEvery.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/lodash/_baseEach.js\");\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXZlcnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXZlcnkuanM/MWY0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgXG4gKi9cbmZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUV2ZXJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseEvery.js\n");

/***/ }),

/***/ "./node_modules/lodash/_baseExtremum.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseExtremum.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/lodash/isSymbol.js\");\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXh0cmVtdW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXh0cmVtdW0uanM/NzZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFeHRyZW11bTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseExtremum.js\n");

/***/ }),

/***/ "./node_modules/lodash/_baseLt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseLt.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTHQuanM/OGQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA8IG90aGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VMdDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseLt.js\n");

/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/lodash/_baseEach.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\");\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hcC5qcz85N2QzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseMap.js\n");

/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var eq = __webpack_require__(/*! ./eq */ \"./node_modules/lodash/eq.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzPzlhZmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_isIterateeCall.js\n");

/***/ }),

/***/ "./node_modules/lodash/every.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/every.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayEvery = __webpack_require__(/*! ./_arrayEvery */ \"./node_modules/lodash/_arrayEvery.js\"),\n    baseEvery = __webpack_require__(/*! ./_baseEvery */ \"./node_modules/lodash/_baseEvery.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/lodash/_baseIteratee.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/lodash/_isIterateeCall.js\");\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = every;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2V2ZXJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ldmVyeS5qcz8yNjU3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcnJheUV2ZXJ5ID0gcmVxdWlyZSgnLi9fYXJyYXlFdmVyeScpLFxuICAgIGJhc2VFdmVyeSA9IHJlcXVpcmUoJy4vX2Jhc2VFdmVyeScpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZXJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/every.js\n");

/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/lodash/_arrayMap.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/lodash/_baseIteratee.js\"),\n    baseMap = __webpack_require__(/*! ./_baseMap */ \"./node_modules/lodash/_baseMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\");\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwLmpzP2RkNjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/map.js\n");

/***/ }),

/***/ "./node_modules/lodash/min.js":
/*!************************************!*\
  !*** ./node_modules/lodash/min.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/lodash/_baseExtremum.js\"),\n    baseLt = __webpack_require__(/*! ./_baseLt */ \"./node_modules/lodash/_baseLt.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/lodash/identity.js\");\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL21pbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWluLmpzPzAwNGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VMdCA9IHJlcXVpcmUoJy4vX2Jhc2VMdCcpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLm1pbihbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/min.js\n");

/***/ }),

/***/ "./node_modules/ng-file-upload/dist/ng-file-upload-all.js":
/*!****************************************************************!*\
  !*** ./node_modules/ng-file-upload/dist/ng-file-upload-all.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**!\n * AngularJS file upload directives and services. Supports: file upload/drop/paste, resume, cancel/abort,\n * progress, resize, thumbnail, preview, validation and CORS\n * FileAPI Flash shim for old browsers not supporting FormData\n * @author  Danial  <danial.farid@gmail.com>\n * @version 12.2.13\n */\n\n(function () {\n  /** @namespace FileAPI.noContentTimeout */\n\n  function patchXHR(fnName, newFn) {\n    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);\n  }\n\n  function redefineProp(xhr, prop, fn) {\n    try {\n      Object.defineProperty(xhr, prop, {get: fn});\n    } catch (e) {/*ignore*/\n    }\n  }\n\n  if (!window.FileAPI) {\n    window.FileAPI = {};\n  }\n\n  if (!window.XMLHttpRequest) {\n    throw 'AJAX is not supported. XMLHttpRequest is not defined.';\n  }\n\n  FileAPI.shouldLoad = !window.FormData || FileAPI.forceLoad;\n  if (FileAPI.shouldLoad) {\n    var initializeUploadListener = function (xhr) {\n      if (!xhr.__listeners) {\n        if (!xhr.upload) xhr.upload = {};\n        xhr.__listeners = [];\n        var origAddEventListener = xhr.upload.addEventListener;\n        xhr.upload.addEventListener = function (t, fn) {\n          xhr.__listeners[t] = fn;\n          if (origAddEventListener) origAddEventListener.apply(this, arguments);\n        };\n      }\n    };\n\n    patchXHR('open', function (orig) {\n      return function (m, url, b) {\n        initializeUploadListener(this);\n        this.__url = url;\n        try {\n          orig.apply(this, [m, url, b]);\n        } catch (e) {\n          if (e.message.indexOf('Access is denied') > -1) {\n            this.__origError = e;\n            orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);\n          }\n        }\n      };\n    });\n\n    patchXHR('getResponseHeader', function (orig) {\n      return function (h) {\n        return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));\n      };\n    });\n\n    patchXHR('getAllResponseHeaders', function (orig) {\n      return function () {\n        return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));\n      };\n    });\n\n    patchXHR('abort', function (orig) {\n      return function () {\n        return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));\n      };\n    });\n\n    patchXHR('setRequestHeader', function (orig) {\n      return function (header, value) {\n        if (header === '__setXHR_') {\n          initializeUploadListener(this);\n          var val = value(this);\n          // fix for angular < 1.2.0\n          if (val instanceof Function) {\n            val(this);\n          }\n        } else {\n          this.__requestHeaders = this.__requestHeaders || {};\n          this.__requestHeaders[header] = value;\n          orig.apply(this, arguments);\n        }\n      };\n    });\n\n    patchXHR('send', function (orig) {\n      return function () {\n        var xhr = this;\n        if (arguments[0] && arguments[0].__isFileAPIShim) {\n          var formData = arguments[0];\n          var config = {\n            url: xhr.__url,\n            jsonp: false, //removes the callback form param\n            cache: true, //removes the ?fileapiXXX in the url\n            complete: function (err, fileApiXHR) {\n              if (err && angular.isString(err) && err.indexOf('#2174') !== -1) {\n                // this error seems to be fine the file is being uploaded properly.\n                err = null;\n              }\n              xhr.__completed = true;\n              if (!err && xhr.__listeners.load)\n                xhr.__listeners.load({\n                  type: 'load',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (!err && xhr.__listeners.loadend)\n                xhr.__listeners.loadend({\n                  type: 'loadend',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (err === 'abort' && xhr.__listeners.abort)\n                xhr.__listeners.abort({\n                  type: 'abort',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function () {\n                return (fileApiXHR.status === 0 && err && err !== 'abort') ? 500 : fileApiXHR.status;\n              });\n              if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function () {\n                return fileApiXHR.statusText;\n              });\n              redefineProp(xhr, 'readyState', function () {\n                return 4;\n              });\n              if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function () {\n                return fileApiXHR.response;\n              });\n              var resp = fileApiXHR.responseText || (err && fileApiXHR.status === 0 && err !== 'abort' ? err : undefined);\n              redefineProp(xhr, 'responseText', function () {\n                return resp;\n              });\n              redefineProp(xhr, 'response', function () {\n                return resp;\n              });\n              if (err) redefineProp(xhr, 'err', function () {\n                return err;\n              });\n              xhr.__fileApiXHR = fileApiXHR;\n              if (xhr.onreadystatechange) xhr.onreadystatechange();\n              if (xhr.onload) xhr.onload();\n            },\n            progress: function (e) {\n              e.target = xhr;\n              if (xhr.__listeners.progress) xhr.__listeners.progress(e);\n              xhr.__total = e.total;\n              xhr.__loaded = e.loaded;\n              if (e.total === e.loaded) {\n                // fix flash issue that doesn't call complete if there is no response text from the server\n                var _this = this;\n                setTimeout(function () {\n                  if (!xhr.__completed) {\n                    xhr.getAllResponseHeaders = function () {\n                    };\n                    _this.complete(null, {status: 204, statusText: 'No Content'});\n                  }\n                }, FileAPI.noContentTimeout || 10000);\n              }\n            },\n            headers: xhr.__requestHeaders\n          };\n          config.data = {};\n          config.files = {};\n          for (var i = 0; i < formData.data.length; i++) {\n            var item = formData.data[i];\n            if (item.val != null && item.val.name != null && item.val.size != null && item.val.type != null) {\n              config.files[item.key] = item.val;\n            } else {\n              config.data[item.key] = item.val;\n            }\n          }\n\n          setTimeout(function () {\n            if (!FileAPI.hasFlash) {\n              throw 'Adode Flash Player need to be installed. To check ahead use \"FileAPI.hasFlash\"';\n            }\n            xhr.__fileApiXHR = FileAPI.upload(config);\n          }, 1);\n        } else {\n          if (this.__origError) {\n            throw this.__origError;\n          }\n          orig.apply(xhr, arguments);\n        }\n      };\n    });\n    window.XMLHttpRequest.__isFileAPIShim = true;\n    window.FormData = FormData = function () {\n      return {\n        append: function (key, val, name) {\n          if (val.__isFileAPIBlobShim) {\n            val = val.data[0];\n          }\n          this.data.push({\n            key: key,\n            val: val,\n            name: name\n          });\n        },\n        data: [],\n        __isFileAPIShim: true\n      };\n    };\n\n    window.Blob = Blob = function (b) {\n      return {\n        data: b,\n        __isFileAPIBlobShim: true\n      };\n    };\n  }\n\n})();\n\n(function () {\n  /** @namespace FileAPI.forceLoad */\n  /** @namespace window.FileAPI.jsUrl */\n  /** @namespace window.FileAPI.jsPath */\n\n  function isInputTypeFile(elem) {\n    return elem[0].tagName.toLowerCase() === 'input' && elem.attr('type') && elem.attr('type').toLowerCase() === 'file';\n  }\n\n  function hasFlash() {\n    try {\n      var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n      if (fo) return true;\n    } catch (e) {\n      if (navigator.mimeTypes['application/x-shockwave-flash'] !== undefined) return true;\n    }\n    return false;\n  }\n\n  function getOffset(obj) {\n    var left = 0, top = 0;\n\n    if (window.jQuery) {\n      return jQuery(obj).offset();\n    }\n\n    if (obj.offsetParent) {\n      do {\n        left += (obj.offsetLeft - obj.scrollLeft);\n        top += (obj.offsetTop - obj.scrollTop);\n        obj = obj.offsetParent;\n      } while (obj);\n    }\n    return {\n      left: left,\n      top: top\n    };\n  }\n\n  if (FileAPI.shouldLoad) {\n    FileAPI.hasFlash = hasFlash();\n\n    //load FileAPI\n    if (FileAPI.forceLoad) {\n      FileAPI.html5 = false;\n    }\n\n    if (!FileAPI.upload) {\n      var jsUrl, basePath, script = document.createElement('script'), allScripts = document.getElementsByTagName('script'), i, index, src;\n      if (window.FileAPI.jsUrl) {\n        jsUrl = window.FileAPI.jsUrl;\n      } else if (window.FileAPI.jsPath) {\n        basePath = window.FileAPI.jsPath;\n      } else {\n        for (i = 0; i < allScripts.length; i++) {\n          src = allScripts[i].src;\n          index = src.search(/\\/ng\\-file\\-upload[\\-a-zA-z0-9\\.]*\\.js/);\n          if (index > -1) {\n            basePath = src.substring(0, index + 1);\n            break;\n          }\n        }\n      }\n\n      if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;\n      script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');\n      document.getElementsByTagName('head')[0].appendChild(script);\n    }\n\n    FileAPI.ngfFixIE = function (elem, fileElem, changeFn) {\n      if (!hasFlash()) {\n        throw 'Adode Flash Player need to be installed. To check ahead use \"FileAPI.hasFlash\"';\n      }\n      var fixInputStyle = function () {\n        var label = fileElem.parent();\n        if (elem.attr('disabled')) {\n          if (label) label.removeClass('js-fileapi-wrapper');\n        } else {\n          if (!fileElem.attr('__ngf_flash_')) {\n            fileElem.unbind('change');\n            fileElem.unbind('click');\n            fileElem.bind('change', function (evt) {\n              fileApiChangeFn.apply(this, [evt]);\n              changeFn.apply(this, [evt]);\n            });\n            fileElem.attr('__ngf_flash_', 'true');\n          }\n          label.addClass('js-fileapi-wrapper');\n          if (!isInputTypeFile(elem)) {\n            label.css('position', 'absolute')\n              .css('top', getOffset(elem[0]).top + 'px').css('left', getOffset(elem[0]).left + 'px')\n              .css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')\n              .css('filter', 'alpha(opacity=0)').css('display', elem.css('display'))\n              .css('overflow', 'hidden').css('z-index', '900000')\n              .css('visibility', 'visible');\n            fileElem.css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')\n              .css('position', 'absolute').css('top', '0px').css('left', '0px');\n          }\n        }\n      };\n\n      elem.bind('mouseenter', fixInputStyle);\n\n      var fileApiChangeFn = function (evt) {\n        var files = FileAPI.getFiles(evt);\n        //just a double check for #233\n        for (var i = 0; i < files.length; i++) {\n          if (files[i].size === undefined) files[i].size = 0;\n          if (files[i].name === undefined) files[i].name = 'file';\n          if (files[i].type === undefined) files[i].type = 'undefined';\n        }\n        if (!evt.target) {\n          evt.target = {};\n        }\n        evt.target.files = files;\n        // if evt.target.files is not writable use helper field\n        if (evt.target.files !== files) {\n          evt.__files_ = files;\n        }\n        (evt.__files_ || evt.target.files).item = function (i) {\n          return (evt.__files_ || evt.target.files)[i] || null;\n        };\n      };\n    };\n\n    FileAPI.disableFileInput = function (elem, disable) {\n      if (disable) {\n        elem.removeClass('js-fileapi-wrapper');\n      } else {\n        elem.addClass('js-fileapi-wrapper');\n      }\n    };\n  }\n})();\n\nif (!window.FileReader) {\n  window.FileReader = function () {\n    var _this = this, loadStarted = false;\n    this.listeners = {};\n    this.addEventListener = function (type, fn) {\n      _this.listeners[type] = _this.listeners[type] || [];\n      _this.listeners[type].push(fn);\n    };\n    this.removeEventListener = function (type, fn) {\n      if (_this.listeners[type]) _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);\n    };\n    this.dispatchEvent = function (evt) {\n      var list = _this.listeners[evt.type];\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(_this, evt);\n        }\n      }\n    };\n    this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;\n\n    var constructEvent = function (type, evt) {\n      var e = {type: type, target: _this, loaded: evt.loaded, total: evt.total, error: evt.error};\n      if (evt.result != null) e.target.result = evt.result;\n      return e;\n    };\n    var listener = function (evt) {\n      if (!loadStarted) {\n        loadStarted = true;\n        if (_this.onloadstart) _this.onloadstart(constructEvent('loadstart', evt));\n      }\n      var e;\n      if (evt.type === 'load') {\n        if (_this.onloadend) _this.onloadend(constructEvent('loadend', evt));\n        e = constructEvent('load', evt);\n        if (_this.onload) _this.onload(e);\n        _this.dispatchEvent(e);\n      } else if (evt.type === 'progress') {\n        e = constructEvent('progress', evt);\n        if (_this.onprogress) _this.onprogress(e);\n        _this.dispatchEvent(e);\n      } else {\n        e = constructEvent('error', evt);\n        if (_this.onerror) _this.onerror(e);\n        _this.dispatchEvent(e);\n      }\n    };\n    this.readAsDataURL = function (file) {\n      FileAPI.readAsDataURL(file, listener);\n    };\n    this.readAsText = function (file) {\n      FileAPI.readAsText(file, listener);\n    };\n  };\n}\n\n/**!\n * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,\n * progress, resize, thumbnail, preview, validation and CORS\n * @author  Danial  <danial.farid@gmail.com>\n * @version 12.2.13\n */\n\nif (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {\n  window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {\n    return function (header, value) {\n      if (header === '__setXHR_') {\n        var val = value(this);\n        // fix for angular < 1.2.0\n        if (val instanceof Function) {\n          val(this);\n        }\n      } else {\n        orig.apply(this, arguments);\n      }\n    };\n  })(window.XMLHttpRequest.prototype.setRequestHeader);\n}\n\nvar ngFileUpload = angular.module('ngFileUpload', []);\n\nngFileUpload.version = '12.2.13';\n\nngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {\n  var upload = this;\n  upload.promisesCount = 0;\n\n  this.isResumeSupported = function () {\n    return window.Blob && window.Blob.prototype.slice;\n  };\n\n  var resumeSupported = this.isResumeSupported();\n\n  function sendHttp(config) {\n    config.method = config.method || 'POST';\n    config.headers = config.headers || {};\n\n    var deferred = config._deferred = config._deferred || $q.defer();\n    var promise = deferred.promise;\n\n    function notifyProgress(e) {\n      if (deferred.notify) {\n        deferred.notify(e);\n      }\n      if (promise.progressFunc) {\n        $timeout(function () {\n          promise.progressFunc(e);\n        });\n      }\n    }\n\n    function getNotifyEvent(n) {\n      if (config._start != null && resumeSupported) {\n        return {\n          loaded: n.loaded + config._start,\n          total: (config._file && config._file.size) || n.total,\n          type: n.type, config: config,\n          lengthComputable: true, target: n.target\n        };\n      } else {\n        return n;\n      }\n    }\n\n    if (!config.disableProgress) {\n      config.headers.__setXHR_ = function () {\n        return function (xhr) {\n          if (!xhr || !xhr.upload || !xhr.upload.addEventListener) return;\n          config.__XHR = xhr;\n          if (config.xhrFn) config.xhrFn(xhr);\n          xhr.upload.addEventListener('progress', function (e) {\n            e.config = config;\n            notifyProgress(getNotifyEvent(e));\n          }, false);\n          //fix for firefox not firing upload progress end, also IE8-9\n          xhr.upload.addEventListener('load', function (e) {\n            if (e.lengthComputable) {\n              e.config = config;\n              notifyProgress(getNotifyEvent(e));\n            }\n          }, false);\n        };\n      };\n    }\n\n    function uploadWithAngular() {\n      $http(config).then(function (r) {\n          if (resumeSupported && config._chunkSize && !config._finished && config._file) {\n            var fileSize = config._file && config._file.size || 0;\n            notifyProgress({\n                loaded: Math.min(config._end, fileSize),\n                total: fileSize,\n                config: config,\n                type: 'progress'\n              }\n            );\n            upload.upload(config, true);\n          } else {\n            if (config._finished) delete config._finished;\n            deferred.resolve(r);\n          }\n        }, function (e) {\n          deferred.reject(e);\n        }, function (n) {\n          deferred.notify(n);\n        }\n      );\n    }\n\n    if (!resumeSupported) {\n      uploadWithAngular();\n    } else if (config._chunkSize && config._end && !config._finished) {\n      config._start = config._end;\n      config._end += config._chunkSize;\n      uploadWithAngular();\n    } else if (config.resumeSizeUrl) {\n      $http.get(config.resumeSizeUrl).then(function (resp) {\n        if (config.resumeSizeResponseReader) {\n          config._start = config.resumeSizeResponseReader(resp.data);\n        } else {\n          config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());\n        }\n        if (config._chunkSize) {\n          config._end = config._start + config._chunkSize;\n        }\n        uploadWithAngular();\n      }, function (e) {\n        throw e;\n      });\n    } else if (config.resumeSize) {\n      config.resumeSize().then(function (size) {\n        config._start = size;\n        if (config._chunkSize) {\n          config._end = config._start + config._chunkSize;\n        }\n        uploadWithAngular();\n      }, function (e) {\n        throw e;\n      });\n    } else {\n      if (config._chunkSize) {\n        config._start = 0;\n        config._end = config._start + config._chunkSize;\n      }\n      uploadWithAngular();\n    }\n\n\n    promise.success = function (fn) {\n      promise.then(function (response) {\n        fn(response.data, response.status, response.headers, config);\n      });\n      return promise;\n    };\n\n    promise.error = function (fn) {\n      promise.then(null, function (response) {\n        fn(response.data, response.status, response.headers, config);\n      });\n      return promise;\n    };\n\n    promise.progress = function (fn) {\n      promise.progressFunc = fn;\n      promise.then(null, null, function (n) {\n        fn(n);\n      });\n      return promise;\n    };\n    promise.abort = promise.pause = function () {\n      if (config.__XHR) {\n        $timeout(function () {\n          config.__XHR.abort();\n        });\n      }\n      return promise;\n    };\n    promise.xhr = function (fn) {\n      config.xhrFn = (function (origXhrFn) {\n        return function () {\n          if (origXhrFn) origXhrFn.apply(promise, arguments);\n          fn.apply(promise, arguments);\n        };\n      })(config.xhrFn);\n      return promise;\n    };\n\n    upload.promisesCount++;\n    if (promise['finally'] && promise['finally'] instanceof Function) {\n      promise['finally'](function () {\n        upload.promisesCount--;\n      });\n    }\n    return promise;\n  }\n\n  this.isUploadInProgress = function () {\n    return upload.promisesCount > 0;\n  };\n\n  this.rename = function (file, name) {\n    file.ngfName = name;\n    return file;\n  };\n\n  this.jsonBlob = function (val) {\n    if (val != null && !angular.isString(val)) {\n      val = JSON.stringify(val);\n    }\n    var blob = new window.Blob([val], {type: 'application/json'});\n    blob._ngfBlob = true;\n    return blob;\n  };\n\n  this.json = function (val) {\n    return angular.toJson(val);\n  };\n\n  function copy(obj) {\n    var clone = {};\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clone[key] = obj[key];\n      }\n    }\n    return clone;\n  }\n\n  this.isFile = function (file) {\n    return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));\n  };\n\n  this.upload = function (config, internal) {\n    function toResumeFile(file, formData) {\n      if (file._ngfBlob) return file;\n      config._file = config._file || file;\n      if (config._start != null && resumeSupported) {\n        if (config._end && config._end >= file.size) {\n          config._finished = true;\n          config._end = file.size;\n        }\n        var slice = file.slice(config._start, config._end || file.size);\n        slice.name = file.name;\n        slice.ngfName = file.ngfName;\n        if (config._chunkSize) {\n          formData.append('_chunkSize', config._chunkSize);\n          formData.append('_currentChunkSize', config._end - config._start);\n          formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));\n          formData.append('_totalSize', config._file.size);\n        }\n        return slice;\n      }\n      return file;\n    }\n\n    function addFieldToFormData(formData, val, key) {\n      if (val !== undefined) {\n        if (angular.isDate(val)) {\n          val = val.toISOString();\n        }\n        if (angular.isString(val)) {\n          formData.append(key, val);\n        } else if (upload.isFile(val)) {\n          var file = toResumeFile(val, formData);\n          var split = key.split(',');\n          if (split[1]) {\n            file.ngfName = split[1].replace(/^\\s+|\\s+$/g, '');\n            key = split[0];\n          }\n          config._fileKey = config._fileKey || key;\n          formData.append(key, file, file.ngfName || file.name);\n        } else {\n          if (angular.isObject(val)) {\n            if (val.$$ngfCircularDetection) throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;\n\n            val.$$ngfCircularDetection = true;\n            try {\n              for (var k in val) {\n                if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {\n                  var objectKey = config.objectKey == null ? '[i]' : config.objectKey;\n                  if (val.length && parseInt(k) > -1) {\n                    objectKey = config.arrayKey == null ? objectKey : config.arrayKey;\n                  }\n                  addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));\n                }\n              }\n            } finally {\n              delete val.$$ngfCircularDetection;\n            }\n          } else {\n            formData.append(key, val);\n          }\n        }\n      }\n    }\n\n    function digestConfig() {\n      config._chunkSize = upload.translateScalars(config.resumeChunkSize);\n      config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;\n\n      config.headers = config.headers || {};\n      config.headers['Content-Type'] = undefined;\n      config.transformRequest = config.transformRequest ?\n        (angular.isArray(config.transformRequest) ?\n          config.transformRequest : [config.transformRequest]) : [];\n      config.transformRequest.push(function (data) {\n        var formData = new window.FormData(), key;\n        data = data || config.fields || {};\n        if (config.file) {\n          data.file = config.file;\n        }\n        for (key in data) {\n          if (data.hasOwnProperty(key)) {\n            var val = data[key];\n            if (config.formDataAppender) {\n              config.formDataAppender(formData, key, val);\n            } else {\n              addFieldToFormData(formData, val, key);\n            }\n          }\n        }\n\n        return formData;\n      });\n    }\n\n    if (!internal) config = copy(config);\n    if (!config._isDigested) {\n      config._isDigested = true;\n      digestConfig();\n    }\n\n    return sendHttp(config);\n  };\n\n  this.http = function (config) {\n    config = copy(config);\n    config.transformRequest = config.transformRequest || function (data) {\n        if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {\n          return data;\n        }\n        return $http.defaults.transformRequest[0].apply(this, arguments);\n      };\n    config._chunkSize = upload.translateScalars(config.resumeChunkSize);\n    config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;\n\n    return sendHttp(config);\n  };\n\n  this.translateScalars = function (str) {\n    if (angular.isString(str)) {\n      if (str.search(/kb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1024);\n      } else if (str.search(/mb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1048576);\n      } else if (str.search(/gb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1073741824);\n      } else if (str.search(/b/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1));\n      } else if (str.search(/s/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1));\n      } else if (str.search(/m/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1) * 60);\n      } else if (str.search(/h/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1) * 3600);\n      }\n    }\n    return str;\n  };\n\n  this.urlToBlob = function(url) {\n    var defer = $q.defer();\n    $http({url: url, method: 'get', responseType: 'arraybuffer'}).then(function (resp) {\n      var arrayBufferView = new Uint8Array(resp.data);\n      var type = resp.headers('content-type') || 'image/WebP';\n      var blob = new window.Blob([arrayBufferView], {type: type});\n      var matches = url.match(/.*\\/(.+?)(\\?.*)?$/);\n      if (matches.length > 1) {\n        blob.name = matches[1];\n      }\n      defer.resolve(blob);\n    }, function (e) {\n      defer.reject(e);\n    });\n    return defer.promise;\n  };\n\n  this.setDefaults = function (defaults) {\n    this.defaults = defaults || {};\n  };\n\n  this.defaults = {};\n  this.version = ngFileUpload.version;\n}\n\n]);\n\nngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function ($parse, $timeout, $compile, $q, UploadExif) {\n  var upload = UploadExif;\n  upload.getAttrWithDefaults = function (attr, name) {\n    if (attr[name] != null) return attr[name];\n    var def = upload.defaults[name];\n    return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));\n  };\n\n  upload.attrGetter = function (name, attr, scope, params) {\n    var attrVal = this.getAttrWithDefaults(attr, name);\n    if (scope) {\n      try {\n        if (params) {\n          return $parse(attrVal)(scope, params);\n        } else {\n          return $parse(attrVal)(scope);\n        }\n      } catch (e) {\n        // hangle string value without single qoute\n        if (name.search(/min|max|pattern/i)) {\n          return attrVal;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      return attrVal;\n    }\n  };\n\n  upload.shouldUpdateOn = function (type, attr, scope) {\n    var modelOptions = upload.attrGetter('ngfModelOptions', attr, scope);\n    if (modelOptions && modelOptions.updateOn) {\n      return modelOptions.updateOn.split(' ').indexOf(type) > -1;\n    }\n    return true;\n  };\n\n  upload.emptyPromise = function () {\n    var d = $q.defer();\n    var args = arguments;\n    $timeout(function () {\n      d.resolve.apply(d, args);\n    });\n    return d.promise;\n  };\n\n  upload.rejectPromise = function () {\n    var d = $q.defer();\n    var args = arguments;\n    $timeout(function () {\n      d.reject.apply(d, args);\n    });\n    return d.promise;\n  };\n\n  upload.happyPromise = function (promise, data) {\n    var d = $q.defer();\n    promise.then(function (result) {\n      d.resolve(result);\n    }, function (error) {\n      $timeout(function () {\n        throw error;\n      });\n      d.resolve(data);\n    });\n    return d.promise;\n  };\n\n  function applyExifRotations(files, attr, scope) {\n    var promises = [upload.emptyPromise()];\n    angular.forEach(files, function (f, i) {\n      if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, {$file: f})) {\n        promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function (fixedFile) {\n          files.splice(i, 1, fixedFile);\n        }));\n      }\n    });\n    return $q.all(promises);\n  }\n\n  function resizeFile(files, attr, scope, ngModel) {\n    var resizeVal = upload.attrGetter('ngfResize', attr, scope);\n    if (!resizeVal || !upload.isResizeSupported() || !files.length) return upload.emptyPromise();\n    if (resizeVal instanceof Function) {\n      var defer = $q.defer();\n      return resizeVal(files).then(function (p) {\n        resizeWithParams(p, files, attr, scope, ngModel).then(function (r) {\n          defer.resolve(r);\n        }, function (e) {\n          defer.reject(e);\n        });\n      }, function (e) {\n        defer.reject(e);\n      });\n    } else {\n      return resizeWithParams(resizeVal, files, attr, scope, ngModel);\n    }\n  }\n\n  function resizeWithParams(params, files, attr, scope, ngModel) {\n    var promises = [upload.emptyPromise()];\n\n    function handleFile(f, i) {\n      if (f.type.indexOf('image') === 0) {\n        if (params.pattern && !upload.validatePattern(f, params.pattern)) return;\n        params.resizeIf = function (width, height) {\n          return upload.attrGetter('ngfResizeIf', attr, scope,\n            {$width: width, $height: height, $file: f});\n        };\n        var promise = upload.resize(f, params);\n        promises.push(promise);\n        promise.then(function (resizedFile) {\n          files.splice(i, 1, resizedFile);\n        }, function (e) {\n          f.$error = 'resize';\n          (f.$errorMessages = (f.$errorMessages || {})).resize = true;\n          f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);\n          ngModel.$ngfValidations.push({name: 'resize', valid: false});\n          upload.applyModelValidation(ngModel, files);\n        });\n      }\n    }\n\n    for (var i = 0; i < files.length; i++) {\n      handleFile(files[i], i);\n    }\n    return $q.all(promises);\n  }\n\n  upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {\n    function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {\n      attr.$$ngfPrevValidFiles = files;\n      attr.$$ngfPrevInvalidFiles = invalidFiles;\n      var file = files && files.length ? files[0] : null;\n      var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;\n\n      if (ngModel) {\n        upload.applyModelValidation(ngModel, files);\n        ngModel.$setViewValue(isSingleModel ? file : files);\n      }\n\n      if (fileChange) {\n        $parse(fileChange)(scope, {\n          $files: files,\n          $file: file,\n          $newFiles: newFiles,\n          $duplicateFiles: dupFiles,\n          $invalidFiles: invalidFiles,\n          $invalidFile: invalidFile,\n          $event: evt\n        });\n      }\n\n      var invalidModel = upload.attrGetter('ngfModelInvalid', attr);\n      if (invalidModel) {\n        $timeout(function () {\n          $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);\n        });\n      }\n      $timeout(function () {\n        // scope apply changes\n      });\n    }\n\n    var allNewFiles, dupFiles = [], prevValidFiles, prevInvalidFiles,\n      invalids = [], valids = [];\n\n    function removeDuplicates() {\n      function equals(f1, f2) {\n        return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) &&\n          f1.type === f2.type;\n      }\n\n      function isInPrevFiles(f) {\n        var j;\n        for (j = 0; j < prevValidFiles.length; j++) {\n          if (equals(f, prevValidFiles[j])) {\n            return true;\n          }\n        }\n        for (j = 0; j < prevInvalidFiles.length; j++) {\n          if (equals(f, prevInvalidFiles[j])) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      if (files) {\n        allNewFiles = [];\n        dupFiles = [];\n        for (var i = 0; i < files.length; i++) {\n          if (isInPrevFiles(files[i])) {\n            dupFiles.push(files[i]);\n          } else {\n            allNewFiles.push(files[i]);\n          }\n        }\n      }\n    }\n\n    function toArray(v) {\n      return angular.isArray(v) ? v : [v];\n    }\n\n    function resizeAndUpdate() {\n      function updateModel() {\n        $timeout(function () {\n          update(keep ? prevValidFiles.concat(valids) : valids,\n            keep ? prevInvalidFiles.concat(invalids) : invalids,\n            files, dupFiles, isSingleModel);\n        }, options && options.debounce ? options.debounce.change || options.debounce : 0);\n      }\n\n      var resizingFiles = validateAfterResize ? allNewFiles : valids;\n      resizeFile(resizingFiles, attr, scope, ngModel).then(function () {\n        if (validateAfterResize) {\n          upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)\n            .then(function (validationResult) {\n              valids = validationResult.validsFiles;\n              invalids = validationResult.invalidsFiles;\n              updateModel();\n            });\n        } else {\n          updateModel();\n        }\n      }, function () {\n        for (var i = 0; i < resizingFiles.length; i++) {\n          var f = resizingFiles[i];\n          if (f.$error === 'resize') {\n            var index = valids.indexOf(f);\n            if (index > -1) {\n              valids.splice(index, 1);\n              invalids.push(f);\n            }\n            updateModel();\n          }\n        }\n      });\n    }\n\n    prevValidFiles = attr.$$ngfPrevValidFiles || [];\n    prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];\n    if (ngModel && ngModel.$modelValue) {\n      prevValidFiles = toArray(ngModel.$modelValue);\n    }\n\n    var keep = upload.attrGetter('ngfKeep', attr, scope);\n    allNewFiles = (files || []).slice(0);\n    if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {\n      removeDuplicates(attr, scope);\n    }\n\n    var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);\n\n    if (keep && !allNewFiles.length) return;\n\n    upload.attrGetter('ngfBeforeModelChange', attr, scope, {\n      $files: files,\n      $file: files && files.length ? files[0] : null,\n      $newFiles: allNewFiles,\n      $duplicateFiles: dupFiles,\n      $event: evt\n    });\n\n    var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);\n\n    var options = upload.attrGetter('ngfModelOptions', attr, scope);\n    upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)\n      .then(function (validationResult) {\n      if (noDelay) {\n        update(allNewFiles, [], files, dupFiles, isSingleModel);\n      } else {\n        if ((!options || !options.allowInvalid) && !validateAfterResize) {\n          valids = validationResult.validFiles;\n          invalids = validationResult.invalidFiles;\n        } else {\n          valids = allNewFiles;\n        }\n        if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {\n          applyExifRotations(valids, attr, scope).then(function () {\n            resizeAndUpdate();\n          });\n        } else {\n          resizeAndUpdate();\n        }\n      }\n    });\n  };\n\n  return upload;\n}]);\n\nngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {\n  var generatedElems = [];\n\n  function isDelayedClickSupported(ua) {\n    // fix for android native browser < 4.4 and safari windows\n    var m = ua.match(/Android[^\\d]*(\\d+)\\.(\\d+)/);\n    if (m && m.length > 2) {\n      var v = Upload.defaults.androidFixMinorVersion || 4;\n      return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);\n    }\n\n    // safari on windows\n    return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);\n  }\n\n  function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {\n    /** @namespace attr.ngfSelect */\n    /** @namespace attr.ngfChange */\n    /** @namespace attr.ngModel */\n    /** @namespace attr.ngfModelOptions */\n    /** @namespace attr.ngfMultiple */\n    /** @namespace attr.ngfCapture */\n    /** @namespace attr.ngfValidate */\n    /** @namespace attr.ngfKeep */\n    var attrGetter = function (name, scope) {\n      return upload.attrGetter(name, attr, scope);\n    };\n\n    function isInputTypeFile() {\n      return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';\n    }\n\n    function fileChangeAttr() {\n      return attrGetter('ngfChange') || attrGetter('ngfSelect');\n    }\n\n    function changeFn(evt) {\n      if (upload.shouldUpdateOn('change', attr, scope)) {\n        var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];\n        /* Handle duplicate call in  IE11 */\n        if (!fileList) return;\n        for (var i = 0; i < fileList.length; i++) {\n          files.push(fileList[i]);\n        }\n        upload.updateModel(ngModel, attr, scope, fileChangeAttr(),\n          files.length ? files : null, evt);\n      }\n    }\n\n    upload.registerModelChangeValidator(ngModel, attr, scope);\n\n    var unwatches = [];\n    if (attrGetter('ngfMultiple')) {\n      unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {\n        fileElem.attr('multiple', attrGetter('ngfMultiple', scope));\n      }));\n    }\n    if (attrGetter('ngfCapture')) {\n      unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {\n        fileElem.attr('capture', attrGetter('ngfCapture', scope));\n      }));\n    }\n    if (attrGetter('ngfAccept')) {\n      unwatches.push(scope.$watch(attrGetter('ngfAccept'), function () {\n        fileElem.attr('accept', attrGetter('ngfAccept', scope));\n      }));\n    }\n    unwatches.push(attr.$observe('accept', function () {\n      fileElem.attr('accept', attrGetter('accept'));\n    }));\n    function bindAttrToFileInput(fileElem, label) {\n      function updateId(val) {\n        fileElem.attr('id', 'ngf-' + val);\n        label.attr('id', 'ngf-label-' + val);\n      }\n\n      for (var i = 0; i < elem[0].attributes.length; i++) {\n        var attribute = elem[0].attributes[i];\n        if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {\n          if (attribute.name === 'id') {\n            updateId(attribute.value);\n            unwatches.push(attr.$observe('id', updateId));\n          } else {\n            fileElem.attr(attribute.name, (!attribute.value && (attribute.name === 'required' ||\n            attribute.name === 'multiple')) ? attribute.name : attribute.value);\n          }\n        }\n      }\n    }\n\n    function createFileInput() {\n      if (isInputTypeFile()) {\n        return elem;\n      }\n\n      var fileElem = angular.element('<input type=\"file\">');\n\n      var label = angular.element('<label>upload</label>');\n      label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')\n        .css('width', '0px').css('height', '0px').css('border', 'none')\n        .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');\n      bindAttrToFileInput(fileElem, label);\n\n      generatedElems.push({el: elem, ref: label});\n\n      document.body.appendChild(label.append(fileElem)[0]);\n\n      return fileElem;\n    }\n\n    function clickHandler(evt) {\n      if (elem.attr('disabled')) return false;\n      if (attrGetter('ngfSelectDisabled', scope)) return;\n\n      var r = detectSwipe(evt);\n      // prevent the click if it is a swipe\n      if (r != null) return r;\n\n      resetModel(evt);\n\n      // fix for md when the element is removed from the DOM and added back #460\n      try {\n        if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {\n          generatedElems.push({el: elem, ref: fileElem.parent()});\n          document.body.appendChild(fileElem.parent()[0]);\n          fileElem.bind('change', changeFn);\n        }\n      } catch (e) {/*ignore*/\n      }\n\n      if (isDelayedClickSupported(navigator.userAgent)) {\n        setTimeout(function () {\n          fileElem[0].click();\n        }, 0);\n      } else {\n        fileElem[0].click();\n      }\n\n      return false;\n    }\n\n\n    var initialTouchStartY = 0;\n    var initialTouchStartX = 0;\n\n    function detectSwipe(evt) {\n      var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);\n      if (touches) {\n        if (evt.type === 'touchstart') {\n          initialTouchStartX = touches[0].clientX;\n          initialTouchStartY = touches[0].clientY;\n          return true; // don't block event default\n        } else {\n          // prevent scroll from triggering event\n          if (evt.type === 'touchend') {\n            var currentX = touches[0].clientX;\n            var currentY = touches[0].clientY;\n            if ((Math.abs(currentX - initialTouchStartX) > 20) ||\n              (Math.abs(currentY - initialTouchStartY) > 20)) {\n              evt.stopPropagation();\n              evt.preventDefault();\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n    }\n\n    var fileElem = elem;\n\n    function resetModel(evt) {\n      if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {\n        fileElem.val(null);\n        upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);\n      }\n    }\n\n    if (!isInputTypeFile()) {\n      fileElem = createFileInput();\n    }\n    fileElem.bind('change', changeFn);\n\n    if (!isInputTypeFile()) {\n      elem.bind('click touchstart touchend', clickHandler);\n    } else {\n      elem.bind('click', resetModel);\n    }\n\n    function ie10SameFileSelectFix(evt) {\n      if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {\n        if (!fileElem[0].parentNode) {\n          fileElem = null;\n          return;\n        }\n        evt.preventDefault();\n        evt.stopPropagation();\n        fileElem.unbind('click');\n        var clone = fileElem.clone();\n        fileElem.replaceWith(clone);\n        fileElem = clone;\n        fileElem.attr('__ngf_ie10_Fix_', 'true');\n        fileElem.bind('change', changeFn);\n        fileElem.bind('click', ie10SameFileSelectFix);\n        fileElem[0].click();\n        return false;\n      } else {\n        fileElem.removeAttr('__ngf_ie10_Fix_');\n      }\n    }\n\n    if (navigator.appVersion.indexOf('MSIE 10') !== -1) {\n      fileElem.bind('click', ie10SameFileSelectFix);\n    }\n\n    if (ngModel) ngModel.$formatters.push(function (val) {\n      if (val == null || val.length === 0) {\n        if (fileElem.val()) {\n          fileElem.val(null);\n        }\n      }\n      return val;\n    });\n\n    scope.$on('$destroy', function () {\n      if (!isInputTypeFile()) fileElem.parent().remove();\n      angular.forEach(unwatches, function (unwatch) {\n        unwatch();\n      });\n    });\n\n    $timeout(function () {\n      for (var i = 0; i < generatedElems.length; i++) {\n        var g = generatedElems[i];\n        if (!document.body.contains(g.el[0])) {\n          generatedElems.splice(i, 1);\n          g.ref.remove();\n        }\n      }\n    });\n\n    if (window.FileAPI && window.FileAPI.ngfFixIE) {\n      window.FileAPI.ngfFixIE(elem, fileElem, changeFn);\n    }\n  }\n\n  return {\n    restrict: 'AEC',\n    require: '?ngModel',\n    link: function (scope, elem, attr, ngModel) {\n      linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);\n    }\n  };\n}]);\n\n(function () {\n\n  ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {\n    var upload = UploadBase;\n    upload.base64DataUrl = function (file) {\n      if (angular.isArray(file)) {\n        var d = $q.defer(), count = 0;\n        angular.forEach(file, function (f) {\n          upload.dataUrl(f, true)['finally'](function () {\n            count++;\n            if (count === file.length) {\n              var urls = [];\n              angular.forEach(file, function (ff) {\n                urls.push(ff.$ngfDataUrl);\n              });\n              d.resolve(urls, file);\n            }\n          });\n        });\n        return d.promise;\n      } else {\n        return upload.dataUrl(file, true);\n      }\n    };\n    upload.dataUrl = function (file, disallowObjectUrl) {\n      if (!file) return upload.emptyPromise(file, file);\n      if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {\n        return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);\n      }\n      var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;\n      if (p) return p;\n\n      var deferred = $q.defer();\n      $timeout(function () {\n        if (window.FileReader && file &&\n          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&\n          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {\n          //prefer URL.createObjectURL for handling refrences to files of all sizes\n          //since it doesnt build a large string in memory\n          var URL = window.URL || window.webkitURL;\n          if (URL && URL.createObjectURL && !disallowObjectUrl) {\n            var url;\n            try {\n              url = URL.createObjectURL(file);\n            } catch (e) {\n              $timeout(function () {\n                file.$ngfBlobUrl = '';\n                deferred.reject();\n              });\n              return;\n            }\n            $timeout(function () {\n              file.$ngfBlobUrl = url;\n              if (url) {\n                deferred.resolve(url, file);\n                upload.blobUrls = upload.blobUrls || [];\n                upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;\n                upload.blobUrls.push({url: url, size: file.size});\n                upload.blobUrlsTotalSize += file.size || 0;\n                var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;\n                var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;\n                while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {\n                  var obj = upload.blobUrls.splice(0, 1)[0];\n                  URL.revokeObjectURL(obj.url);\n                  upload.blobUrlsTotalSize -= obj.size;\n                }\n              }\n            });\n          } else {\n            var fileReader = new FileReader();\n            fileReader.onload = function (e) {\n              $timeout(function () {\n                file.$ngfDataUrl = e.target.result;\n                deferred.resolve(e.target.result, file);\n                $timeout(function () {\n                  delete file.$ngfDataUrl;\n                }, 1000);\n              });\n            };\n            fileReader.onerror = function () {\n              $timeout(function () {\n                file.$ngfDataUrl = '';\n                deferred.reject();\n              });\n            };\n            fileReader.readAsDataURL(file);\n          }\n        } else {\n          $timeout(function () {\n            file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';\n            deferred.reject();\n          });\n        }\n      });\n\n      if (disallowObjectUrl) {\n        p = file.$$ngfDataUrlPromise = deferred.promise;\n      } else {\n        p = file.$$ngfBlobUrlPromise = deferred.promise;\n      }\n      p['finally'](function () {\n        delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];\n      });\n      return p;\n    };\n    return upload;\n  }]);\n\n  function getTagType(el) {\n    if (el.tagName.toLowerCase() === 'img') return 'image';\n    if (el.tagName.toLowerCase() === 'audio') return 'audio';\n    if (el.tagName.toLowerCase() === 'video') return 'video';\n    return /./;\n  }\n\n  function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {\n    function constructDataUrl(file) {\n      var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);\n      Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {\n        $timeout(function () {\n          var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;\n          if (isBackground) {\n            elem.css('background-image', 'url(\\'' + (src || '') + '\\')');\n          } else {\n            elem.attr('src', src);\n          }\n          if (src) {\n            elem.removeClass('ng-hide');\n          } else {\n            elem.addClass('ng-hide');\n          }\n        });\n      });\n    }\n\n    $timeout(function () {\n      var unwatch = scope.$watch(attr[directiveName], function (file) {\n        var size = resizeParams;\n        if (directiveName === 'ngfThumbnail') {\n          if (!size) {\n            size = {\n              width: elem[0].naturalWidth || elem[0].clientWidth,\n              height: elem[0].naturalHeight || elem[0].clientHeight\n            };\n          }\n          if (size.width === 0 && window.getComputedStyle) {\n            var style = getComputedStyle(elem[0]);\n            if (style.width && style.width.indexOf('px') > -1 && style.height && style.height.indexOf('px') > -1) {\n              size = {\n                width: parseInt(style.width.slice(0, -2)),\n                height: parseInt(style.height.slice(0, -2))\n              };\n            }\n          }\n        }\n\n        if (angular.isString(file)) {\n          elem.removeClass('ng-hide');\n          if (isBackground) {\n            return elem.css('background-image', 'url(\\'' + file + '\\')');\n          } else {\n            return elem.attr('src', file);\n          }\n        }\n        if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&\n          (!isBackground || file.type.indexOf('image') === 0)) {\n          if (size && Upload.isResizeSupported()) {\n            size.resizeIf = function (width, height) {\n              return Upload.attrGetter('ngfResizeIf', attr, scope,\n                {$width: width, $height: height, $file: file});\n            };\n            Upload.resize(file, size).then(\n              function (f) {\n                constructDataUrl(f);\n              }, function (e) {\n                throw e;\n              }\n            );\n          } else {\n            constructDataUrl(file);\n          }\n        } else {\n          elem.addClass('ng-hide');\n        }\n      });\n\n      scope.$on('$destroy', function () {\n        unwatch();\n      });\n    });\n  }\n\n\n  /** @namespace attr.ngfSrc */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',\n          Upload.attrGetter('ngfResize', attr, scope), false);\n      }\n    };\n  }]);\n\n  /** @namespace attr.ngfBackground */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',\n          Upload.attrGetter('ngfResize', attr, scope), true);\n      }\n    };\n  }]);\n\n  /** @namespace attr.ngfThumbnail */\n  /** @namespace attr.ngfAsBackground */\n  /** @namespace attr.ngfSize */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        var size = Upload.attrGetter('ngfSize', attr, scope);\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,\n          Upload.attrGetter('ngfAsBackground', attr, scope));\n      }\n    };\n  }]);\n\n  ngFileUpload.config(['$compileProvider', function ($compileProvider) {\n    if ($compileProvider.imgSrcSanitizationWhitelist) $compileProvider.imgSrcSanitizationWhitelist(/^\\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);\n    if ($compileProvider.aHrefSanitizationWhitelist) $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);\n  }]);\n\n  ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {\n    return function (file, disallowObjectUrl, trustedUrl) {\n      if (angular.isString(file)) {\n        return $sce.trustAsResourceUrl(file);\n      }\n      var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);\n      if (file && !src) {\n        if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {\n          file.$ngfDataUrlFilterInProgress = true;\n          UploadDataUrl.dataUrl(file, disallowObjectUrl);\n        }\n        return '';\n      }\n      if (file) delete file.$ngfDataUrlFilterInProgress;\n      return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';\n    };\n  }]);\n\n})();\n\nngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {\n  var upload = UploadDataUrl;\n\n  function globStringToRegex(str) {\n    var regexp = '', excludes = [];\n    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {\n      regexp = str.substring(1, str.length - 1);\n    } else {\n      var split = str.split(',');\n      if (split.length > 1) {\n        for (var i = 0; i < split.length; i++) {\n          var r = globStringToRegex(split[i]);\n          if (r.regexp) {\n            regexp += '(' + r.regexp + ')';\n            if (i < split.length - 1) {\n              regexp += '|';\n            }\n          } else {\n            excludes = excludes.concat(r.excludes);\n          }\n        }\n      } else {\n        if (str.indexOf('!') === 0) {\n          excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');\n        } else {\n          if (str.indexOf('.') === 0) {\n            str = '*' + str;\n          }\n          regexp = '^' + str.replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\-]', 'g'), '\\\\$&') + '$';\n          regexp = regexp.replace(/\\\\\\*/g, '.*').replace(/\\\\\\?/g, '.');\n        }\n      }\n    }\n    return {regexp: regexp, excludes: excludes};\n  }\n\n  upload.validatePattern = function (file, val) {\n    if (!val) {\n      return true;\n    }\n    var pattern = globStringToRegex(val), valid = true;\n    if (pattern.regexp && pattern.regexp.length) {\n      var regexp = new RegExp(pattern.regexp, 'i');\n      valid = (file.type != null && regexp.test(file.type)) ||\n        (file.name != null && regexp.test(file.name));\n    }\n    var len = pattern.excludes.length;\n    while (len--) {\n      var exclude = new RegExp(pattern.excludes[len], 'i');\n      valid = valid && (file.type == null || exclude.test(file.type)) &&\n        (file.name == null || exclude.test(file.name));\n    }\n    return valid;\n  };\n\n  upload.ratioToFloat = function (val) {\n    var r = val.toString(), xIndex = r.search(/[x:]/i);\n    if (xIndex > -1) {\n      r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));\n    } else {\n      r = parseFloat(r);\n    }\n    return r;\n  };\n\n  upload.registerModelChangeValidator = function (ngModel, attr, scope) {\n    if (ngModel) {\n      ngModel.$formatters.push(function (files) {\n        if (ngModel.$dirty) {\n          var filesArray = files;\n          if (files && !angular.isArray(files)) {\n            filesArray = [files];\n          }\n          upload.validate(filesArray, 0, ngModel, attr, scope).then(function () {\n            upload.applyModelValidation(ngModel, filesArray);\n          });\n        }\n        return files;\n      });\n    }\n  };\n\n  function markModelAsDirty(ngModel, files) {\n    if (files != null && !ngModel.$dirty) {\n      if (ngModel.$setDirty) {\n        ngModel.$setDirty();\n      } else {\n        ngModel.$dirty = true;\n      }\n    }\n  }\n\n  upload.applyModelValidation = function (ngModel, files) {\n    markModelAsDirty(ngModel, files);\n    angular.forEach(ngModel.$ngfValidations, function (validation) {\n      ngModel.$setValidity(validation.name, validation.valid);\n    });\n  };\n\n  upload.getValidationAttr = function (attr, scope, name, validationName, file) {\n    var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);\n    var val = upload.attrGetter(dName, attr, scope, {$file: file});\n    if (val == null) {\n      val = upload.attrGetter('ngfValidate', attr, scope, {$file: file});\n      if (val) {\n        var split = (validationName || name).split('.');\n        val = val[split[0]];\n        if (split.length > 1) {\n          val = val && val[split[1]];\n        }\n      }\n    }\n    return val;\n  };\n\n  upload.validate = function (files, prevLength, ngModel, attr, scope) {\n    ngModel = ngModel || {};\n    ngModel.$ngfValidations = ngModel.$ngfValidations || [];\n\n    angular.forEach(ngModel.$ngfValidations, function (v) {\n      v.valid = true;\n    });\n\n    var attrGetter = function (name, params) {\n      return upload.attrGetter(name, attr, scope, params);\n    };\n\n    var ignoredErrors = (upload.attrGetter('ngfIgnoreInvalid', attr, scope) || '').split(' ');\n    var runAllValidation = upload.attrGetter('ngfRunAllValidations', attr, scope);\n\n    if (files == null || files.length === 0) {\n      return upload.emptyPromise({'validFiles': files, 'invalidFiles': []});\n    }\n\n    files = files.length === undefined ? [files] : files.slice(0);\n    var invalidFiles = [];\n\n    function validateSync(name, validationName, fn) {\n      if (files) {\n        var i = files.length, valid = null;\n        while (i--) {\n          var file = files[i];\n          if (file) {\n            var val = upload.getValidationAttr(attr, scope, name, validationName, file);\n            if (val != null) {\n              if (!fn(file, val, i)) {\n                if (ignoredErrors.indexOf(name) === -1) {\n                  file.$error = name;\n                  (file.$errorMessages = (file.$errorMessages || {}))[name] = true;\n                  file.$errorParam = val;\n                  if (invalidFiles.indexOf(file) === -1) {\n                    invalidFiles.push(file);\n                  }\n                  if (!runAllValidation) {\n                    files.splice(i, 1);\n                  }\n                  valid = false;\n                } else {\n                  files.splice(i, 1);\n                }\n              }\n            }\n          }\n        }\n        if (valid !== null) {\n          ngModel.$ngfValidations.push({name: name, valid: valid});\n        }\n      }\n    }\n\n    validateSync('pattern', null, upload.validatePattern);\n    validateSync('minSize', 'size.min', function (file, val) {\n      return file.size + 0.1 >= upload.translateScalars(val);\n    });\n    validateSync('maxSize', 'size.max', function (file, val) {\n      return file.size - 0.1 <= upload.translateScalars(val);\n    });\n    var totalSize = 0;\n    validateSync('maxTotalSize', null, function (file, val) {\n      totalSize += file.size;\n      if (totalSize > upload.translateScalars(val)) {\n        files.splice(0, files.length);\n        return false;\n      }\n      return true;\n    });\n\n    validateSync('validateFn', null, function (file, r) {\n      return r === true || r === null || r === '';\n    });\n\n    if (!files.length) {\n      return upload.emptyPromise({'validFiles': [], 'invalidFiles': invalidFiles});\n    }\n\n    function validateAsync(name, validationName, type, asyncFn, fn) {\n      function resolveResult(defer, file, val) {\n        function resolveInternal(fn) {\n          if (fn()) {\n            if (ignoredErrors.indexOf(name) === -1) {\n              file.$error = name;\n              (file.$errorMessages = (file.$errorMessages || {}))[name] = true;\n              file.$errorParam = val;\n              if (invalidFiles.indexOf(file) === -1) {\n                invalidFiles.push(file);\n              }\n              if (!runAllValidation) {\n                var i = files.indexOf(file);\n                if (i > -1) files.splice(i, 1);\n              }\n              defer.resolve(false);\n            } else {\n              var j = files.indexOf(file);\n              if (j > -1) files.splice(j, 1);\n              defer.resolve(true);\n            }\n          } else {\n            defer.resolve(true);\n          }\n        }\n\n        if (val != null) {\n          asyncFn(file, val).then(function (d) {\n            resolveInternal(function () {\n              return !fn(d, val);\n            });\n          }, function () {\n            resolveInternal(function () {\n              return attrGetter('ngfValidateForce', {$file: file});\n            });\n          });\n        } else {\n          defer.resolve(true);\n        }\n      }\n\n      var promises = [upload.emptyPromise(true)];\n      if (files) {\n        files = files.length === undefined ? [files] : files;\n        angular.forEach(files, function (file) {\n          var defer = $q.defer();\n          promises.push(defer.promise);\n          if (type && (file.type == null || file.type.search(type) !== 0)) {\n            defer.resolve(true);\n            return;\n          }\n          if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {\n            upload.imageDimensions(file).then(function (d) {\n              resolveResult(defer, file,\n                attrGetter('ngfDimensions', {$file: file, $width: d.width, $height: d.height}));\n            }, function () {\n              defer.resolve(false);\n            });\n          } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {\n            upload.mediaDuration(file).then(function (d) {\n              resolveResult(defer, file,\n                attrGetter('ngfDuration', {$file: file, $duration: d}));\n            }, function () {\n              defer.resolve(false);\n            });\n          } else {\n            resolveResult(defer, file,\n              upload.getValidationAttr(attr, scope, name, validationName, file));\n          }\n        });\n      }\n      var deffer = $q.defer();\n      $q.all(promises).then(function (values) {\n        var isValid = true;\n        for (var i = 0; i < values.length; i++) {\n          if (!values[i]) {\n            isValid = false;\n            break;\n          }\n        }\n        ngModel.$ngfValidations.push({name: name, valid: isValid});\n        deffer.resolve(isValid);\n      });\n      return deffer.promise;\n    }\n\n    var deffer = $q.defer();\n    var promises = [];\n\n    promises.push(validateAsync('maxHeight', 'height.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.height <= val;\n      }));\n    promises.push(validateAsync('minHeight', 'height.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.height >= val;\n      }));\n    promises.push(validateAsync('maxWidth', 'width.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.width <= val;\n      }));\n    promises.push(validateAsync('minWidth', 'width.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.width >= val;\n      }));\n    promises.push(validateAsync('dimensions', null, /image/,\n      function (file, val) {\n        return upload.emptyPromise(val);\n      }, function (r) {\n        return r;\n      }));\n    promises.push(validateAsync('ratio', null, /image/,\n      this.imageDimensions, function (d, val) {\n        var split = val.toString().split(','), valid = false;\n        for (var i = 0; i < split.length; i++) {\n          if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.01) {\n            valid = true;\n          }\n        }\n        return valid;\n      }));\n    promises.push(validateAsync('maxRatio', 'ratio.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;\n      }));\n    promises.push(validateAsync('minRatio', 'ratio.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;\n      }));\n    promises.push(validateAsync('maxDuration', 'duration.max', /audio|video/,\n      this.mediaDuration, function (d, val) {\n        return d <= upload.translateScalars(val);\n      }));\n    promises.push(validateAsync('minDuration', 'duration.min', /audio|video/,\n      this.mediaDuration, function (d, val) {\n        return d >= upload.translateScalars(val);\n      }));\n    promises.push(validateAsync('duration', null, /audio|video/,\n      function (file, val) {\n        return upload.emptyPromise(val);\n      }, function (r) {\n        return r;\n      }));\n\n    promises.push(validateAsync('validateAsyncFn', null, null,\n      function (file, val) {\n        return val;\n      }, function (r) {\n        return r === true || r === null || r === '';\n      }));\n\n    $q.all(promises).then(function () {\n\n      if (runAllValidation) {\n        for (var i = 0; i < files.length; i++) {\n          var file = files[i];\n          if (file.$error) {\n            files.splice(i--, 1);\n          }\n        }\n      }\n\n      runAllValidation = false;\n      validateSync('maxFiles', null, function (file, val, i) {\n        return prevLength + i < val;\n      });\n\n      deffer.resolve({'validFiles': files, 'invalidFiles': invalidFiles});\n    });\n    return deffer.promise;\n  };\n\n  upload.imageDimensions = function (file) {\n    if (file.$ngfWidth && file.$ngfHeight) {\n      var d = $q.defer();\n      $timeout(function () {\n        d.resolve({width: file.$ngfWidth, height: file.$ngfHeight});\n      });\n      return d.promise;\n    }\n    if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;\n\n    var deferred = $q.defer();\n    $timeout(function () {\n      if (file.type.indexOf('image') !== 0) {\n        deferred.reject('not image');\n        return;\n      }\n      upload.dataUrl(file).then(function (dataUrl) {\n        var img = angular.element('<img>').attr('src', dataUrl)\n          .css('visibility', 'hidden').css('position', 'fixed')\n          .css('max-width', 'none !important').css('max-height', 'none !important');\n\n        function success() {\n          var width = img[0].naturalWidth || img[0].clientWidth;\n          var height = img[0].naturalHeight || img[0].clientHeight;\n          img.remove();\n          file.$ngfWidth = width;\n          file.$ngfHeight = height;\n          deferred.resolve({width: width, height: height});\n        }\n\n        function error() {\n          img.remove();\n          deferred.reject('load error');\n        }\n\n        img.on('load', success);\n        img.on('error', error);\n\n        var secondsCounter = 0;\n        function checkLoadErrorInCaseOfNoCallback() {\n          $timeout(function () {\n            if (img[0].parentNode) {\n              if (img[0].clientWidth) {\n                success();\n              } else if (secondsCounter++ > 10) {\n                error();\n              } else {\n                checkLoadErrorInCaseOfNoCallback();\n              }\n            }\n          }, 1000);\n        }\n\n        checkLoadErrorInCaseOfNoCallback();\n\n        angular.element(document.getElementsByTagName('body')[0]).append(img);\n      }, function () {\n        deferred.reject('load error');\n      });\n    });\n\n    file.$ngfDimensionPromise = deferred.promise;\n    file.$ngfDimensionPromise['finally'](function () {\n      delete file.$ngfDimensionPromise;\n    });\n    return file.$ngfDimensionPromise;\n  };\n\n  upload.mediaDuration = function (file) {\n    if (file.$ngfDuration) {\n      var d = $q.defer();\n      $timeout(function () {\n        d.resolve(file.$ngfDuration);\n      });\n      return d.promise;\n    }\n    if (file.$ngfDurationPromise) return file.$ngfDurationPromise;\n\n    var deferred = $q.defer();\n    $timeout(function () {\n      if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {\n        deferred.reject('not media');\n        return;\n      }\n      upload.dataUrl(file).then(function (dataUrl) {\n        var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')\n          .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');\n\n        function success() {\n          var duration = el[0].duration;\n          file.$ngfDuration = duration;\n          el.remove();\n          deferred.resolve(duration);\n        }\n\n        function error() {\n          el.remove();\n          deferred.reject('load error');\n        }\n\n        el.on('loadedmetadata', success);\n        el.on('error', error);\n        var count = 0;\n\n        function checkLoadError() {\n          $timeout(function () {\n            if (el[0].parentNode) {\n              if (el[0].duration) {\n                success();\n              } else if (count > 10) {\n                error();\n              } else {\n                checkLoadError();\n              }\n            }\n          }, 1000);\n        }\n\n        checkLoadError();\n\n        angular.element(document.body).append(el);\n      }, function () {\n        deferred.reject('load error');\n      });\n    });\n\n    file.$ngfDurationPromise = deferred.promise;\n    file.$ngfDurationPromise['finally'](function () {\n      delete file.$ngfDurationPromise;\n    });\n    return file.$ngfDurationPromise;\n  };\n  return upload;\n}\n]);\n\nngFileUpload.service('UploadResize', ['UploadValidate', '$q', function (UploadValidate, $q) {\n  var upload = UploadValidate;\n\n  /**\n   * Conserve aspect ratio of the original region. Useful when shrinking/enlarging\n   * images to fit into a certain area.\n   * Source:  http://stackoverflow.com/a/14731922\n   *\n   * @param {Number} srcWidth Source area width\n   * @param {Number} srcHeight Source area height\n   * @param {Number} maxWidth Nestable area maximum available width\n   * @param {Number} maxHeight Nestable area maximum available height\n   * @return {Object} { width, height }\n   */\n  var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {\n    var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) :\n      Math.min(maxWidth / srcWidth, maxHeight / srcHeight);\n    return {\n      width: srcWidth * ratio, height: srcHeight * ratio,\n      marginX: srcWidth * ratio - maxWidth, marginY: srcHeight * ratio - maxHeight\n    };\n  };\n\n  // Extracted from https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89\n  var resize = function (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {\n    var deferred = $q.defer();\n    var canvasElement = document.createElement('canvas');\n    var imageElement = document.createElement('img');\n    imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');\n    document.body.appendChild(imageElement);\n\n    imageElement.onload = function () {\n      var imgWidth = imageElement.width, imgHeight = imageElement.height;\n      imageElement.parentNode.removeChild(imageElement);\n      if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {\n        deferred.reject('resizeIf');\n        return;\n      }\n      try {\n        if (ratio) {\n          var ratioFloat = upload.ratioToFloat(ratio);\n          var imgRatio = imgWidth / imgHeight;\n          if (imgRatio < ratioFloat) {\n            width = imgWidth;\n            height = width / ratioFloat;\n          } else {\n            height = imgHeight;\n            width = height * ratioFloat;\n          }\n        }\n        if (!width) {\n          width = imgWidth;\n        }\n        if (!height) {\n          height = imgHeight;\n        }\n        var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);\n        canvasElement.width = Math.min(dimensions.width, width);\n        canvasElement.height = Math.min(dimensions.height, height);\n        var context = canvasElement.getContext('2d');\n        context.drawImage(imageElement,\n          Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),\n          dimensions.width, dimensions.height);\n        deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));\n      } catch (e) {\n        deferred.reject(e);\n      }\n    };\n    imageElement.onerror = function () {\n      imageElement.parentNode.removeChild(imageElement);\n      deferred.reject();\n    };\n    imageElement.src = imagen;\n    return deferred.promise;\n  };\n\n  upload.dataUrltoBlob = function (dataurl, name, origSize) {\n    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],\n      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n);\n    }\n    var blob = new window.Blob([u8arr], {type: mime});\n    blob.name = name;\n    blob.$ngfOrigSize = origSize;\n    return blob;\n  };\n\n  upload.isResizeSupported = function () {\n    var elem = document.createElement('canvas');\n    return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;\n  };\n\n  if (upload.isResizeSupported()) {\n    // add name getter to the blob constructor prototype\n    Object.defineProperty(window.Blob.prototype, 'name', {\n      get: function () {\n        return this.$ngfName;\n      },\n      set: function (v) {\n        this.$ngfName = v;\n      },\n      configurable: true\n    });\n  }\n\n  upload.resize = function (file, options) {\n    if (file.type.indexOf('image') !== 0) return upload.emptyPromise(file);\n\n    var deferred = $q.defer();\n    upload.dataUrl(file, true).then(function (url) {\n      resize(url, options.width, options.height, options.quality, options.type || file.type,\n        options.ratio, options.centerCrop, options.resizeIf)\n        .then(function (dataUrl) {\n          if (file.type === 'image/jpeg' && options.restoreExif !== false) {\n            try {\n              dataUrl = upload.restoreExif(url, dataUrl);\n            } catch (e) {\n              setTimeout(function () {throw e;}, 1);\n            }\n          }\n          try {\n            var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);\n            deferred.resolve(blob);\n          } catch (e) {\n            deferred.reject(e);\n          }\n        }, function (r) {\n          if (r === 'resizeIf') {\n            deferred.resolve(file);\n          }\n          deferred.reject(r);\n        });\n    }, function (e) {\n      deferred.reject(e);\n    });\n    return deferred.promise;\n  };\n\n  return upload;\n}]);\n\n(function () {\n  ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$window', 'Upload', '$http', '$q',\n    function ($parse, $timeout, $window, Upload, $http, $q) {\n      return {\n        restrict: 'AEC',\n        require: '?ngModel',\n        link: function (scope, elem, attr, ngModel) {\n          linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);\n        }\n      };\n    }]);\n\n  ngFileUpload.directive('ngfNoFileDrop', function () {\n    return function (scope, elem) {\n      if (dropAvailable()) elem.css('display', 'none');\n    };\n  });\n\n  ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {\n    return function (scope, elem, attr) {\n      if (dropAvailable()) {\n        var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));\n        $timeout(function () {\n          model(scope);\n          if (model.assign) {\n            model.assign(scope, true);\n          }\n        });\n      }\n    };\n  }]);\n\n  function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {\n    var available = dropAvailable();\n\n    var attrGetter = function (name, scope, params) {\n      return upload.attrGetter(name, attr, scope, params);\n    };\n\n    if (attrGetter('dropAvailable')) {\n      $timeout(function () {\n        if (scope[attrGetter('dropAvailable')]) {\n          scope[attrGetter('dropAvailable')].value = available;\n        } else {\n          scope[attrGetter('dropAvailable')] = available;\n        }\n      });\n    }\n    if (!available) {\n      if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {\n        elem.css('display', 'none');\n      }\n      return;\n    }\n\n    function isDisabled() {\n      return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);\n    }\n\n    if (attrGetter('ngfSelect') == null) {\n      upload.registerModelChangeValidator(ngModel, attr, scope);\n    }\n\n    var leaveTimeout = null;\n    var stopPropagation = $parse(attrGetter('ngfStopPropagation'));\n    var dragOverDelay = 1;\n    var actualDragOverClass;\n\n    elem[0].addEventListener('dragover', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      // handling dragover events from the Chrome download bar\n      if (navigator.userAgent.indexOf('Chrome') > -1) {\n        var b = evt.dataTransfer.effectAllowed;\n        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';\n      }\n      $timeout.cancel(leaveTimeout);\n      if (!actualDragOverClass) {\n        actualDragOverClass = 'C';\n        calculateDragOverClass(scope, attr, evt, function (clazz) {\n          actualDragOverClass = clazz;\n          elem.addClass(actualDragOverClass);\n          attrGetter('ngfDrag', scope, {$isDragging: true, $class: actualDragOverClass, $event: evt});\n        });\n      }\n    }, false);\n    elem[0].addEventListener('dragenter', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n    }, false);\n    elem[0].addEventListener('dragleave', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      leaveTimeout = $timeout(function () {\n        if (actualDragOverClass) elem.removeClass(actualDragOverClass);\n        actualDragOverClass = null;\n        attrGetter('ngfDrag', scope, {$isDragging: false, $event: evt});\n      }, dragOverDelay || 100);\n    }, false);\n    elem[0].addEventListener('drop', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      if (actualDragOverClass) elem.removeClass(actualDragOverClass);\n      actualDragOverClass = null;\n      extractFilesAndUpdateModel(evt.dataTransfer, evt, 'dropUrl');\n    }, false);\n    elem[0].addEventListener('paste', function (evt) {\n      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&\n        attrGetter('ngfEnableFirefoxPaste', scope)) {\n        evt.preventDefault();\n      }\n      if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope)) return;\n      extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, 'pasteUrl');\n    }, false);\n\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&\n      attrGetter('ngfEnableFirefoxPaste', scope)) {\n      elem.attr('contenteditable', true);\n      elem.on('keypress', function (e) {\n        if (!e.metaKey && !e.ctrlKey) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    function extractFilesAndUpdateModel(source, evt, updateOnType) {\n      if (!source) return;\n      // html needs to be calculated on the same process otherwise the data will be wiped\n      // after promise resolve or setTimeout.\n      var html;\n      try {\n        html = source && source.getData && source.getData('text/html');\n      } catch (e) {/* Fix IE11 that throw error calling getData */\n      }\n      extractFiles(source.items, source.files, attrGetter('ngfAllowDir', scope) !== false,\n        attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function (files) {\n        if (files.length) {\n          updateModel(files, evt);\n        } else {\n          extractFilesFromHtml(updateOnType, html).then(function (files) {\n            updateModel(files, evt);\n          });\n        }\n      });\n    }\n\n    function updateModel(files, evt) {\n      upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);\n    }\n\n    function extractFilesFromHtml(updateOn, html) {\n      if (!upload.shouldUpdateOn(updateOn, attr, scope) || typeof html !== 'string') return upload.rejectPromise([]);\n      var urls = [];\n      html.replace(/<(img src|img [^>]* src) *=\\\"([^\\\"]*)\\\"/gi, function (m, n, src) {\n        urls.push(src);\n      });\n      var promises = [], files = [];\n      if (urls.length) {\n        angular.forEach(urls, function (url) {\n          promises.push(upload.urlToBlob(url).then(function (blob) {\n            files.push(blob);\n          }));\n        });\n        var defer = $q.defer();\n        $q.all(promises).then(function () {\n          defer.resolve(files);\n        }, function (e) {\n          defer.reject(e);\n        });\n        return defer.promise;\n      }\n      return upload.emptyPromise();\n    }\n\n    function calculateDragOverClass(scope, attr, evt, callback) {\n      var obj = attrGetter('ngfDragOverClass', scope, {$event: evt}), dClass = 'dragover';\n      if (angular.isString(obj)) {\n        dClass = obj;\n      } else if (obj) {\n        if (obj.delay) dragOverDelay = obj.delay;\n        if (obj.accept || obj.reject) {\n          var items = evt.dataTransfer.items;\n          if (items == null || !items.length) {\n            dClass = obj.accept;\n          } else {\n            var pattern = obj.pattern || attrGetter('ngfPattern', scope, {$event: evt});\n            var len = items.length;\n            while (len--) {\n              if (!upload.validatePattern(items[len], pattern)) {\n                dClass = obj.reject;\n                break;\n              } else {\n                dClass = obj.accept;\n              }\n            }\n          }\n        }\n      }\n      callback(dClass);\n    }\n\n    function extractFiles(items, fileList, allowDir, multiple) {\n      var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles');\n      if (maxFiles == null) {\n        maxFiles = Number.MAX_VALUE;\n      }\n      var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize');\n      if (maxTotalSize == null) {\n        maxTotalSize = Number.MAX_VALUE;\n      }\n      var includeDir = attrGetter('ngfIncludeDir', scope);\n      var files = [], totalSize = 0;\n\n      function traverseFileTree(entry, path) {\n        var defer = $q.defer();\n        if (entry != null) {\n          if (entry.isDirectory) {\n            var promises = [upload.emptyPromise()];\n            if (includeDir) {\n              var file = {type: 'directory'};\n              file.name = file.path = (path || '') + entry.name;\n              files.push(file);\n            }\n            var dirReader = entry.createReader();\n            var entries = [];\n            var readEntries = function () {\n              dirReader.readEntries(function (results) {\n                try {\n                  if (!results.length) {\n                    angular.forEach(entries.slice(0), function (e) {\n                      if (files.length <= maxFiles && totalSize <= maxTotalSize) {\n                        promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));\n                      }\n                    });\n                    $q.all(promises).then(function () {\n                      defer.resolve();\n                    }, function (e) {\n                      defer.reject(e);\n                    });\n                  } else {\n                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));\n                    readEntries();\n                  }\n                } catch (e) {\n                  defer.reject(e);\n                }\n              }, function (e) {\n                defer.reject(e);\n              });\n            };\n            readEntries();\n          } else {\n            entry.file(function (file) {\n              try {\n                file.path = (path ? path : '') + file.name;\n                if (includeDir) {\n                  file = upload.rename(file, file.path);\n                }\n                files.push(file);\n                totalSize += file.size;\n                defer.resolve();\n              } catch (e) {\n                defer.reject(e);\n              }\n            }, function (e) {\n              defer.reject(e);\n            });\n          }\n        }\n        return defer.promise;\n      }\n\n      var promises = [upload.emptyPromise()];\n\n      if (items && items.length > 0 && $window.location.protocol !== 'file:') {\n        for (var i = 0; i < items.length; i++) {\n          if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {\n            var entry = items[i].webkitGetAsEntry();\n            if (entry.isDirectory && !allowDir) {\n              continue;\n            }\n            if (entry != null) {\n              promises.push(traverseFileTree(entry));\n            }\n          } else {\n            var f = items[i].getAsFile();\n            if (f != null) {\n              files.push(f);\n              totalSize += f.size;\n            }\n          }\n          if (files.length > maxFiles || totalSize > maxTotalSize ||\n            (!multiple && files.length > 0)) break;\n        }\n      } else {\n        if (fileList != null) {\n          for (var j = 0; j < fileList.length; j++) {\n            var file = fileList.item(j);\n            if (file.type || file.size > 0) {\n              files.push(file);\n              totalSize += file.size;\n            }\n            if (files.length > maxFiles || totalSize > maxTotalSize ||\n              (!multiple && files.length > 0)) break;\n          }\n        }\n      }\n\n      var defer = $q.defer();\n      $q.all(promises).then(function () {\n        if (!multiple && !includeDir && files.length) {\n          var i = 0;\n          while (files[i] && files[i].type === 'directory') i++;\n          defer.resolve([files[i]]);\n        } else {\n          defer.resolve(files);\n        }\n      }, function (e) {\n        defer.reject(e);\n      });\n\n      return defer.promise;\n    }\n  }\n\n  function dropAvailable() {\n    var div = document.createElement('div');\n    return ('draggable' in div) && ('ondrop' in div) && !/Edge\\/12./i.test(navigator.userAgent);\n  }\n\n})();\n\n// customized version of https://github.com/exif-js/exif-js\nngFileUpload.service('UploadExif', ['UploadResize', '$q', function (UploadResize, $q) {\n  var upload = UploadResize;\n\n  upload.isExifSupported = function () {\n    return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();\n  };\n\n  function applyTransform(ctx, orientation, width, height) {\n    switch (orientation) {\n      case 2:\n        return ctx.transform(-1, 0, 0, 1, width, 0);\n      case 3:\n        return ctx.transform(-1, 0, 0, -1, width, height);\n      case 4:\n        return ctx.transform(1, 0, 0, -1, 0, height);\n      case 5:\n        return ctx.transform(0, 1, 1, 0, 0, 0);\n      case 6:\n        return ctx.transform(0, 1, -1, 0, height, 0);\n      case 7:\n        return ctx.transform(0, -1, -1, 0, height, width);\n      case 8:\n        return ctx.transform(0, -1, 1, 0, 0, width);\n    }\n  }\n\n  upload.readOrientation = function (file) {\n    var defer = $q.defer();\n    var reader = new FileReader();\n    var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;\n    reader.readAsArrayBuffer(slicedFile);\n    reader.onerror = function (e) {\n      return defer.reject(e);\n    };\n    reader.onload = function (e) {\n      var result = {orientation: 1};\n      var view = new DataView(this.result);\n      if (view.getUint16(0, false) !== 0xFFD8) return defer.resolve(result);\n\n      var length = view.byteLength,\n        offset = 2;\n      while (offset < length) {\n        var marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker === 0xFFE1) {\n          if (view.getUint32(offset += 2, false) !== 0x45786966) return defer.resolve(result);\n\n          var little = view.getUint16(offset += 6, false) === 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          var tags = view.getUint16(offset, little);\n          offset += 2;\n          for (var i = 0; i < tags; i++)\n            if (view.getUint16(offset + (i * 12), little) === 0x0112) {\n              var orientation = view.getUint16(offset + (i * 12) + 8, little);\n              if (orientation >= 2 && orientation <= 8) {\n                view.setUint16(offset + (i * 12) + 8, 1, little);\n                result.fixedArrayBuffer = e.target.result;\n              }\n              result.orientation = orientation;\n              return defer.resolve(result);\n            }\n        } else if ((marker & 0xFF00) !== 0xFF00) break;\n        else offset += view.getUint16(offset, false);\n      }\n      return defer.resolve(result);\n    };\n    return defer.promise;\n  };\n\n  function arrayBufferToBase64(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n  }\n\n  upload.applyExifRotation = function (file) {\n    if (file.type.indexOf('image/jpeg') !== 0) {\n      return upload.emptyPromise(file);\n    }\n\n    var deferred = $q.defer();\n    upload.readOrientation(file).then(function (result) {\n      if (result.orientation < 2 || result.orientation > 8) {\n        return deferred.resolve(file);\n      }\n      upload.dataUrl(file, true).then(function (url) {\n        var canvas = document.createElement('canvas');\n        var img = document.createElement('img');\n\n        img.onload = function () {\n          try {\n            canvas.width = result.orientation > 4 ? img.height : img.width;\n            canvas.height = result.orientation > 4 ? img.width : img.height;\n            var ctx = canvas.getContext('2d');\n            applyTransform(ctx, result.orientation, img.width, img.height);\n            ctx.drawImage(img, 0, 0);\n            var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);\n            dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);\n            var blob = upload.dataUrltoBlob(dataUrl, file.name);\n            deferred.resolve(blob);\n          } catch (e) {\n            return deferred.reject(e);\n          }\n        };\n        img.onerror = function () {\n          deferred.reject();\n        };\n        img.src = url;\n      }, function (e) {\n        deferred.reject(e);\n      });\n    }, function (e) {\n      deferred.reject(e);\n    });\n    return deferred.promise;\n  };\n\n  upload.restoreExif = function (orig, resized) {\n    var ExifRestorer = {};\n\n    ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' +\n      'QRSTUVWXYZabcdef' +\n      'ghijklmnopqrstuv' +\n      'wxyz0123456789+/' +\n      '=';\n\n    ExifRestorer.encode64 = function (input) {\n      var output = '',\n        chr1, chr2, chr3 = '',\n        enc1, enc2, enc3, enc4 = '',\n        i = 0;\n\n      do {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output +\n          this.KEY_STR.charAt(enc1) +\n          this.KEY_STR.charAt(enc2) +\n          this.KEY_STR.charAt(enc3) +\n          this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n      } while (i < input.length);\n\n      return output;\n    };\n\n    ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {\n      if (origFileBase64.match('data:image/jpeg;base64,')) {\n        origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');\n      }\n\n      var rawImage = this.decode64(origFileBase64);\n      var segments = this.slice2Segments(rawImage);\n\n      var image = this.exifManipulation(resizedFileBase64, segments);\n\n      return 'data:image/jpeg;base64,' + this.encode64(image);\n    };\n\n\n    ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments),\n        newImageArray = this.insertExif(resizedFileBase64, exifArray);\n      return new Uint8Array(newImageArray);\n    };\n\n\n    ExifRestorer.getExifArray = function (segments) {\n      var seg;\n      for (var x = 0; x < segments.length; x++) {\n        seg = segments[x];\n        if (seg[0] === 255 & seg[1] === 225) //(ff e1)\n        {\n          return seg;\n        }\n      }\n      return [];\n    };\n\n\n    ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),\n        buf = this.decode64(imageData),\n        separatePoint = buf.indexOf(255, 3),\n        mae = buf.slice(0, separatePoint),\n        ato = buf.slice(separatePoint),\n        array = mae;\n\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    };\n\n\n    ExifRestorer.slice2Segments = function (rawImageArray) {\n      var head = 0,\n        segments = [];\n\n      while (1) {\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n          break;\n        }\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n          head += 2;\n        }\n        else {\n          var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n            endPoint = head + length + 2,\n            seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n\n      return segments;\n    };\n\n\n    ExifRestorer.decode64 = function (input) {\n      var chr1, chr2, chr3 = '',\n        enc1, enc2, enc3, enc4 = '',\n        i = 0,\n        buf = [];\n\n      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n      if (base64test.exec(input)) {\n        console.log('There were invalid base64 characters in the input text.\\n' +\n          'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and \"=\"\\n' +\n          'Expect errors in decoding.');\n      }\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n      do {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        buf.push(chr1);\n\n        if (enc3 !== 64) {\n          buf.push(chr2);\n        }\n        if (enc4 !== 64) {\n          buf.push(chr3);\n        }\n\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n\n      } while (i < input.length);\n\n      return buf;\n    };\n\n    return ExifRestorer.restore(orig, resized);  //<= EXIF\n  };\n\n  return upload;\n}]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmctZmlsZS11cGxvYWQvZGlzdC9uZy1maWxlLXVwbG9hZC1hbGwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZmlsZS11cGxvYWQvZGlzdC9uZy1maWxlLXVwbG9hZC1hbGwuanM/NDI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBBbmd1bGFySlMgZmlsZSB1cGxvYWQgZGlyZWN0aXZlcyBhbmQgc2VydmljZXMuIFN1cHBvcnRzOiBmaWxlIHVwbG9hZC9kcm9wL3Bhc3RlLCByZXN1bWUsIGNhbmNlbC9hYm9ydCxcbiAqIHByb2dyZXNzLCByZXNpemUsIHRodW1ibmFpbCwgcHJldmlldywgdmFsaWRhdGlvbiBhbmQgQ09SU1xuICogRmlsZUFQSSBGbGFzaCBzaGltIGZvciBvbGQgYnJvd3NlcnMgbm90IHN1cHBvcnRpbmcgRm9ybURhdGFcbiAqIEBhdXRob3IgIERhbmlhbCAgPGRhbmlhbC5mYXJpZEBnbWFpbC5jb20+XG4gKiBAdmVyc2lvbiAxMi4yLjEzXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgLyoqIEBuYW1lc3BhY2UgRmlsZUFQSS5ub0NvbnRlbnRUaW1lb3V0ICovXG5cbiAgZnVuY3Rpb24gcGF0Y2hYSFIoZm5OYW1lLCBuZXdGbikge1xuICAgIHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGVbZm5OYW1lXSA9IG5ld0ZuKHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGVbZm5OYW1lXSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWRlZmluZVByb3AoeGhyLCBwcm9wLCBmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoeGhyLCBwcm9wLCB7Z2V0OiBmbn0pO1xuICAgIH0gY2F0Y2ggKGUpIHsvKmlnbm9yZSovXG4gICAgfVxuICB9XG5cbiAgaWYgKCF3aW5kb3cuRmlsZUFQSSkge1xuICAgIHdpbmRvdy5GaWxlQVBJID0ge307XG4gIH1cblxuICBpZiAoIXdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgIHRocm93ICdBSkFYIGlzIG5vdCBzdXBwb3J0ZWQuIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBkZWZpbmVkLic7XG4gIH1cblxuICBGaWxlQVBJLnNob3VsZExvYWQgPSAhd2luZG93LkZvcm1EYXRhIHx8IEZpbGVBUEkuZm9yY2VMb2FkO1xuICBpZiAoRmlsZUFQSS5zaG91bGRMb2FkKSB7XG4gICAgdmFyIGluaXRpYWxpemVVcGxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgIGlmICgheGhyLl9fbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmICgheGhyLnVwbG9hZCkgeGhyLnVwbG9hZCA9IHt9O1xuICAgICAgICB4aHIuX19saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIG9yaWdBZGRFdmVudExpc3RlbmVyID0geGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodCwgZm4pIHtcbiAgICAgICAgICB4aHIuX19saXN0ZW5lcnNbdF0gPSBmbjtcbiAgICAgICAgICBpZiAob3JpZ0FkZEV2ZW50TGlzdGVuZXIpIG9yaWdBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBhdGNoWEhSKCdvcGVuJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobSwgdXJsLCBiKSB7XG4gICAgICAgIGluaXRpYWxpemVVcGxvYWRMaXN0ZW5lcih0aGlzKTtcbiAgICAgICAgdGhpcy5fX3VybCA9IHVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIFttLCB1cmwsIGJdKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLm1lc3NhZ2UuaW5kZXhPZignQWNjZXNzIGlzIGRlbmllZCcpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnRXJyb3IgPSBlO1xuICAgICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBbbSwgJ19maXhfZm9yX2llX2Nyb3NzZG9tYWluX18nLCBiXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGF0Y2hYSFIoJ2dldFJlc3BvbnNlSGVhZGVyJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbGVBcGlYSFIgJiYgdGhpcy5fX2ZpbGVBcGlYSFIuZ2V0UmVzcG9uc2VIZWFkZXIgPyB0aGlzLl9fZmlsZUFwaVhIUi5nZXRSZXNwb25zZUhlYWRlcihoKSA6IChvcmlnID09IG51bGwgPyBudWxsIDogb3JpZy5hcHBseSh0aGlzLCBbaF0pKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBwYXRjaFhIUignZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsZUFwaVhIUiAmJiB0aGlzLl9fZmlsZUFwaVhIUi5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPyB0aGlzLl9fZmlsZUFwaVhIUi5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSA6IChvcmlnID09IG51bGwgPyBudWxsIDogb3JpZy5hcHBseSh0aGlzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGF0Y2hYSFIoJ2Fib3J0JywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsZUFwaVhIUiAmJiB0aGlzLl9fZmlsZUFwaVhIUi5hYm9ydCA/IHRoaXMuX19maWxlQXBpWEhSLmFib3J0KCkgOiAob3JpZyA9PSBudWxsID8gbnVsbCA6IG9yaWcuYXBwbHkodGhpcykpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHBhdGNoWEhSKCdzZXRSZXF1ZXN0SGVhZGVyJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaGVhZGVyID09PSAnX19zZXRYSFJfJykge1xuICAgICAgICAgIGluaXRpYWxpemVVcGxvYWRMaXN0ZW5lcih0aGlzKTtcbiAgICAgICAgICB2YXIgdmFsID0gdmFsdWUodGhpcyk7XG4gICAgICAgICAgLy8gZml4IGZvciBhbmd1bGFyIDwgMS4yLjBcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3JlcXVlc3RIZWFkZXJzID0gdGhpcy5fX3JlcXVlc3RIZWFkZXJzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19yZXF1ZXN0SGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGF0Y2hYSFIoJ3NlbmQnLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhociA9IHRoaXM7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLl9faXNGaWxlQVBJU2hpbSkge1xuICAgICAgICAgIHZhciBmb3JtRGF0YSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgdXJsOiB4aHIuX191cmwsXG4gICAgICAgICAgICBqc29ucDogZmFsc2UsIC8vcmVtb3ZlcyB0aGUgY2FsbGJhY2sgZm9ybSBwYXJhbVxuICAgICAgICAgICAgY2FjaGU6IHRydWUsIC8vcmVtb3ZlcyB0aGUgP2ZpbGVhcGlYWFggaW4gdGhlIHVybFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChlcnIsIGZpbGVBcGlYSFIpIHtcbiAgICAgICAgICAgICAgaWYgKGVyciAmJiBhbmd1bGFyLmlzU3RyaW5nKGVycikgJiYgZXJyLmluZGV4T2YoJyMyMTc0JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzZWVtcyB0byBiZSBmaW5lIHRoZSBmaWxlIGlzIGJlaW5nIHVwbG9hZGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAgIGVyciA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeGhyLl9fY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgeGhyLl9fbGlzdGVuZXJzLmxvYWQpXG4gICAgICAgICAgICAgICAgeGhyLl9fbGlzdGVuZXJzLmxvYWQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgbG9hZGVkOiB4aHIuX19sb2FkZWQsXG4gICAgICAgICAgICAgICAgICB0b3RhbDogeGhyLl9fdG90YWwsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IHhocixcbiAgICAgICAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgeGhyLl9fbGlzdGVuZXJzLmxvYWRlbmQpXG4gICAgICAgICAgICAgICAgeGhyLl9fbGlzdGVuZXJzLmxvYWRlbmQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWRlbmQnLFxuICAgICAgICAgICAgICAgICAgbG9hZGVkOiB4aHIuX19sb2FkZWQsXG4gICAgICAgICAgICAgICAgICB0b3RhbDogeGhyLl9fdG90YWwsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IHhocixcbiAgICAgICAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGVyciA9PT0gJ2Fib3J0JyAmJiB4aHIuX19saXN0ZW5lcnMuYWJvcnQpXG4gICAgICAgICAgICAgICAgeGhyLl9fbGlzdGVuZXJzLmFib3J0KHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhYm9ydCcsXG4gICAgICAgICAgICAgICAgICBsb2FkZWQ6IHhoci5fX2xvYWRlZCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsOiB4aHIuX190b3RhbCxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogeGhyLFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZmlsZUFwaVhIUi5zdGF0dXMgIT09IHVuZGVmaW5lZCkgcmVkZWZpbmVQcm9wKHhociwgJ3N0YXR1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZpbGVBcGlYSFIuc3RhdHVzID09PSAwICYmIGVyciAmJiBlcnIgIT09ICdhYm9ydCcpID8gNTAwIDogZmlsZUFwaVhIUi5zdGF0dXM7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZmlsZUFwaVhIUi5zdGF0dXNUZXh0ICE9PSB1bmRlZmluZWQpIHJlZGVmaW5lUHJvcCh4aHIsICdzdGF0dXNUZXh0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQXBpWEhSLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZWRlZmluZVByb3AoeGhyLCAncmVhZHlTdGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChmaWxlQXBpWEhSLnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHJlZGVmaW5lUHJvcCh4aHIsICdyZXNwb25zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUFwaVhIUi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciByZXNwID0gZmlsZUFwaVhIUi5yZXNwb25zZVRleHQgfHwgKGVyciAmJiBmaWxlQXBpWEhSLnN0YXR1cyA9PT0gMCAmJiBlcnIgIT09ICdhYm9ydCcgPyBlcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICByZWRlZmluZVByb3AoeGhyLCAncmVzcG9uc2VUZXh0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVkZWZpbmVQcm9wKHhociwgJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGVycikgcmVkZWZpbmVQcm9wKHhociwgJ2VycicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgeGhyLl9fZmlsZUFwaVhIUiA9IGZpbGVBcGlYSFI7XG4gICAgICAgICAgICAgIGlmICh4aHIub25yZWFkeXN0YXRlY2hhbmdlKSB4aHIub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gICAgICAgICAgICAgIGlmICh4aHIub25sb2FkKSB4aHIub25sb2FkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUudGFyZ2V0ID0geGhyO1xuICAgICAgICAgICAgICBpZiAoeGhyLl9fbGlzdGVuZXJzLnByb2dyZXNzKSB4aHIuX19saXN0ZW5lcnMucHJvZ3Jlc3MoZSk7XG4gICAgICAgICAgICAgIHhoci5fX3RvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgeGhyLl9fbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgIGlmIChlLnRvdGFsID09PSBlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGZpeCBmbGFzaCBpc3N1ZSB0aGF0IGRvZXNuJ3QgY2FsbCBjb21wbGV0ZSBpZiB0aGVyZSBpcyBubyByZXNwb25zZSB0ZXh0IGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXhoci5fX2NvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCB7c3RhdHVzOiAyMDQsIHN0YXR1c1RleHQ6ICdObyBDb250ZW50J30pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIEZpbGVBUEkubm9Db250ZW50VGltZW91dCB8fCAxMDAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB4aHIuX19yZXF1ZXN0SGVhZGVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uZmlnLmRhdGEgPSB7fTtcbiAgICAgICAgICBjb25maWcuZmlsZXMgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1EYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZm9ybURhdGEuZGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnZhbCAhPSBudWxsICYmIGl0ZW0udmFsLm5hbWUgIT0gbnVsbCAmJiBpdGVtLnZhbC5zaXplICE9IG51bGwgJiYgaXRlbS52YWwudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5maWxlc1tpdGVtLmtleV0gPSBpdGVtLnZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5kYXRhW2l0ZW0ua2V5XSA9IGl0ZW0udmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFGaWxlQVBJLmhhc0ZsYXNoKSB7XG4gICAgICAgICAgICAgIHRocm93ICdBZG9kZSBGbGFzaCBQbGF5ZXIgbmVlZCB0byBiZSBpbnN0YWxsZWQuIFRvIGNoZWNrIGFoZWFkIHVzZSBcIkZpbGVBUEkuaGFzRmxhc2hcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHIuX19maWxlQXBpWEhSID0gRmlsZUFQSS51cGxvYWQoY29uZmlnKTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fX29yaWdFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fX29yaWdFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZy5hcHBseSh4aHIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgd2luZG93LlhNTEh0dHBSZXF1ZXN0Ll9faXNGaWxlQVBJU2hpbSA9IHRydWU7XG4gICAgd2luZG93LkZvcm1EYXRhID0gRm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChrZXksIHZhbCwgbmFtZSkge1xuICAgICAgICAgIGlmICh2YWwuX19pc0ZpbGVBUElCbG9iU2hpbSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmRhdGFbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBfX2lzRmlsZUFQSVNoaW06IHRydWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHdpbmRvdy5CbG9iID0gQmxvYiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBiLFxuICAgICAgICBfX2lzRmlsZUFQSUJsb2JTaGltOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgLyoqIEBuYW1lc3BhY2UgRmlsZUFQSS5mb3JjZUxvYWQgKi9cbiAgLyoqIEBuYW1lc3BhY2Ugd2luZG93LkZpbGVBUEkuanNVcmwgKi9cbiAgLyoqIEBuYW1lc3BhY2Ugd2luZG93LkZpbGVBUEkuanNQYXRoICovXG5cbiAgZnVuY3Rpb24gaXNJbnB1dFR5cGVGaWxlKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgZWxlbS5hdHRyKCd0eXBlJykgJiYgZWxlbS5hdHRyKCd0eXBlJykudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpbGUnO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzRmxhc2goKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmbyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpO1xuICAgICAgaWYgKGZvKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAobmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0KG9iaikge1xuICAgIHZhciBsZWZ0ID0gMCwgdG9wID0gMDtcblxuICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XG4gICAgICByZXR1cm4galF1ZXJ5KG9iaikub2Zmc2V0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9iai5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbGVmdCArPSAob2JqLm9mZnNldExlZnQgLSBvYmouc2Nyb2xsTGVmdCk7XG4gICAgICAgIHRvcCArPSAob2JqLm9mZnNldFRvcCAtIG9iai5zY3JvbGxUb3ApO1xuICAgICAgICBvYmogPSBvYmoub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcFxuICAgIH07XG4gIH1cblxuICBpZiAoRmlsZUFQSS5zaG91bGRMb2FkKSB7XG4gICAgRmlsZUFQSS5oYXNGbGFzaCA9IGhhc0ZsYXNoKCk7XG5cbiAgICAvL2xvYWQgRmlsZUFQSVxuICAgIGlmIChGaWxlQVBJLmZvcmNlTG9hZCkge1xuICAgICAgRmlsZUFQSS5odG1sNSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghRmlsZUFQSS51cGxvYWQpIHtcbiAgICAgIHZhciBqc1VybCwgYmFzZVBhdGgsIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLCBhbGxTY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLCBpLCBpbmRleCwgc3JjO1xuICAgICAgaWYgKHdpbmRvdy5GaWxlQVBJLmpzVXJsKSB7XG4gICAgICAgIGpzVXJsID0gd2luZG93LkZpbGVBUEkuanNVcmw7XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5GaWxlQVBJLmpzUGF0aCkge1xuICAgICAgICBiYXNlUGF0aCA9IHdpbmRvdy5GaWxlQVBJLmpzUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxTY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3JjID0gYWxsU2NyaXB0c1tpXS5zcmM7XG4gICAgICAgICAgaW5kZXggPSBzcmMuc2VhcmNoKC9cXC9uZ1xcLWZpbGVcXC11cGxvYWRbXFwtYS16QS16MC05XFwuXSpcXC5qcy8pO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBiYXNlUGF0aCA9IHNyYy5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRmlsZUFQSS5zdGF0aWNQYXRoID09IG51bGwpIEZpbGVBUEkuc3RhdGljUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywganNVcmwgfHwgYmFzZVBhdGggKyAnRmlsZUFQSS5taW4uanMnKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG5cbiAgICBGaWxlQVBJLm5nZkZpeElFID0gZnVuY3Rpb24gKGVsZW0sIGZpbGVFbGVtLCBjaGFuZ2VGbikge1xuICAgICAgaWYgKCFoYXNGbGFzaCgpKSB7XG4gICAgICAgIHRocm93ICdBZG9kZSBGbGFzaCBQbGF5ZXIgbmVlZCB0byBiZSBpbnN0YWxsZWQuIFRvIGNoZWNrIGFoZWFkIHVzZSBcIkZpbGVBUEkuaGFzRmxhc2hcIic7XG4gICAgICB9XG4gICAgICB2YXIgZml4SW5wdXRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZmlsZUVsZW0ucGFyZW50KCk7XG4gICAgICAgIGlmIChlbGVtLmF0dHIoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICBpZiAobGFiZWwpIGxhYmVsLnJlbW92ZUNsYXNzKCdqcy1maWxlYXBpLXdyYXBwZXInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWZpbGVFbGVtLmF0dHIoJ19fbmdmX2ZsYXNoXycpKSB7XG4gICAgICAgICAgICBmaWxlRWxlbS51bmJpbmQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgZmlsZUVsZW0udW5iaW5kKCdjbGljaycpO1xuICAgICAgICAgICAgZmlsZUVsZW0uYmluZCgnY2hhbmdlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICBmaWxlQXBpQ2hhbmdlRm4uYXBwbHkodGhpcywgW2V2dF0pO1xuICAgICAgICAgICAgICBjaGFuZ2VGbi5hcHBseSh0aGlzLCBbZXZ0XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbGVFbGVtLmF0dHIoJ19fbmdmX2ZsYXNoXycsICd0cnVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsLmFkZENsYXNzKCdqcy1maWxlYXBpLXdyYXBwZXInKTtcbiAgICAgICAgICBpZiAoIWlzSW5wdXRUeXBlRmlsZShlbGVtKSkge1xuICAgICAgICAgICAgbGFiZWwuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXG4gICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIGdldE9mZnNldChlbGVtWzBdKS50b3AgKyAncHgnKS5jc3MoJ2xlZnQnLCBnZXRPZmZzZXQoZWxlbVswXSkubGVmdCArICdweCcpXG4gICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgZWxlbVswXS5vZmZzZXRXaWR0aCArICdweCcpLmNzcygnaGVpZ2h0JywgZWxlbVswXS5vZmZzZXRIZWlnaHQgKyAncHgnKVxuICAgICAgICAgICAgICAuY3NzKCdmaWx0ZXInLCAnYWxwaGEob3BhY2l0eT0wKScpLmNzcygnZGlzcGxheScsIGVsZW0uY3NzKCdkaXNwbGF5JykpXG4gICAgICAgICAgICAgIC5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpLmNzcygnei1pbmRleCcsICc5MDAwMDAnKVxuICAgICAgICAgICAgICAuY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGZpbGVFbGVtLmNzcygnd2lkdGgnLCBlbGVtWzBdLm9mZnNldFdpZHRoICsgJ3B4JykuY3NzKCdoZWlnaHQnLCBlbGVtWzBdLm9mZnNldEhlaWdodCArICdweCcpXG4gICAgICAgICAgICAgIC5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJykuY3NzKCd0b3AnLCAnMHB4JykuY3NzKCdsZWZ0JywgJzBweCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZWxlbS5iaW5kKCdtb3VzZWVudGVyJywgZml4SW5wdXRTdHlsZSk7XG5cbiAgICAgIHZhciBmaWxlQXBpQ2hhbmdlRm4gPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBmaWxlcyA9IEZpbGVBUEkuZ2V0RmlsZXMoZXZ0KTtcbiAgICAgICAgLy9qdXN0IGEgZG91YmxlIGNoZWNrIGZvciAjMjMzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZXNbaV0uc2l6ZSA9PT0gdW5kZWZpbmVkKSBmaWxlc1tpXS5zaXplID0gMDtcbiAgICAgICAgICBpZiAoZmlsZXNbaV0ubmFtZSA9PT0gdW5kZWZpbmVkKSBmaWxlc1tpXS5uYW1lID0gJ2ZpbGUnO1xuICAgICAgICAgIGlmIChmaWxlc1tpXS50eXBlID09PSB1bmRlZmluZWQpIGZpbGVzW2ldLnR5cGUgPSAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2dC50YXJnZXQpIHtcbiAgICAgICAgICBldnQudGFyZ2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnRhcmdldC5maWxlcyA9IGZpbGVzO1xuICAgICAgICAvLyBpZiBldnQudGFyZ2V0LmZpbGVzIGlzIG5vdCB3cml0YWJsZSB1c2UgaGVscGVyIGZpZWxkXG4gICAgICAgIGlmIChldnQudGFyZ2V0LmZpbGVzICE9PSBmaWxlcykge1xuICAgICAgICAgIGV2dC5fX2ZpbGVzXyA9IGZpbGVzO1xuICAgICAgICB9XG4gICAgICAgIChldnQuX19maWxlc18gfHwgZXZ0LnRhcmdldC5maWxlcykuaXRlbSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIChldnQuX19maWxlc18gfHwgZXZ0LnRhcmdldC5maWxlcylbaV0gfHwgbnVsbDtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIEZpbGVBUEkuZGlzYWJsZUZpbGVJbnB1dCA9IGZ1bmN0aW9uIChlbGVtLCBkaXNhYmxlKSB7XG4gICAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKCdqcy1maWxlYXBpLXdyYXBwZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uYWRkQ2xhc3MoJ2pzLWZpbGVhcGktd3JhcHBlcicpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKCk7XG5cbmlmICghd2luZG93LkZpbGVSZWFkZXIpIHtcbiAgd2luZG93LkZpbGVSZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgbG9hZFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgICAgX3RoaXMubGlzdGVuZXJzW3R5cGVdID0gX3RoaXMubGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgX3RoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goZm4pO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICBpZiAoX3RoaXMubGlzdGVuZXJzW3R5cGVdKSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKF90aGlzLmxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGZuKSwgMSk7XG4gICAgfTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB2YXIgbGlzdCA9IF90aGlzLmxpc3RlbmVyc1tldnQudHlwZV07XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0W2ldLmNhbGwoX3RoaXMsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25hYm9ydCA9IHRoaXMub25lcnJvciA9IHRoaXMub25sb2FkID0gdGhpcy5vbmxvYWRzdGFydCA9IHRoaXMub25sb2FkZW5kID0gdGhpcy5vbnByb2dyZXNzID0gbnVsbDtcblxuICAgIHZhciBjb25zdHJ1Y3RFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBldnQpIHtcbiAgICAgIHZhciBlID0ge3R5cGU6IHR5cGUsIHRhcmdldDogX3RoaXMsIGxvYWRlZDogZXZ0LmxvYWRlZCwgdG90YWw6IGV2dC50b3RhbCwgZXJyb3I6IGV2dC5lcnJvcn07XG4gICAgICBpZiAoZXZ0LnJlc3VsdCAhPSBudWxsKSBlLnRhcmdldC5yZXN1bHQgPSBldnQucmVzdWx0O1xuICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoIWxvYWRTdGFydGVkKSB7XG4gICAgICAgIGxvYWRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKF90aGlzLm9ubG9hZHN0YXJ0KSBfdGhpcy5vbmxvYWRzdGFydChjb25zdHJ1Y3RFdmVudCgnbG9hZHN0YXJ0JywgZXZ0KSk7XG4gICAgICB9XG4gICAgICB2YXIgZTtcbiAgICAgIGlmIChldnQudHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICAgIGlmIChfdGhpcy5vbmxvYWRlbmQpIF90aGlzLm9ubG9hZGVuZChjb25zdHJ1Y3RFdmVudCgnbG9hZGVuZCcsIGV2dCkpO1xuICAgICAgICBlID0gY29uc3RydWN0RXZlbnQoJ2xvYWQnLCBldnQpO1xuICAgICAgICBpZiAoX3RoaXMub25sb2FkKSBfdGhpcy5vbmxvYWQoZSk7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09PSAncHJvZ3Jlc3MnKSB7XG4gICAgICAgIGUgPSBjb25zdHJ1Y3RFdmVudCgncHJvZ3Jlc3MnLCBldnQpO1xuICAgICAgICBpZiAoX3RoaXMub25wcm9ncmVzcykgX3RoaXMub25wcm9ncmVzcyhlKTtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUgPSBjb25zdHJ1Y3RFdmVudCgnZXJyb3InLCBldnQpO1xuICAgICAgICBpZiAoX3RoaXMub25lcnJvcikgX3RoaXMub25lcnJvcihlKTtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVhZEFzRGF0YVVSTCA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBGaWxlQVBJLnJlYWRBc0RhdGFVUkwoZmlsZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgdGhpcy5yZWFkQXNUZXh0ID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIEZpbGVBUEkucmVhZEFzVGV4dChmaWxlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqIVxuICogQW5ndWxhckpTIGZpbGUgdXBsb2FkIGRpcmVjdGl2ZXMgYW5kIHNlcnZpY2VzLiBTdXBvb3J0czogZmlsZSB1cGxvYWQvZHJvcC9wYXN0ZSwgcmVzdW1lLCBjYW5jZWwvYWJvcnQsXG4gKiBwcm9ncmVzcywgcmVzaXplLCB0aHVtYm5haWwsIHByZXZpZXcsIHZhbGlkYXRpb24gYW5kIENPUlNcbiAqIEBhdXRob3IgIERhbmlhbCAgPGRhbmlhbC5mYXJpZEBnbWFpbC5jb20+XG4gKiBAdmVyc2lvbiAxMi4yLjEzXG4gKi9cblxuaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAhKHdpbmRvdy5GaWxlQVBJICYmIEZpbGVBUEkuc2hvdWxkTG9hZCkpIHtcbiAgd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gKGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgICBpZiAoaGVhZGVyID09PSAnX19zZXRYSFJfJykge1xuICAgICAgICB2YXIgdmFsID0gdmFsdWUodGhpcyk7XG4gICAgICAgIC8vIGZpeCBmb3IgYW5ndWxhciA8IDEuMi4wXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIHZhbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlcik7XG59XG5cbnZhciBuZ0ZpbGVVcGxvYWQgPSBhbmd1bGFyLm1vZHVsZSgnbmdGaWxlVXBsb2FkJywgW10pO1xuXG5uZ0ZpbGVVcGxvYWQudmVyc2lvbiA9ICcxMi4yLjEzJztcblxubmdGaWxlVXBsb2FkLnNlcnZpY2UoJ1VwbG9hZEJhc2UnLCBbJyRodHRwJywgJyRxJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRodHRwLCAkcSwgJHRpbWVvdXQpIHtcbiAgdmFyIHVwbG9hZCA9IHRoaXM7XG4gIHVwbG9hZC5wcm9taXNlc0NvdW50ID0gMDtcblxuICB0aGlzLmlzUmVzdW1lU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuQmxvYiAmJiB3aW5kb3cuQmxvYi5wcm90b3R5cGUuc2xpY2U7XG4gIH07XG5cbiAgdmFyIHJlc3VtZVN1cHBvcnRlZCA9IHRoaXMuaXNSZXN1bWVTdXBwb3J0ZWQoKTtcblxuICBmdW5jdGlvbiBzZW5kSHR0cChjb25maWcpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZCB8fCAnUE9TVCc7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAgIHZhciBkZWZlcnJlZCA9IGNvbmZpZy5fZGVmZXJyZWQgPSBjb25maWcuX2RlZmVycmVkIHx8ICRxLmRlZmVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gbm90aWZ5UHJvZ3Jlc3MoZSkge1xuICAgICAgaWYgKGRlZmVycmVkLm5vdGlmeSkge1xuICAgICAgICBkZWZlcnJlZC5ub3RpZnkoZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvbWlzZS5wcm9ncmVzc0Z1bmMpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb21pc2UucHJvZ3Jlc3NGdW5jKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROb3RpZnlFdmVudChuKSB7XG4gICAgICBpZiAoY29uZmlnLl9zdGFydCAhPSBudWxsICYmIHJlc3VtZVN1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvYWRlZDogbi5sb2FkZWQgKyBjb25maWcuX3N0YXJ0LFxuICAgICAgICAgIHRvdGFsOiAoY29uZmlnLl9maWxlICYmIGNvbmZpZy5fZmlsZS5zaXplKSB8fCBuLnRvdGFsLFxuICAgICAgICAgIHR5cGU6IG4udHlwZSwgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZSwgdGFyZ2V0OiBuLnRhcmdldFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb25maWcuZGlzYWJsZVByb2dyZXNzKSB7XG4gICAgICBjb25maWcuaGVhZGVycy5fX3NldFhIUl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgaWYgKCF4aHIgfHwgIXhoci51cGxvYWQgfHwgIXhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcikgcmV0dXJuO1xuICAgICAgICAgIGNvbmZpZy5fX1hIUiA9IHhocjtcbiAgICAgICAgICBpZiAoY29uZmlnLnhockZuKSBjb25maWcueGhyRm4oeGhyKTtcbiAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgbm90aWZ5UHJvZ3Jlc3MoZ2V0Tm90aWZ5RXZlbnQoZSkpO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAvL2ZpeCBmb3IgZmlyZWZveCBub3QgZmlyaW5nIHVwbG9hZCBwcm9ncmVzcyBlbmQsIGFsc28gSUU4LTlcbiAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICBlLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgbm90aWZ5UHJvZ3Jlc3MoZ2V0Tm90aWZ5RXZlbnQoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBsb2FkV2l0aEFuZ3VsYXIoKSB7XG4gICAgICAkaHR0cChjb25maWcpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICBpZiAocmVzdW1lU3VwcG9ydGVkICYmIGNvbmZpZy5fY2h1bmtTaXplICYmICFjb25maWcuX2ZpbmlzaGVkICYmIGNvbmZpZy5fZmlsZSkge1xuICAgICAgICAgICAgdmFyIGZpbGVTaXplID0gY29uZmlnLl9maWxlICYmIGNvbmZpZy5fZmlsZS5zaXplIHx8IDA7XG4gICAgICAgICAgICBub3RpZnlQcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgbG9hZGVkOiBNYXRoLm1pbihjb25maWcuX2VuZCwgZmlsZVNpemUpLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBmaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncHJvZ3Jlc3MnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB1cGxvYWQudXBsb2FkKGNvbmZpZywgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuX2ZpbmlzaGVkKSBkZWxldGUgY29uZmlnLl9maW5pc2hlZDtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bWVTdXBwb3J0ZWQpIHtcbiAgICAgIHVwbG9hZFdpdGhBbmd1bGFyKCk7XG4gICAgfSBlbHNlIGlmIChjb25maWcuX2NodW5rU2l6ZSAmJiBjb25maWcuX2VuZCAmJiAhY29uZmlnLl9maW5pc2hlZCkge1xuICAgICAgY29uZmlnLl9zdGFydCA9IGNvbmZpZy5fZW5kO1xuICAgICAgY29uZmlnLl9lbmQgKz0gY29uZmlnLl9jaHVua1NpemU7XG4gICAgICB1cGxvYWRXaXRoQW5ndWxhcigpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLnJlc3VtZVNpemVVcmwpIHtcbiAgICAgICRodHRwLmdldChjb25maWcucmVzdW1lU2l6ZVVybCkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBpZiAoY29uZmlnLnJlc3VtZVNpemVSZXNwb25zZVJlYWRlcikge1xuICAgICAgICAgIGNvbmZpZy5fc3RhcnQgPSBjb25maWcucmVzdW1lU2l6ZVJlc3BvbnNlUmVhZGVyKHJlc3AuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZmlnLl9zdGFydCA9IHBhcnNlSW50KChyZXNwLmRhdGEuc2l6ZSA9PSBudWxsID8gcmVzcC5kYXRhIDogcmVzcC5kYXRhLnNpemUpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2NodW5rU2l6ZSkge1xuICAgICAgICAgIGNvbmZpZy5fZW5kID0gY29uZmlnLl9zdGFydCArIGNvbmZpZy5fY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIHVwbG9hZFdpdGhBbmd1bGFyKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb25maWcucmVzdW1lU2l6ZSkge1xuICAgICAgY29uZmlnLnJlc3VtZVNpemUoKS50aGVuKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGNvbmZpZy5fc3RhcnQgPSBzaXplO1xuICAgICAgICBpZiAoY29uZmlnLl9jaHVua1NpemUpIHtcbiAgICAgICAgICBjb25maWcuX2VuZCA9IGNvbmZpZy5fc3RhcnQgKyBjb25maWcuX2NodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB1cGxvYWRXaXRoQW5ndWxhcigpO1xuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLl9jaHVua1NpemUpIHtcbiAgICAgICAgY29uZmlnLl9zdGFydCA9IDA7XG4gICAgICAgIGNvbmZpZy5fZW5kID0gY29uZmlnLl9zdGFydCArIGNvbmZpZy5fY2h1bmtTaXplO1xuICAgICAgfVxuICAgICAgdXBsb2FkV2l0aEFuZ3VsYXIoKTtcbiAgICB9XG5cblxuICAgIHByb21pc2Uuc3VjY2VzcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBmbihyZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBwcm9taXNlLnRoZW4obnVsbCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGZuKHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuaGVhZGVycywgY29uZmlnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHByb21pc2UucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHByb21pc2UucHJvZ3Jlc3NGdW5jID0gZm47XG4gICAgICBwcm9taXNlLnRoZW4obnVsbCwgbnVsbCwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgZm4obik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgcHJvbWlzZS5hYm9ydCA9IHByb21pc2UucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29uZmlnLl9fWEhSKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25maWcuX19YSFIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIHByb21pc2UueGhyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBjb25maWcueGhyRm4gPSAoZnVuY3Rpb24gKG9yaWdYaHJGbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvcmlnWGhyRm4pIG9yaWdYaHJGbi5hcHBseShwcm9taXNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGZuLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KShjb25maWcueGhyRm4pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHVwbG9hZC5wcm9taXNlc0NvdW50Kys7XG4gICAgaWYgKHByb21pc2VbJ2ZpbmFsbHknXSAmJiBwcm9taXNlWydmaW5hbGx5J10gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcHJvbWlzZVsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXBsb2FkLnByb21pc2VzQ291bnQtLTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHRoaXMuaXNVcGxvYWRJblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1cGxvYWQucHJvbWlzZXNDb3VudCA+IDA7XG4gIH07XG5cbiAgdGhpcy5yZW5hbWUgPSBmdW5jdGlvbiAoZmlsZSwgbmFtZSkge1xuICAgIGZpbGUubmdmTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgdGhpcy5qc29uQmxvYiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgIWFuZ3VsYXIuaXNTdHJpbmcodmFsKSkge1xuICAgICAgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcbiAgICB9XG4gICAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3ZhbF0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KTtcbiAgICBibG9iLl9uZ2ZCbG9iID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvYjtcbiAgfTtcblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGFuZ3VsYXIudG9Kc29uKHZhbCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29weShvYmopIHtcbiAgICB2YXIgY2xvbmUgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2xvbmVba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICB0aGlzLmlzRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIGZpbGUgIT0gbnVsbCAmJiAoZmlsZSBpbnN0YW5jZW9mIHdpbmRvdy5CbG9iIHx8IChmaWxlLmZsYXNoSWQgJiYgZmlsZS5uYW1lICYmIGZpbGUuc2l6ZSkpO1xuICB9O1xuXG4gIHRoaXMudXBsb2FkID0gZnVuY3Rpb24gKGNvbmZpZywgaW50ZXJuYWwpIHtcbiAgICBmdW5jdGlvbiB0b1Jlc3VtZUZpbGUoZmlsZSwgZm9ybURhdGEpIHtcbiAgICAgIGlmIChmaWxlLl9uZ2ZCbG9iKSByZXR1cm4gZmlsZTtcbiAgICAgIGNvbmZpZy5fZmlsZSA9IGNvbmZpZy5fZmlsZSB8fCBmaWxlO1xuICAgICAgaWYgKGNvbmZpZy5fc3RhcnQgIT0gbnVsbCAmJiByZXN1bWVTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZW5kICYmIGNvbmZpZy5fZW5kID49IGZpbGUuc2l6ZSkge1xuICAgICAgICAgIGNvbmZpZy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbmZpZy5fZW5kID0gZmlsZS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbGljZSA9IGZpbGUuc2xpY2UoY29uZmlnLl9zdGFydCwgY29uZmlnLl9lbmQgfHwgZmlsZS5zaXplKTtcbiAgICAgICAgc2xpY2UubmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgc2xpY2UubmdmTmFtZSA9IGZpbGUubmdmTmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5fY2h1bmtTaXplKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdfY2h1bmtTaXplJywgY29uZmlnLl9jaHVua1NpemUpO1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnX2N1cnJlbnRDaHVua1NpemUnLCBjb25maWcuX2VuZCAtIGNvbmZpZy5fc3RhcnQpO1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnX2NodW5rTnVtYmVyJywgTWF0aC5mbG9vcihjb25maWcuX3N0YXJ0IC8gY29uZmlnLl9jaHVua1NpemUpKTtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ190b3RhbFNpemUnLCBjb25maWcuX2ZpbGUuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRmllbGRUb0Zvcm1EYXRhKGZvcm1EYXRhLCB2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZSh2YWwpKSB7XG4gICAgICAgICAgdmFsID0gdmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXBsb2FkLmlzRmlsZSh2YWwpKSB7XG4gICAgICAgICAgdmFyIGZpbGUgPSB0b1Jlc3VtZUZpbGUodmFsLCBmb3JtRGF0YSk7XG4gICAgICAgICAgdmFyIHNwbGl0ID0ga2V5LnNwbGl0KCcsJyk7XG4gICAgICAgICAgaWYgKHNwbGl0WzFdKSB7XG4gICAgICAgICAgICBmaWxlLm5nZk5hbWUgPSBzcGxpdFsxXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uZmlnLl9maWxlS2V5ID0gY29uZmlnLl9maWxlS2V5IHx8IGtleTtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCBmaWxlLCBmaWxlLm5nZk5hbWUgfHwgZmlsZS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICBpZiAodmFsLiQkbmdmQ2lyY3VsYXJEZXRlY3Rpb24pIHRocm93ICduZ0ZpbGVVcGxvYWQ6IENpcmN1bGFyIHJlZmVyZW5jZSBpbiBjb25maWcuZGF0YS4gTWFrZSBzdXJlIHNwZWNpZmllZCBkYXRhIGZvciBVcGxvYWQudXBsb2FkKCkgaGFzIG5vIGNpcmN1bGFyIHJlZmVyZW5jZTogJyArIGtleTtcblxuICAgICAgICAgICAgdmFsLiQkbmdmQ2lyY3VsYXJEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KGspICYmIGsgIT09ICckJG5nZkNpcmN1bGFyRGV0ZWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEtleSA9IGNvbmZpZy5vYmplY3RLZXkgPT0gbnVsbCA/ICdbaV0nIDogY29uZmlnLm9iamVjdEtleTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoICYmIHBhcnNlSW50KGspID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0S2V5ID0gY29uZmlnLmFycmF5S2V5ID09IG51bGwgPyBvYmplY3RLZXkgOiBjb25maWcuYXJyYXlLZXk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhZGRGaWVsZFRvRm9ybURhdGEoZm9ybURhdGEsIHZhbFtrXSwga2V5ICsgb2JqZWN0S2V5LnJlcGxhY2UoL1tpa10vZywgaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZGVsZXRlIHZhbC4kJG5nZkNpcmN1bGFyRGV0ZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZ2VzdENvbmZpZygpIHtcbiAgICAgIGNvbmZpZy5fY2h1bmtTaXplID0gdXBsb2FkLnRyYW5zbGF0ZVNjYWxhcnMoY29uZmlnLnJlc3VtZUNodW5rU2l6ZSk7XG4gICAgICBjb25maWcuX2NodW5rU2l6ZSA9IGNvbmZpZy5fY2h1bmtTaXplID8gcGFyc2VJbnQoY29uZmlnLl9jaHVua1NpemUudG9TdHJpbmcoKSkgOiBudWxsO1xuXG4gICAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgY29uZmlnLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdW5kZWZpbmVkO1xuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3QgPSBjb25maWcudHJhbnNmb3JtUmVxdWVzdCA/XG4gICAgICAgIChhbmd1bGFyLmlzQXJyYXkoY29uZmlnLnRyYW5zZm9ybVJlcXVlc3QpID9cbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdCA6IFtjb25maWcudHJhbnNmb3JtUmVxdWVzdF0pIDogW107XG4gICAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdC5wdXNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyB3aW5kb3cuRm9ybURhdGEoKSwga2V5O1xuICAgICAgICBkYXRhID0gZGF0YSB8fCBjb25maWcuZmllbGRzIHx8IHt9O1xuICAgICAgICBpZiAoY29uZmlnLmZpbGUpIHtcbiAgICAgICAgICBkYXRhLmZpbGUgPSBjb25maWcuZmlsZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybURhdGFBcHBlbmRlcikge1xuICAgICAgICAgICAgICBjb25maWcuZm9ybURhdGFBcHBlbmRlcihmb3JtRGF0YSwga2V5LCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkRmllbGRUb0Zvcm1EYXRhKGZvcm1EYXRhLCB2YWwsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcm5hbCkgY29uZmlnID0gY29weShjb25maWcpO1xuICAgIGlmICghY29uZmlnLl9pc0RpZ2VzdGVkKSB7XG4gICAgICBjb25maWcuX2lzRGlnZXN0ZWQgPSB0cnVlO1xuICAgICAgZGlnZXN0Q29uZmlnKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbmRIdHRwKGNvbmZpZyk7XG4gIH07XG5cbiAgdGhpcy5odHRwID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvcHkoY29uZmlnKTtcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdCA9IGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0IHx8IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICgod2luZG93LkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiB3aW5kb3cuQXJyYXlCdWZmZXIpIHx8IGRhdGEgaW5zdGFuY2VvZiB3aW5kb3cuQmxvYikge1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkaHR0cC5kZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0WzBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNvbmZpZy5fY2h1bmtTaXplID0gdXBsb2FkLnRyYW5zbGF0ZVNjYWxhcnMoY29uZmlnLnJlc3VtZUNodW5rU2l6ZSk7XG4gICAgY29uZmlnLl9jaHVua1NpemUgPSBjb25maWcuX2NodW5rU2l6ZSA/IHBhcnNlSW50KGNvbmZpZy5fY2h1bmtTaXplLnRvU3RyaW5nKCkpIDogbnVsbDtcblxuICAgIHJldHVybiBzZW5kSHR0cChjb25maWcpO1xuICB9O1xuXG4gIHRoaXMudHJhbnNsYXRlU2NhbGFycyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhzdHIpKSB7XG4gICAgICBpZiAoc3RyLnNlYXJjaCgva2IvaSkgPT09IHN0ci5sZW5ndGggLSAyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpICogMTAyNCk7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zZWFyY2goL21iL2kpID09PSBzdHIubGVuZ3RoIC0gMikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAyKSAqIDEwNDg1NzYpO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc2VhcmNoKC9nYi9pKSA9PT0gc3RyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMikgKiAxMDczNzQxODI0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyLnNlYXJjaCgvYi9pKSA9PT0gc3RyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSkpO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc2VhcmNoKC9zL2kpID09PSBzdHIubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zZWFyY2goL20vaSkgPT09IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpICogNjApO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc2VhcmNoKC9oL2kpID09PSBzdHIubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSAqIDM2MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHRoaXMudXJsVG9CbG9iID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcbiAgICAkaHR0cCh7dXJsOiB1cmwsIG1ldGhvZDogJ2dldCcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ30pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgIHZhciBhcnJheUJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShyZXNwLmRhdGEpO1xuICAgICAgdmFyIHR5cGUgPSByZXNwLmhlYWRlcnMoJ2NvbnRlbnQtdHlwZScpIHx8ICdpbWFnZS9XZWJQJztcbiAgICAgIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFthcnJheUJ1ZmZlclZpZXddLCB7dHlwZTogdHlwZX0pO1xuICAgICAgdmFyIG1hdGNoZXMgPSB1cmwubWF0Y2goLy4qXFwvKC4rPykoXFw/LiopPyQvKTtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYmxvYi5uYW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgIH1cbiAgICAgIGRlZmVyLnJlc29sdmUoYmxvYik7XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgfTtcblxuICB0aGlzLnNldERlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzIHx8IHt9O1xuICB9O1xuXG4gIHRoaXMuZGVmYXVsdHMgPSB7fTtcbiAgdGhpcy52ZXJzaW9uID0gbmdGaWxlVXBsb2FkLnZlcnNpb247XG59XG5cbl0pO1xuXG5uZ0ZpbGVVcGxvYWQuc2VydmljZSgnVXBsb2FkJywgWyckcGFyc2UnLCAnJHRpbWVvdXQnLCAnJGNvbXBpbGUnLCAnJHEnLCAnVXBsb2FkRXhpZicsIGZ1bmN0aW9uICgkcGFyc2UsICR0aW1lb3V0LCAkY29tcGlsZSwgJHEsIFVwbG9hZEV4aWYpIHtcbiAgdmFyIHVwbG9hZCA9IFVwbG9hZEV4aWY7XG4gIHVwbG9hZC5nZXRBdHRyV2l0aERlZmF1bHRzID0gZnVuY3Rpb24gKGF0dHIsIG5hbWUpIHtcbiAgICBpZiAoYXR0cltuYW1lXSAhPSBudWxsKSByZXR1cm4gYXR0cltuYW1lXTtcbiAgICB2YXIgZGVmID0gdXBsb2FkLmRlZmF1bHRzW25hbWVdO1xuICAgIHJldHVybiAoZGVmID09IG51bGwgPyBkZWYgOiAoYW5ndWxhci5pc1N0cmluZyhkZWYpID8gZGVmIDogSlNPTi5zdHJpbmdpZnkoZGVmKSkpO1xuICB9O1xuXG4gIHVwbG9hZC5hdHRyR2V0dGVyID0gZnVuY3Rpb24gKG5hbWUsIGF0dHIsIHNjb3BlLCBwYXJhbXMpIHtcbiAgICB2YXIgYXR0clZhbCA9IHRoaXMuZ2V0QXR0cldpdGhEZWZhdWx0cyhhdHRyLCBuYW1lKTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gJHBhcnNlKGF0dHJWYWwpKHNjb3BlLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkcGFyc2UoYXR0clZhbCkoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGhhbmdsZSBzdHJpbmcgdmFsdWUgd2l0aG91dCBzaW5nbGUgcW91dGVcbiAgICAgICAgaWYgKG5hbWUuc2VhcmNoKC9taW58bWF4fHBhdHRlcm4vaSkpIHtcbiAgICAgICAgICByZXR1cm4gYXR0clZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhdHRyVmFsO1xuICAgIH1cbiAgfTtcblxuICB1cGxvYWQuc2hvdWxkVXBkYXRlT24gPSBmdW5jdGlvbiAodHlwZSwgYXR0ciwgc2NvcGUpIHtcbiAgICB2YXIgbW9kZWxPcHRpb25zID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZk1vZGVsT3B0aW9ucycsIGF0dHIsIHNjb3BlKTtcbiAgICBpZiAobW9kZWxPcHRpb25zICYmIG1vZGVsT3B0aW9ucy51cGRhdGVPbikge1xuICAgICAgcmV0dXJuIG1vZGVsT3B0aW9ucy51cGRhdGVPbi5zcGxpdCgnICcpLmluZGV4T2YodHlwZSkgPiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdXBsb2FkLmVtcHR5UHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZCA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZC5yZXNvbHZlLmFwcGx5KGQsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkLnByb21pc2U7XG4gIH07XG5cbiAgdXBsb2FkLnJlamVjdFByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGQgPSAkcS5kZWZlcigpO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGQucmVqZWN0LmFwcGx5KGQsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkLnByb21pc2U7XG4gIH07XG5cbiAgdXBsb2FkLmhhcHB5UHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBkYXRhKSB7XG4gICAgdmFyIGQgPSAkcS5kZWZlcigpO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBkLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGQucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZC5wcm9taXNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFwcGx5RXhpZlJvdGF0aW9ucyhmaWxlcywgYXR0ciwgc2NvcGUpIHtcbiAgICB2YXIgcHJvbWlzZXMgPSBbdXBsb2FkLmVtcHR5UHJvbWlzZSgpXTtcbiAgICBhbmd1bGFyLmZvckVhY2goZmlsZXMsIGZ1bmN0aW9uIChmLCBpKSB7XG4gICAgICBpZiAoZi50eXBlLmluZGV4T2YoJ2ltYWdlL2pwZWcnKSA9PT0gMCAmJiB1cGxvYWQuYXR0ckdldHRlcignbmdmRml4T3JpZW50YXRpb24nLCBhdHRyLCBzY29wZSwgeyRmaWxlOiBmfSkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh1cGxvYWQuaGFwcHlQcm9taXNlKHVwbG9hZC5hcHBseUV4aWZSb3RhdGlvbihmKSwgZikudGhlbihmdW5jdGlvbiAoZml4ZWRGaWxlKSB7XG4gICAgICAgICAgZmlsZXMuc3BsaWNlKGksIDEsIGZpeGVkRmlsZSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZUZpbGUoZmlsZXMsIGF0dHIsIHNjb3BlLCBuZ01vZGVsKSB7XG4gICAgdmFyIHJlc2l6ZVZhbCA9IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZSZXNpemUnLCBhdHRyLCBzY29wZSk7XG4gICAgaWYgKCFyZXNpemVWYWwgfHwgIXVwbG9hZC5pc1Jlc2l6ZVN1cHBvcnRlZCgpIHx8ICFmaWxlcy5sZW5ndGgpIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKCk7XG4gICAgaWYgKHJlc2l6ZVZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB2YXIgZGVmZXIgPSAkcS5kZWZlcigpO1xuICAgICAgcmV0dXJuIHJlc2l6ZVZhbChmaWxlcykudGhlbihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXNpemVXaXRoUGFyYW1zKHAsIGZpbGVzLCBhdHRyLCBzY29wZSwgbmdNb2RlbCkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgIGRlZmVyLnJlc29sdmUocik7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzaXplV2l0aFBhcmFtcyhyZXNpemVWYWwsIGZpbGVzLCBhdHRyLCBzY29wZSwgbmdNb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplV2l0aFBhcmFtcyhwYXJhbXMsIGZpbGVzLCBhdHRyLCBzY29wZSwgbmdNb2RlbCkge1xuICAgIHZhciBwcm9taXNlcyA9IFt1cGxvYWQuZW1wdHlQcm9taXNlKCldO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlRmlsZShmLCBpKSB7XG4gICAgICBpZiAoZi50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgaWYgKHBhcmFtcy5wYXR0ZXJuICYmICF1cGxvYWQudmFsaWRhdGVQYXR0ZXJuKGYsIHBhcmFtcy5wYXR0ZXJuKSkgcmV0dXJuO1xuICAgICAgICBwYXJhbXMucmVzaXplSWYgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgIHJldHVybiB1cGxvYWQuYXR0ckdldHRlcignbmdmUmVzaXplSWYnLCBhdHRyLCBzY29wZSxcbiAgICAgICAgICAgIHskd2lkdGg6IHdpZHRoLCAkaGVpZ2h0OiBoZWlnaHQsICRmaWxlOiBmfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcm9taXNlID0gdXBsb2FkLnJlc2l6ZShmLCBwYXJhbXMpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc2l6ZWRGaWxlKSB7XG4gICAgICAgICAgZmlsZXMuc3BsaWNlKGksIDEsIHJlc2l6ZWRGaWxlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBmLiRlcnJvciA9ICdyZXNpemUnO1xuICAgICAgICAgIChmLiRlcnJvck1lc3NhZ2VzID0gKGYuJGVycm9yTWVzc2FnZXMgfHwge30pKS5yZXNpemUgPSB0cnVlO1xuICAgICAgICAgIGYuJGVycm9yUGFyYW0gPSAoZSA/IChlLm1lc3NhZ2UgPyBlLm1lc3NhZ2UgOiBlKSArICc6ICcgOiAnJykgKyAoZiAmJiBmLm5hbWUpO1xuICAgICAgICAgIG5nTW9kZWwuJG5nZlZhbGlkYXRpb25zLnB1c2goe25hbWU6ICdyZXNpemUnLCB2YWxpZDogZmFsc2V9KTtcbiAgICAgICAgICB1cGxvYWQuYXBwbHlNb2RlbFZhbGlkYXRpb24obmdNb2RlbCwgZmlsZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVGaWxlKGZpbGVzW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICB1cGxvYWQudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAobmdNb2RlbCwgYXR0ciwgc2NvcGUsIGZpbGVDaGFuZ2UsIGZpbGVzLCBldnQsIG5vRGVsYXkpIHtcbiAgICBmdW5jdGlvbiB1cGRhdGUoZmlsZXMsIGludmFsaWRGaWxlcywgbmV3RmlsZXMsIGR1cEZpbGVzLCBpc1NpbmdsZU1vZGVsKSB7XG4gICAgICBhdHRyLiQkbmdmUHJldlZhbGlkRmlsZXMgPSBmaWxlcztcbiAgICAgIGF0dHIuJCRuZ2ZQcmV2SW52YWxpZEZpbGVzID0gaW52YWxpZEZpbGVzO1xuICAgICAgdmFyIGZpbGUgPSBmaWxlcyAmJiBmaWxlcy5sZW5ndGggPyBmaWxlc1swXSA6IG51bGw7XG4gICAgICB2YXIgaW52YWxpZEZpbGUgPSBpbnZhbGlkRmlsZXMgJiYgaW52YWxpZEZpbGVzLmxlbmd0aCA/IGludmFsaWRGaWxlc1swXSA6IG51bGw7XG5cbiAgICAgIGlmIChuZ01vZGVsKSB7XG4gICAgICAgIHVwbG9hZC5hcHBseU1vZGVsVmFsaWRhdGlvbihuZ01vZGVsLCBmaWxlcyk7XG4gICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShpc1NpbmdsZU1vZGVsID8gZmlsZSA6IGZpbGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVDaGFuZ2UpIHtcbiAgICAgICAgJHBhcnNlKGZpbGVDaGFuZ2UpKHNjb3BlLCB7XG4gICAgICAgICAgJGZpbGVzOiBmaWxlcyxcbiAgICAgICAgICAkZmlsZTogZmlsZSxcbiAgICAgICAgICAkbmV3RmlsZXM6IG5ld0ZpbGVzLFxuICAgICAgICAgICRkdXBsaWNhdGVGaWxlczogZHVwRmlsZXMsXG4gICAgICAgICAgJGludmFsaWRGaWxlczogaW52YWxpZEZpbGVzLFxuICAgICAgICAgICRpbnZhbGlkRmlsZTogaW52YWxpZEZpbGUsXG4gICAgICAgICAgJGV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnZhbGlkTW9kZWwgPSB1cGxvYWQuYXR0ckdldHRlcignbmdmTW9kZWxJbnZhbGlkJywgYXR0cik7XG4gICAgICBpZiAoaW52YWxpZE1vZGVsKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkcGFyc2UoaW52YWxpZE1vZGVsKS5hc3NpZ24oc2NvcGUsIGlzU2luZ2xlTW9kZWwgPyBpbnZhbGlkRmlsZSA6IGludmFsaWRGaWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzY29wZSBhcHBseSBjaGFuZ2VzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYWxsTmV3RmlsZXMsIGR1cEZpbGVzID0gW10sIHByZXZWYWxpZEZpbGVzLCBwcmV2SW52YWxpZEZpbGVzLFxuICAgICAgaW52YWxpZHMgPSBbXSwgdmFsaWRzID0gW107XG5cbiAgICBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKCkge1xuICAgICAgZnVuY3Rpb24gZXF1YWxzKGYxLCBmMikge1xuICAgICAgICByZXR1cm4gZjEubmFtZSA9PT0gZjIubmFtZSAmJiAoZjEuJG5nZk9yaWdTaXplIHx8IGYxLnNpemUpID09PSAoZjIuJG5nZk9yaWdTaXplIHx8IGYyLnNpemUpICYmXG4gICAgICAgICAgZjEudHlwZSA9PT0gZjIudHlwZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJblByZXZGaWxlcyhmKSB7XG4gICAgICAgIHZhciBqO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcHJldlZhbGlkRmlsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoZXF1YWxzKGYsIHByZXZWYWxpZEZpbGVzW2pdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBwcmV2SW52YWxpZEZpbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGVxdWFscyhmLCBwcmV2SW52YWxpZEZpbGVzW2pdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVzKSB7XG4gICAgICAgIGFsbE5ld0ZpbGVzID0gW107XG4gICAgICAgIGR1cEZpbGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaXNJblByZXZGaWxlcyhmaWxlc1tpXSkpIHtcbiAgICAgICAgICAgIGR1cEZpbGVzLnB1c2goZmlsZXNbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxOZXdGaWxlcy5wdXNoKGZpbGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KHYpIHtcbiAgICAgIHJldHVybiBhbmd1bGFyLmlzQXJyYXkodikgPyB2IDogW3ZdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUFuZFVwZGF0ZSgpIHtcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXBkYXRlKGtlZXAgPyBwcmV2VmFsaWRGaWxlcy5jb25jYXQodmFsaWRzKSA6IHZhbGlkcyxcbiAgICAgICAgICAgIGtlZXAgPyBwcmV2SW52YWxpZEZpbGVzLmNvbmNhdChpbnZhbGlkcykgOiBpbnZhbGlkcyxcbiAgICAgICAgICAgIGZpbGVzLCBkdXBGaWxlcywgaXNTaW5nbGVNb2RlbCk7XG4gICAgICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJvdW5jZSA/IG9wdGlvbnMuZGVib3VuY2UuY2hhbmdlIHx8IG9wdGlvbnMuZGVib3VuY2UgOiAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc2l6aW5nRmlsZXMgPSB2YWxpZGF0ZUFmdGVyUmVzaXplID8gYWxsTmV3RmlsZXMgOiB2YWxpZHM7XG4gICAgICByZXNpemVGaWxlKHJlc2l6aW5nRmlsZXMsIGF0dHIsIHNjb3BlLCBuZ01vZGVsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlQWZ0ZXJSZXNpemUpIHtcbiAgICAgICAgICB1cGxvYWQudmFsaWRhdGUoYWxsTmV3RmlsZXMsIGtlZXAgPyBwcmV2VmFsaWRGaWxlcy5sZW5ndGggOiAwLCBuZ01vZGVsLCBhdHRyLCBzY29wZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhbGlkcyA9IHZhbGlkYXRpb25SZXN1bHQudmFsaWRzRmlsZXM7XG4gICAgICAgICAgICAgIGludmFsaWRzID0gdmFsaWRhdGlvblJlc3VsdC5pbnZhbGlkc0ZpbGVzO1xuICAgICAgICAgICAgICB1cGRhdGVNb2RlbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlTW9kZWwoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6aW5nRmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZiA9IHJlc2l6aW5nRmlsZXNbaV07XG4gICAgICAgICAgaWYgKGYuJGVycm9yID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdmFsaWRzLmluZGV4T2YoZik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICB2YWxpZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgaW52YWxpZHMucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU1vZGVsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcmV2VmFsaWRGaWxlcyA9IGF0dHIuJCRuZ2ZQcmV2VmFsaWRGaWxlcyB8fCBbXTtcbiAgICBwcmV2SW52YWxpZEZpbGVzID0gYXR0ci4kJG5nZlByZXZJbnZhbGlkRmlsZXMgfHwgW107XG4gICAgaWYgKG5nTW9kZWwgJiYgbmdNb2RlbC4kbW9kZWxWYWx1ZSkge1xuICAgICAgcHJldlZhbGlkRmlsZXMgPSB0b0FycmF5KG5nTW9kZWwuJG1vZGVsVmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBrZWVwID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZktlZXAnLCBhdHRyLCBzY29wZSk7XG4gICAgYWxsTmV3RmlsZXMgPSAoZmlsZXMgfHwgW10pLnNsaWNlKDApO1xuICAgIGlmIChrZWVwID09PSAnZGlzdGluY3QnIHx8IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZLZWVwRGlzdGluY3QnLCBhdHRyLCBzY29wZSkgPT09IHRydWUpIHtcbiAgICAgIHJlbW92ZUR1cGxpY2F0ZXMoYXR0ciwgc2NvcGUpO1xuICAgIH1cblxuICAgIHZhciBpc1NpbmdsZU1vZGVsID0gIWtlZXAgJiYgIXVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZNdWx0aXBsZScsIGF0dHIsIHNjb3BlKSAmJiAhdXBsb2FkLmF0dHJHZXR0ZXIoJ211bHRpcGxlJywgYXR0cik7XG5cbiAgICBpZiAoa2VlcCAmJiAhYWxsTmV3RmlsZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICB1cGxvYWQuYXR0ckdldHRlcignbmdmQmVmb3JlTW9kZWxDaGFuZ2UnLCBhdHRyLCBzY29wZSwge1xuICAgICAgJGZpbGVzOiBmaWxlcyxcbiAgICAgICRmaWxlOiBmaWxlcyAmJiBmaWxlcy5sZW5ndGggPyBmaWxlc1swXSA6IG51bGwsXG4gICAgICAkbmV3RmlsZXM6IGFsbE5ld0ZpbGVzLFxuICAgICAgJGR1cGxpY2F0ZUZpbGVzOiBkdXBGaWxlcyxcbiAgICAgICRldmVudDogZXZ0XG4gICAgfSk7XG5cbiAgICB2YXIgdmFsaWRhdGVBZnRlclJlc2l6ZSA9IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZWYWxpZGF0ZUFmdGVyUmVzaXplJywgYXR0ciwgc2NvcGUpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB1cGxvYWQuYXR0ckdldHRlcignbmdmTW9kZWxPcHRpb25zJywgYXR0ciwgc2NvcGUpO1xuICAgIHVwbG9hZC52YWxpZGF0ZShhbGxOZXdGaWxlcywga2VlcCA/IHByZXZWYWxpZEZpbGVzLmxlbmd0aCA6IDAsIG5nTW9kZWwsIGF0dHIsIHNjb3BlKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgIGlmIChub0RlbGF5KSB7XG4gICAgICAgIHVwZGF0ZShhbGxOZXdGaWxlcywgW10sIGZpbGVzLCBkdXBGaWxlcywgaXNTaW5nbGVNb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLmFsbG93SW52YWxpZCkgJiYgIXZhbGlkYXRlQWZ0ZXJSZXNpemUpIHtcbiAgICAgICAgICB2YWxpZHMgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbGlkRmlsZXM7XG4gICAgICAgICAgaW52YWxpZHMgPSB2YWxpZGF0aW9uUmVzdWx0LmludmFsaWRGaWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZHMgPSBhbGxOZXdGaWxlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBsb2FkLmF0dHJHZXR0ZXIoJ25nZkZpeE9yaWVudGF0aW9uJywgYXR0ciwgc2NvcGUpICYmIHVwbG9hZC5pc0V4aWZTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIGFwcGx5RXhpZlJvdGF0aW9ucyh2YWxpZHMsIGF0dHIsIHNjb3BlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc2l6ZUFuZFVwZGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2l6ZUFuZFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHVwbG9hZDtcbn1dKTtcblxubmdGaWxlVXBsb2FkLmRpcmVjdGl2ZSgnbmdmU2VsZWN0JywgWyckcGFyc2UnLCAnJHRpbWVvdXQnLCAnJGNvbXBpbGUnLCAnVXBsb2FkJywgZnVuY3Rpb24gKCRwYXJzZSwgJHRpbWVvdXQsICRjb21waWxlLCBVcGxvYWQpIHtcbiAgdmFyIGdlbmVyYXRlZEVsZW1zID0gW107XG5cbiAgZnVuY3Rpb24gaXNEZWxheWVkQ2xpY2tTdXBwb3J0ZWQodWEpIHtcbiAgICAvLyBmaXggZm9yIGFuZHJvaWQgbmF0aXZlIGJyb3dzZXIgPCA0LjQgYW5kIHNhZmFyaSB3aW5kb3dzXG4gICAgdmFyIG0gPSB1YS5tYXRjaCgvQW5kcm9pZFteXFxkXSooXFxkKylcXC4oXFxkKykvKTtcbiAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhciB2ID0gVXBsb2FkLmRlZmF1bHRzLmFuZHJvaWRGaXhNaW5vclZlcnNpb24gfHwgNDtcbiAgICAgIHJldHVybiBwYXJzZUludChtWzFdKSA8IDQgfHwgKHBhcnNlSW50KG1bMV0pID09PSB2ICYmIHBhcnNlSW50KG1bMl0pIDwgdik7XG4gICAgfVxuXG4gICAgLy8gc2FmYXJpIG9uIHdpbmRvd3NcbiAgICByZXR1cm4gdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIC8uKldpbmRvd3MuKlNhZmFyaS4qLy50ZXN0KHVhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtGaWxlU2VsZWN0KHNjb3BlLCBlbGVtLCBhdHRyLCBuZ01vZGVsLCAkcGFyc2UsICR0aW1lb3V0LCAkY29tcGlsZSwgdXBsb2FkKSB7XG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZTZWxlY3QgKi9cbiAgICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZkNoYW5nZSAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdNb2RlbCAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmTW9kZWxPcHRpb25zICovXG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZNdWx0aXBsZSAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmQ2FwdHVyZSAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmVmFsaWRhdGUgKi9cbiAgICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZktlZXAgKi9cbiAgICB2YXIgYXR0ckdldHRlciA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgcmV0dXJuIHVwbG9hZC5hdHRyR2V0dGVyKG5hbWUsIGF0dHIsIHNjb3BlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbnB1dFR5cGVGaWxlKCkge1xuICAgICAgcmV0dXJuIGVsZW1bMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIGF0dHIudHlwZSAmJiBhdHRyLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpbGUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGVDaGFuZ2VBdHRyKCkge1xuICAgICAgcmV0dXJuIGF0dHJHZXR0ZXIoJ25nZkNoYW5nZScpIHx8IGF0dHJHZXR0ZXIoJ25nZlNlbGVjdCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZUZuKGV2dCkge1xuICAgICAgaWYgKHVwbG9hZC5zaG91bGRVcGRhdGVPbignY2hhbmdlJywgYXR0ciwgc2NvcGUpKSB7XG4gICAgICAgIHZhciBmaWxlTGlzdCA9IGV2dC5fX2ZpbGVzXyB8fCAoZXZ0LnRhcmdldCAmJiBldnQudGFyZ2V0LmZpbGVzKSwgZmlsZXMgPSBbXTtcbiAgICAgICAgLyogSGFuZGxlIGR1cGxpY2F0ZSBjYWxsIGluICBJRTExICovXG4gICAgICAgIGlmICghZmlsZUxpc3QpIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbGVzLnB1c2goZmlsZUxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHVwbG9hZC51cGRhdGVNb2RlbChuZ01vZGVsLCBhdHRyLCBzY29wZSwgZmlsZUNoYW5nZUF0dHIoKSxcbiAgICAgICAgICBmaWxlcy5sZW5ndGggPyBmaWxlcyA6IG51bGwsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBsb2FkLnJlZ2lzdGVyTW9kZWxDaGFuZ2VWYWxpZGF0b3IobmdNb2RlbCwgYXR0ciwgc2NvcGUpO1xuXG4gICAgdmFyIHVud2F0Y2hlcyA9IFtdO1xuICAgIGlmIChhdHRyR2V0dGVyKCduZ2ZNdWx0aXBsZScpKSB7XG4gICAgICB1bndhdGNoZXMucHVzaChzY29wZS4kd2F0Y2goYXR0ckdldHRlcignbmdmTXVsdGlwbGUnKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmaWxlRWxlbS5hdHRyKCdtdWx0aXBsZScsIGF0dHJHZXR0ZXIoJ25nZk11bHRpcGxlJywgc2NvcGUpKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGF0dHJHZXR0ZXIoJ25nZkNhcHR1cmUnKSkge1xuICAgICAgdW53YXRjaGVzLnB1c2goc2NvcGUuJHdhdGNoKGF0dHJHZXR0ZXIoJ25nZkNhcHR1cmUnKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmaWxlRWxlbS5hdHRyKCdjYXB0dXJlJywgYXR0ckdldHRlcignbmdmQ2FwdHVyZScsIHNjb3BlKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChhdHRyR2V0dGVyKCduZ2ZBY2NlcHQnKSkge1xuICAgICAgdW53YXRjaGVzLnB1c2goc2NvcGUuJHdhdGNoKGF0dHJHZXR0ZXIoJ25nZkFjY2VwdCcpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpbGVFbGVtLmF0dHIoJ2FjY2VwdCcsIGF0dHJHZXR0ZXIoJ25nZkFjY2VwdCcsIHNjb3BlKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHVud2F0Y2hlcy5wdXNoKGF0dHIuJG9ic2VydmUoJ2FjY2VwdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZpbGVFbGVtLmF0dHIoJ2FjY2VwdCcsIGF0dHJHZXR0ZXIoJ2FjY2VwdCcpKTtcbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gYmluZEF0dHJUb0ZpbGVJbnB1dChmaWxlRWxlbSwgbGFiZWwpIHtcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUlkKHZhbCkge1xuICAgICAgICBmaWxlRWxlbS5hdHRyKCdpZCcsICduZ2YtJyArIHZhbCk7XG4gICAgICAgIGxhYmVsLmF0dHIoJ2lkJywgJ25nZi1sYWJlbC0nICsgdmFsKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtWzBdLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGVsZW1bMF0uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5uYW1lICE9PSAndHlwZScgJiYgYXR0cmlidXRlLm5hbWUgIT09ICdjbGFzcycgJiYgYXR0cmlidXRlLm5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHVwZGF0ZUlkKGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgICAgICB1bndhdGNoZXMucHVzaChhdHRyLiRvYnNlcnZlKCdpZCcsIHVwZGF0ZUlkKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVFbGVtLmF0dHIoYXR0cmlidXRlLm5hbWUsICghYXR0cmlidXRlLnZhbHVlICYmIChhdHRyaWJ1dGUubmFtZSA9PT0gJ3JlcXVpcmVkJyB8fFxuICAgICAgICAgICAgYXR0cmlidXRlLm5hbWUgPT09ICdtdWx0aXBsZScpKSA/IGF0dHJpYnV0ZS5uYW1lIDogYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWxlSW5wdXQoKSB7XG4gICAgICBpZiAoaXNJbnB1dFR5cGVGaWxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWxlRWxlbSA9IGFuZ3VsYXIuZWxlbWVudCgnPGlucHV0IHR5cGU9XCJmaWxlXCI+Jyk7XG5cbiAgICAgIHZhciBsYWJlbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGxhYmVsPnVwbG9hZDwvbGFiZWw+Jyk7XG4gICAgICBsYWJlbC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpLmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJylcbiAgICAgICAgLmNzcygnd2lkdGgnLCAnMHB4JykuY3NzKCdoZWlnaHQnLCAnMHB4JykuY3NzKCdib3JkZXInLCAnbm9uZScpXG4gICAgICAgIC5jc3MoJ21hcmdpbicsICcwcHgnKS5jc3MoJ3BhZGRpbmcnLCAnMHB4JykuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIGJpbmRBdHRyVG9GaWxlSW5wdXQoZmlsZUVsZW0sIGxhYmVsKTtcblxuICAgICAgZ2VuZXJhdGVkRWxlbXMucHVzaCh7ZWw6IGVsZW0sIHJlZjogbGFiZWx9KTtcblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsYWJlbC5hcHBlbmQoZmlsZUVsZW0pWzBdKTtcblxuICAgICAgcmV0dXJuIGZpbGVFbGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihldnQpIHtcbiAgICAgIGlmIChlbGVtLmF0dHIoJ2Rpc2FibGVkJykpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChhdHRyR2V0dGVyKCduZ2ZTZWxlY3REaXNhYmxlZCcsIHNjb3BlKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgciA9IGRldGVjdFN3aXBlKGV2dCk7XG4gICAgICAvLyBwcmV2ZW50IHRoZSBjbGljayBpZiBpdCBpcyBhIHN3aXBlXG4gICAgICBpZiAociAhPSBudWxsKSByZXR1cm4gcjtcblxuICAgICAgcmVzZXRNb2RlbChldnQpO1xuXG4gICAgICAvLyBmaXggZm9yIG1kIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gYW5kIGFkZGVkIGJhY2sgIzQ2MFxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0lucHV0VHlwZUZpbGUoKSAmJiAhZG9jdW1lbnQuYm9keS5jb250YWlucyhmaWxlRWxlbVswXSkpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRFbGVtcy5wdXNoKHtlbDogZWxlbSwgcmVmOiBmaWxlRWxlbS5wYXJlbnQoKX0pO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZmlsZUVsZW0ucGFyZW50KClbMF0pO1xuICAgICAgICAgIGZpbGVFbGVtLmJpbmQoJ2NoYW5nZScsIGNoYW5nZUZuKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkgey8qaWdub3JlKi9cbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGVsYXllZENsaWNrU3VwcG9ydGVkKG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZpbGVFbGVtWzBdLmNsaWNrKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZUVsZW1bMF0uY2xpY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgdmFyIGluaXRpYWxUb3VjaFN0YXJ0WSA9IDA7XG4gICAgdmFyIGluaXRpYWxUb3VjaFN0YXJ0WCA9IDA7XG5cbiAgICBmdW5jdGlvbiBkZXRlY3RTd2lwZShldnQpIHtcbiAgICAgIHZhciB0b3VjaGVzID0gZXZ0LmNoYW5nZWRUb3VjaGVzIHx8IChldnQub3JpZ2luYWxFdmVudCAmJiBldnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgIGluaXRpYWxUb3VjaFN0YXJ0WCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICBpbml0aWFsVG91Y2hTdGFydFkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGRvbid0IGJsb2NrIGV2ZW50IGRlZmF1bHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwcmV2ZW50IHNjcm9sbCBmcm9tIHRyaWdnZXJpbmcgZXZlbnRcbiAgICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50WCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50WSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnMoY3VycmVudFggLSBpbml0aWFsVG91Y2hTdGFydFgpID4gMjApIHx8XG4gICAgICAgICAgICAgIChNYXRoLmFicyhjdXJyZW50WSAtIGluaXRpYWxUb3VjaFN0YXJ0WSkgPiAyMCkpIHtcbiAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWxlRWxlbSA9IGVsZW07XG5cbiAgICBmdW5jdGlvbiByZXNldE1vZGVsKGV2dCkge1xuICAgICAgaWYgKHVwbG9hZC5zaG91bGRVcGRhdGVPbignY2xpY2snLCBhdHRyLCBzY29wZSkgJiYgZmlsZUVsZW0udmFsKCkpIHtcbiAgICAgICAgZmlsZUVsZW0udmFsKG51bGwpO1xuICAgICAgICB1cGxvYWQudXBkYXRlTW9kZWwobmdNb2RlbCwgYXR0ciwgc2NvcGUsIGZpbGVDaGFuZ2VBdHRyKCksIG51bGwsIGV2dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0lucHV0VHlwZUZpbGUoKSkge1xuICAgICAgZmlsZUVsZW0gPSBjcmVhdGVGaWxlSW5wdXQoKTtcbiAgICB9XG4gICAgZmlsZUVsZW0uYmluZCgnY2hhbmdlJywgY2hhbmdlRm4pO1xuXG4gICAgaWYgKCFpc0lucHV0VHlwZUZpbGUoKSkge1xuICAgICAgZWxlbS5iaW5kKCdjbGljayB0b3VjaHN0YXJ0IHRvdWNoZW5kJywgY2xpY2tIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5iaW5kKCdjbGljaycsIHJlc2V0TW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGllMTBTYW1lRmlsZVNlbGVjdEZpeChldnQpIHtcbiAgICAgIGlmIChmaWxlRWxlbSAmJiAhZmlsZUVsZW0uYXR0cignX19uZ2ZfaWUxMF9GaXhfJykpIHtcbiAgICAgICAgaWYgKCFmaWxlRWxlbVswXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZmlsZUVsZW0gPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBmaWxlRWxlbS51bmJpbmQoJ2NsaWNrJyk7XG4gICAgICAgIHZhciBjbG9uZSA9IGZpbGVFbGVtLmNsb25lKCk7XG4gICAgICAgIGZpbGVFbGVtLnJlcGxhY2VXaXRoKGNsb25lKTtcbiAgICAgICAgZmlsZUVsZW0gPSBjbG9uZTtcbiAgICAgICAgZmlsZUVsZW0uYXR0cignX19uZ2ZfaWUxMF9GaXhfJywgJ3RydWUnKTtcbiAgICAgICAgZmlsZUVsZW0uYmluZCgnY2hhbmdlJywgY2hhbmdlRm4pO1xuICAgICAgICBmaWxlRWxlbS5iaW5kKCdjbGljaycsIGllMTBTYW1lRmlsZVNlbGVjdEZpeCk7XG4gICAgICAgIGZpbGVFbGVtWzBdLmNsaWNrKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGVFbGVtLnJlbW92ZUF0dHIoJ19fbmdmX2llMTBfRml4XycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgIT09IC0xKSB7XG4gICAgICBmaWxlRWxlbS5iaW5kKCdjbGljaycsIGllMTBTYW1lRmlsZVNlbGVjdEZpeCk7XG4gICAgfVxuXG4gICAgaWYgKG5nTW9kZWwpIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoZmlsZUVsZW0udmFsKCkpIHtcbiAgICAgICAgICBmaWxlRWxlbS52YWwobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG5cbiAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc0lucHV0VHlwZUZpbGUoKSkgZmlsZUVsZW0ucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgICBhbmd1bGFyLmZvckVhY2godW53YXRjaGVzLCBmdW5jdGlvbiAodW53YXRjaCkge1xuICAgICAgICB1bndhdGNoKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VuZXJhdGVkRWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0ZWRFbGVtc1tpXTtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGcuZWxbMF0pKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkRWxlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGcucmVmLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAod2luZG93LkZpbGVBUEkgJiYgd2luZG93LkZpbGVBUEkubmdmRml4SUUpIHtcbiAgICAgIHdpbmRvdy5GaWxlQVBJLm5nZkZpeElFKGVsZW0sIGZpbGVFbGVtLCBjaGFuZ2VGbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0FFQycsXG4gICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcbiAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW0sIGF0dHIsIG5nTW9kZWwpIHtcbiAgICAgIGxpbmtGaWxlU2VsZWN0KHNjb3BlLCBlbGVtLCBhdHRyLCBuZ01vZGVsLCAkcGFyc2UsICR0aW1lb3V0LCAkY29tcGlsZSwgVXBsb2FkKTtcbiAgICB9XG4gIH07XG59XSk7XG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgbmdGaWxlVXBsb2FkLnNlcnZpY2UoJ1VwbG9hZERhdGFVcmwnLCBbJ1VwbG9hZEJhc2UnLCAnJHRpbWVvdXQnLCAnJHEnLCBmdW5jdGlvbiAoVXBsb2FkQmFzZSwgJHRpbWVvdXQsICRxKSB7XG4gICAgdmFyIHVwbG9hZCA9IFVwbG9hZEJhc2U7XG4gICAgdXBsb2FkLmJhc2U2NERhdGFVcmwgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheShmaWxlKSkge1xuICAgICAgICB2YXIgZCA9ICRxLmRlZmVyKCksIGNvdW50ID0gMDtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGUsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgdXBsb2FkLmRhdGFVcmwoZiwgdHJ1ZSlbJ2ZpbmFsbHknXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSBmaWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdXJscyA9IFtdO1xuICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZSwgZnVuY3Rpb24gKGZmKSB7XG4gICAgICAgICAgICAgICAgdXJscy5wdXNoKGZmLiRuZ2ZEYXRhVXJsKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGQucmVzb2x2ZSh1cmxzLCBmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkLnByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXBsb2FkLmRhdGFVcmwoZmlsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGxvYWQuZGF0YVVybCA9IGZ1bmN0aW9uIChmaWxlLCBkaXNhbGxvd09iamVjdFVybCkge1xuICAgICAgaWYgKCFmaWxlKSByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZShmaWxlLCBmaWxlKTtcbiAgICAgIGlmICgoZGlzYWxsb3dPYmplY3RVcmwgJiYgZmlsZS4kbmdmRGF0YVVybCAhPSBudWxsKSB8fCAoIWRpc2FsbG93T2JqZWN0VXJsICYmIGZpbGUuJG5nZkJsb2JVcmwgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIHVwbG9hZC5lbXB0eVByb21pc2UoZGlzYWxsb3dPYmplY3RVcmwgPyBmaWxlLiRuZ2ZEYXRhVXJsIDogZmlsZS4kbmdmQmxvYlVybCwgZmlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGRpc2FsbG93T2JqZWN0VXJsID8gZmlsZS4kJG5nZkRhdGFVcmxQcm9taXNlIDogZmlsZS4kJG5nZkJsb2JVcmxQcm9taXNlO1xuICAgICAgaWYgKHApIHJldHVybiBwO1xuXG4gICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93LkZpbGVSZWFkZXIgJiYgZmlsZSAmJlxuICAgICAgICAgICghd2luZG93LkZpbGVBUEkgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDgnKSA9PT0gLTEgfHwgZmlsZS5zaXplIDwgMjAwMDApICYmXG4gICAgICAgICAgKCF3aW5kb3cuRmlsZUFQSSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgOScpID09PSAtMSB8fCBmaWxlLnNpemUgPCA0MDAwMDAwKSkge1xuICAgICAgICAgIC8vcHJlZmVyIFVSTC5jcmVhdGVPYmplY3RVUkwgZm9yIGhhbmRsaW5nIHJlZnJlbmNlcyB0byBmaWxlcyBvZiBhbGwgc2l6ZXNcbiAgICAgICAgICAvL3NpbmNlIGl0IGRvZXNuwrR0IGJ1aWxkIGEgbGFyZ2Ugc3RyaW5nIGluIG1lbW9yeVxuICAgICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgaWYgKFVSTCAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMICYmICFkaXNhbGxvd09iamVjdFVybCkge1xuICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmaWxlLiRuZ2ZCbG9iVXJsID0gJyc7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZpbGUuJG5nZkJsb2JVcmwgPSB1cmw7XG4gICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVybCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgdXBsb2FkLmJsb2JVcmxzID0gdXBsb2FkLmJsb2JVcmxzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHVwbG9hZC5ibG9iVXJsc1RvdGFsU2l6ZSA9IHVwbG9hZC5ibG9iVXJsc1RvdGFsU2l6ZSB8fCAwO1xuICAgICAgICAgICAgICAgIHVwbG9hZC5ibG9iVXJscy5wdXNoKHt1cmw6IHVybCwgc2l6ZTogZmlsZS5zaXplfSk7XG4gICAgICAgICAgICAgICAgdXBsb2FkLmJsb2JVcmxzVG90YWxTaXplICs9IGZpbGUuc2l6ZSB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBtYXhNZW1vcnkgPSB1cGxvYWQuZGVmYXVsdHMuYmxvYlVybHNNYXhNZW1vcnkgfHwgMjY4NDM1NDU2O1xuICAgICAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSB1cGxvYWQuZGVmYXVsdHMuYmxvYlVybHNNYXhRdWV1ZVNpemUgfHwgMjAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodXBsb2FkLmJsb2JVcmxzVG90YWxTaXplID4gbWF4TWVtb3J5IHx8IHVwbG9hZC5ibG9iVXJscy5sZW5ndGggPiBtYXhMZW5ndGgpICYmIHVwbG9hZC5ibG9iVXJscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdXBsb2FkLmJsb2JVcmxzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqLnVybCk7XG4gICAgICAgICAgICAgICAgICB1cGxvYWQuYmxvYlVybHNUb3RhbFNpemUgLT0gb2JqLnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZmlsZS4kbmdmRGF0YVVybCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGZpbGUuJG5nZkRhdGFVcmw7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZpbGUuJG5nZkRhdGFVcmwgPSAnJztcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaWxlW2Rpc2FsbG93T2JqZWN0VXJsID8gJyRuZ2ZEYXRhVXJsJyA6ICckbmdmQmxvYlVybCddID0gJyc7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChkaXNhbGxvd09iamVjdFVybCkge1xuICAgICAgICBwID0gZmlsZS4kJG5nZkRhdGFVcmxQcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAgPSBmaWxlLiQkbmdmQmxvYlVybFByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfVxuICAgICAgcFsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIGZpbGVbZGlzYWxsb3dPYmplY3RVcmwgPyAnJCRuZ2ZEYXRhVXJsUHJvbWlzZScgOiAnJCRuZ2ZCbG9iVXJsUHJvbWlzZSddO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIHJldHVybiB1cGxvYWQ7XG4gIH1dKTtcblxuICBmdW5jdGlvbiBnZXRUYWdUeXBlKGVsKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHJldHVybiAnaW1hZ2UnO1xuICAgIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpbycpIHJldHVybiAnYXVkaW8nO1xuICAgIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlbycpIHJldHVybiAndmlkZW8nO1xuICAgIHJldHVybiAvLi87XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rRmlsZURpcmVjdGl2ZShVcGxvYWQsICR0aW1lb3V0LCBzY29wZSwgZWxlbSwgYXR0ciwgZGlyZWN0aXZlTmFtZSwgcmVzaXplUGFyYW1zLCBpc0JhY2tncm91bmQpIHtcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3REYXRhVXJsKGZpbGUpIHtcbiAgICAgIHZhciBkaXNhbGxvd09iamVjdFVybCA9IFVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZOb09iamVjdFVybCcsIGF0dHIsIHNjb3BlKTtcbiAgICAgIFVwbG9hZC5kYXRhVXJsKGZpbGUsIGRpc2FsbG93T2JqZWN0VXJsKVsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzcmMgPSAoZGlzYWxsb3dPYmplY3RVcmwgPyBmaWxlLiRuZ2ZEYXRhVXJsIDogZmlsZS4kbmdmQmxvYlVybCkgfHwgZmlsZS4kbmdmRGF0YVVybDtcbiAgICAgICAgICBpZiAoaXNCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBlbGVtLmNzcygnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoXFwnJyArIChzcmMgfHwgJycpICsgJ1xcJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5hdHRyKCdzcmMnLCBzcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKCduZy1oaWRlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoJ25nLWhpZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVud2F0Y2ggPSBzY29wZS4kd2F0Y2goYXR0cltkaXJlY3RpdmVOYW1lXSwgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSByZXNpemVQYXJhbXM7XG4gICAgICAgIGlmIChkaXJlY3RpdmVOYW1lID09PSAnbmdmVGh1bWJuYWlsJykge1xuICAgICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6IGVsZW1bMF0ubmF0dXJhbFdpZHRoIHx8IGVsZW1bMF0uY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogZWxlbVswXS5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1bMF0uY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2l6ZS53aWR0aCA9PT0gMCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtWzBdKTtcbiAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCAmJiBzdHlsZS53aWR0aC5pbmRleE9mKCdweCcpID4gLTEgJiYgc3R5bGUuaGVpZ2h0ICYmIHN0eWxlLmhlaWdodC5pbmRleE9mKCdweCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VJbnQoc3R5bGUud2lkdGguc2xpY2UoMCwgLTIpKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHN0eWxlLmhlaWdodC5zbGljZSgwLCAtMikpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoZmlsZSkpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKCduZy1oaWRlJyk7XG4gICAgICAgICAgaWYgKGlzQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybChcXCcnICsgZmlsZSArICdcXCcpJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmF0dHIoJ3NyYycsIGZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnR5cGUgJiYgZmlsZS50eXBlLnNlYXJjaChnZXRUYWdUeXBlKGVsZW1bMF0pKSA9PT0gMCAmJlxuICAgICAgICAgICghaXNCYWNrZ3JvdW5kIHx8IGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSkge1xuICAgICAgICAgIGlmIChzaXplICYmIFVwbG9hZC5pc1Jlc2l6ZVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICBzaXplLnJlc2l6ZUlmID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZSZXNpemVJZicsIGF0dHIsIHNjb3BlLFxuICAgICAgICAgICAgICAgIHskd2lkdGg6IHdpZHRoLCAkaGVpZ2h0OiBoZWlnaHQsICRmaWxlOiBmaWxlfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVXBsb2FkLnJlc2l6ZShmaWxlLCBzaXplKS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdERhdGFVcmwoZik7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3RydWN0RGF0YVVybChmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcygnbmctaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW53YXRjaCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmU3JjICovXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmTm9PYmplY3RVcmwgKi9cbiAgbmdGaWxlVXBsb2FkLmRpcmVjdGl2ZSgnbmdmU3JjJywgWydVcGxvYWQnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoVXBsb2FkLCAkdGltZW91dCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0FFJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0cikge1xuICAgICAgICBsaW5rRmlsZURpcmVjdGl2ZShVcGxvYWQsICR0aW1lb3V0LCBzY29wZSwgZWxlbSwgYXR0ciwgJ25nZlNyYycsXG4gICAgICAgICAgVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlJlc2l6ZScsIGF0dHIsIHNjb3BlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZkJhY2tncm91bmQgKi9cbiAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZOb09iamVjdFVybCAqL1xuICBuZ0ZpbGVVcGxvYWQuZGlyZWN0aXZlKCduZ2ZCYWNrZ3JvdW5kJywgWydVcGxvYWQnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoVXBsb2FkLCAkdGltZW91dCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0FFJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0cikge1xuICAgICAgICBsaW5rRmlsZURpcmVjdGl2ZShVcGxvYWQsICR0aW1lb3V0LCBzY29wZSwgZWxlbSwgYXR0ciwgJ25nZkJhY2tncm91bmQnLFxuICAgICAgICAgIFVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZSZXNpemUnLCBhdHRyLCBzY29wZSksIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZlRodW1ibmFpbCAqL1xuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZkFzQmFja2dyb3VuZCAqL1xuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZlNpemUgKi9cbiAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZOb09iamVjdFVybCAqL1xuICBuZ0ZpbGVVcGxvYWQuZGlyZWN0aXZlKCduZ2ZUaHVtYm5haWwnLCBbJ1VwbG9hZCcsICckdGltZW91dCcsIGZ1bmN0aW9uIChVcGxvYWQsICR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtLCBhdHRyKSB7XG4gICAgICAgIHZhciBzaXplID0gVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlNpemUnLCBhdHRyLCBzY29wZSk7XG4gICAgICAgIGxpbmtGaWxlRGlyZWN0aXZlKFVwbG9hZCwgJHRpbWVvdXQsIHNjb3BlLCBlbGVtLCBhdHRyLCAnbmdmVGh1bWJuYWlsJywgc2l6ZSxcbiAgICAgICAgICBVcGxvYWQuYXR0ckdldHRlcignbmdmQXNCYWNrZ3JvdW5kJywgYXR0ciwgc2NvcGUpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbiAgbmdGaWxlVXBsb2FkLmNvbmZpZyhbJyRjb21waWxlUHJvdmlkZXInLCBmdW5jdGlvbiAoJGNvbXBpbGVQcm92aWRlcikge1xuICAgIGlmICgkY29tcGlsZVByb3ZpZGVyLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCkgJGNvbXBpbGVQcm92aWRlci5pbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3QoL15cXHMqKGh0dHBzP3xmdHB8bWFpbHRvfHRlbHx3ZWJjYWx8bG9jYWx8ZmlsZXxkYXRhfGJsb2IpOi8pO1xuICAgIGlmICgkY29tcGlsZVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KSAkY29tcGlsZVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KC9eXFxzKihodHRwcz98ZnRwfG1haWx0b3x0ZWx8d2ViY2FsfGxvY2FsfGZpbGV8ZGF0YXxibG9iKTovKTtcbiAgfV0pO1xuXG4gIG5nRmlsZVVwbG9hZC5maWx0ZXIoJ25nZkRhdGFVcmwnLCBbJ1VwbG9hZERhdGFVcmwnLCAnJHNjZScsIGZ1bmN0aW9uIChVcGxvYWREYXRhVXJsLCAkc2NlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlLCBkaXNhbGxvd09iamVjdFVybCwgdHJ1c3RlZFVybCkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoZmlsZSkpIHtcbiAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKGZpbGUpO1xuICAgICAgfVxuICAgICAgdmFyIHNyYyA9IGZpbGUgJiYgKChkaXNhbGxvd09iamVjdFVybCA/IGZpbGUuJG5nZkRhdGFVcmwgOiBmaWxlLiRuZ2ZCbG9iVXJsKSB8fCBmaWxlLiRuZ2ZEYXRhVXJsKTtcbiAgICAgIGlmIChmaWxlICYmICFzcmMpIHtcbiAgICAgICAgaWYgKCFmaWxlLiRuZ2ZEYXRhVXJsRmlsdGVySW5Qcm9ncmVzcyAmJiBhbmd1bGFyLmlzT2JqZWN0KGZpbGUpKSB7XG4gICAgICAgICAgZmlsZS4kbmdmRGF0YVVybEZpbHRlckluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgIFVwbG9hZERhdGFVcmwuZGF0YVVybChmaWxlLCBkaXNhbGxvd09iamVjdFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGUpIGRlbGV0ZSBmaWxlLiRuZ2ZEYXRhVXJsRmlsdGVySW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiAoZmlsZSAmJiBzcmMgPyAodHJ1c3RlZFVybCA/ICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKHNyYykgOiBzcmMpIDogZmlsZSkgfHwgJyc7XG4gICAgfTtcbiAgfV0pO1xuXG59KSgpO1xuXG5uZ0ZpbGVVcGxvYWQuc2VydmljZSgnVXBsb2FkVmFsaWRhdGUnLCBbJ1VwbG9hZERhdGFVcmwnLCAnJHEnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoVXBsb2FkRGF0YVVybCwgJHEsICR0aW1lb3V0KSB7XG4gIHZhciB1cGxvYWQgPSBVcGxvYWREYXRhVXJsO1xuXG4gIGZ1bmN0aW9uIGdsb2JTdHJpbmdUb1JlZ2V4KHN0cikge1xuICAgIHZhciByZWdleHAgPSAnJywgZXhjbHVkZXMgPSBbXTtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDIgJiYgc3RyWzBdID09PSAnLycgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICByZWdleHAgPSBzdHIuc3Vic3RyaW5nKDEsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNwbGl0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHIgPSBnbG9iU3RyaW5nVG9SZWdleChzcGxpdFtpXSk7XG4gICAgICAgICAgaWYgKHIucmVnZXhwKSB7XG4gICAgICAgICAgICByZWdleHAgKz0gJygnICsgci5yZWdleHAgKyAnKSc7XG4gICAgICAgICAgICBpZiAoaSA8IHNwbGl0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcmVnZXhwICs9ICd8JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjbHVkZXMgPSBleGNsdWRlcy5jb25jYXQoci5leGNsdWRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgICAgICAgIGV4Y2x1ZGVzLnB1c2goJ14oKD8hJyArIGdsb2JTdHJpbmdUb1JlZ2V4KHN0ci5zdWJzdHJpbmcoMSkpLnJlZ2V4cCArICcpLikqJCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdHIuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSAnKicgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cCA9ICdeJyArIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1suXFxcXFxcXFwrKj9cXFxcW1xcXFxeXFxcXF0kKCl7fT0hPD58OlxcXFwtXScsICdnJyksICdcXFxcJCYnKSArICckJztcbiAgICAgICAgICByZWdleHAgPSByZWdleHAucmVwbGFjZSgvXFxcXFxcKi9nLCAnLionKS5yZXBsYWNlKC9cXFxcXFw/L2csICcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtyZWdleHA6IHJlZ2V4cCwgZXhjbHVkZXM6IGV4Y2x1ZGVzfTtcbiAgfVxuXG4gIHVwbG9hZC52YWxpZGF0ZVBhdHRlcm4gPSBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IGdsb2JTdHJpbmdUb1JlZ2V4KHZhbCksIHZhbGlkID0gdHJ1ZTtcbiAgICBpZiAocGF0dGVybi5yZWdleHAgJiYgcGF0dGVybi5yZWdleHAubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlZ2V4cCwgJ2knKTtcbiAgICAgIHZhbGlkID0gKGZpbGUudHlwZSAhPSBudWxsICYmIHJlZ2V4cC50ZXN0KGZpbGUudHlwZSkpIHx8XG4gICAgICAgIChmaWxlLm5hbWUgIT0gbnVsbCAmJiByZWdleHAudGVzdChmaWxlLm5hbWUpKTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IHBhdHRlcm4uZXhjbHVkZXMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgdmFyIGV4Y2x1ZGUgPSBuZXcgUmVnRXhwKHBhdHRlcm4uZXhjbHVkZXNbbGVuXSwgJ2knKTtcbiAgICAgIHZhbGlkID0gdmFsaWQgJiYgKGZpbGUudHlwZSA9PSBudWxsIHx8IGV4Y2x1ZGUudGVzdChmaWxlLnR5cGUpKSAmJlxuICAgICAgICAoZmlsZS5uYW1lID09IG51bGwgfHwgZXhjbHVkZS50ZXN0KGZpbGUubmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH07XG5cbiAgdXBsb2FkLnJhdGlvVG9GbG9hdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgciA9IHZhbC50b1N0cmluZygpLCB4SW5kZXggPSByLnNlYXJjaCgvW3g6XS9pKTtcbiAgICBpZiAoeEluZGV4ID4gLTEpIHtcbiAgICAgIHIgPSBwYXJzZUZsb2F0KHIuc3Vic3RyaW5nKDAsIHhJbmRleCkpIC8gcGFyc2VGbG9hdChyLnN1YnN0cmluZyh4SW5kZXggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUZsb2F0KHIpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICB1cGxvYWQucmVnaXN0ZXJNb2RlbENoYW5nZVZhbGlkYXRvciA9IGZ1bmN0aW9uIChuZ01vZGVsLCBhdHRyLCBzY29wZSkge1xuICAgIGlmIChuZ01vZGVsKSB7XG4gICAgICBuZ01vZGVsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIGlmIChuZ01vZGVsLiRkaXJ0eSkge1xuICAgICAgICAgIHZhciBmaWxlc0FycmF5ID0gZmlsZXM7XG4gICAgICAgICAgaWYgKGZpbGVzICYmICFhbmd1bGFyLmlzQXJyYXkoZmlsZXMpKSB7XG4gICAgICAgICAgICBmaWxlc0FycmF5ID0gW2ZpbGVzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkLnZhbGlkYXRlKGZpbGVzQXJyYXksIDAsIG5nTW9kZWwsIGF0dHIsIHNjb3BlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVwbG9hZC5hcHBseU1vZGVsVmFsaWRhdGlvbihuZ01vZGVsLCBmaWxlc0FycmF5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFya01vZGVsQXNEaXJ0eShuZ01vZGVsLCBmaWxlcykge1xuICAgIGlmIChmaWxlcyAhPSBudWxsICYmICFuZ01vZGVsLiRkaXJ0eSkge1xuICAgICAgaWYgKG5nTW9kZWwuJHNldERpcnR5KSB7XG4gICAgICAgIG5nTW9kZWwuJHNldERpcnR5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZ01vZGVsLiRkaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBsb2FkLmFwcGx5TW9kZWxWYWxpZGF0aW9uID0gZnVuY3Rpb24gKG5nTW9kZWwsIGZpbGVzKSB7XG4gICAgbWFya01vZGVsQXNEaXJ0eShuZ01vZGVsLCBmaWxlcyk7XG4gICAgYW5ndWxhci5mb3JFYWNoKG5nTW9kZWwuJG5nZlZhbGlkYXRpb25zLCBmdW5jdGlvbiAodmFsaWRhdGlvbikge1xuICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkodmFsaWRhdGlvbi5uYW1lLCB2YWxpZGF0aW9uLnZhbGlkKTtcbiAgICB9KTtcbiAgfTtcblxuICB1cGxvYWQuZ2V0VmFsaWRhdGlvbkF0dHIgPSBmdW5jdGlvbiAoYXR0ciwgc2NvcGUsIG5hbWUsIHZhbGlkYXRpb25OYW1lLCBmaWxlKSB7XG4gICAgdmFyIGROYW1lID0gJ25nZicgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgICB2YXIgdmFsID0gdXBsb2FkLmF0dHJHZXR0ZXIoZE5hbWUsIGF0dHIsIHNjb3BlLCB7JGZpbGU6IGZpbGV9KTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHZhbCA9IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZWYWxpZGF0ZScsIGF0dHIsIHNjb3BlLCB7JGZpbGU6IGZpbGV9KTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gKHZhbGlkYXRpb25OYW1lIHx8IG5hbWUpLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhbCA9IHZhbFtzcGxpdFswXV07XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFsID0gdmFsICYmIHZhbFtzcGxpdFsxXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICB1cGxvYWQudmFsaWRhdGUgPSBmdW5jdGlvbiAoZmlsZXMsIHByZXZMZW5ndGgsIG5nTW9kZWwsIGF0dHIsIHNjb3BlKSB7XG4gICAgbmdNb2RlbCA9IG5nTW9kZWwgfHwge307XG4gICAgbmdNb2RlbC4kbmdmVmFsaWRhdGlvbnMgPSBuZ01vZGVsLiRuZ2ZWYWxpZGF0aW9ucyB8fCBbXTtcblxuICAgIGFuZ3VsYXIuZm9yRWFjaChuZ01vZGVsLiRuZ2ZWYWxpZGF0aW9ucywgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHYudmFsaWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdmFyIGF0dHJHZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gdXBsb2FkLmF0dHJHZXR0ZXIobmFtZSwgYXR0ciwgc2NvcGUsIHBhcmFtcyk7XG4gICAgfTtcblxuICAgIHZhciBpZ25vcmVkRXJyb3JzID0gKHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZJZ25vcmVJbnZhbGlkJywgYXR0ciwgc2NvcGUpIHx8ICcnKS5zcGxpdCgnICcpO1xuICAgIHZhciBydW5BbGxWYWxpZGF0aW9uID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlJ1bkFsbFZhbGlkYXRpb25zJywgYXR0ciwgc2NvcGUpO1xuXG4gICAgaWYgKGZpbGVzID09IG51bGwgfHwgZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZSh7J3ZhbGlkRmlsZXMnOiBmaWxlcywgJ2ludmFsaWRGaWxlcyc6IFtdfSk7XG4gICAgfVxuXG4gICAgZmlsZXMgPSBmaWxlcy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IFtmaWxlc10gOiBmaWxlcy5zbGljZSgwKTtcbiAgICB2YXIgaW52YWxpZEZpbGVzID0gW107XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMobmFtZSwgdmFsaWRhdGlvbk5hbWUsIGZuKSB7XG4gICAgICBpZiAoZmlsZXMpIHtcbiAgICAgICAgdmFyIGkgPSBmaWxlcy5sZW5ndGgsIHZhbGlkID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB1cGxvYWQuZ2V0VmFsaWRhdGlvbkF0dHIoYXR0ciwgc2NvcGUsIG5hbWUsIHZhbGlkYXRpb25OYW1lLCBmaWxlKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoIWZuKGZpbGUsIHZhbCwgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlZEVycm9ycy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgZmlsZS4kZXJyb3IgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgKGZpbGUuJGVycm9yTWVzc2FnZXMgPSAoZmlsZS4kZXJyb3JNZXNzYWdlcyB8fCB7fSkpW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGZpbGUuJGVycm9yUGFyYW0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZEZpbGVzLmluZGV4T2YoZmlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFydW5BbGxWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZpbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkICE9PSBudWxsKSB7XG4gICAgICAgICAgbmdNb2RlbC4kbmdmVmFsaWRhdGlvbnMucHVzaCh7bmFtZTogbmFtZSwgdmFsaWQ6IHZhbGlkfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVN5bmMoJ3BhdHRlcm4nLCBudWxsLCB1cGxvYWQudmFsaWRhdGVQYXR0ZXJuKTtcbiAgICB2YWxpZGF0ZVN5bmMoJ21pblNpemUnLCAnc2l6ZS5taW4nLCBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgICByZXR1cm4gZmlsZS5zaXplICsgMC4xID49IHVwbG9hZC50cmFuc2xhdGVTY2FsYXJzKHZhbCk7XG4gICAgfSk7XG4gICAgdmFsaWRhdGVTeW5jKCdtYXhTaXplJywgJ3NpemUubWF4JywgZnVuY3Rpb24gKGZpbGUsIHZhbCkge1xuICAgICAgcmV0dXJuIGZpbGUuc2l6ZSAtIDAuMSA8PSB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyh2YWwpO1xuICAgIH0pO1xuICAgIHZhciB0b3RhbFNpemUgPSAwO1xuICAgIHZhbGlkYXRlU3luYygnbWF4VG90YWxTaXplJywgbnVsbCwgZnVuY3Rpb24gKGZpbGUsIHZhbCkge1xuICAgICAgdG90YWxTaXplICs9IGZpbGUuc2l6ZTtcbiAgICAgIGlmICh0b3RhbFNpemUgPiB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyh2YWwpKSB7XG4gICAgICAgIGZpbGVzLnNwbGljZSgwLCBmaWxlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhbGlkYXRlU3luYygndmFsaWRhdGVGbicsIG51bGwsIGZ1bmN0aW9uIChmaWxlLCByKSB7XG4gICAgICByZXR1cm4gciA9PT0gdHJ1ZSB8fCByID09PSBudWxsIHx8IHIgPT09ICcnO1xuICAgIH0pO1xuXG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKHsndmFsaWRGaWxlcyc6IFtdLCAnaW52YWxpZEZpbGVzJzogaW52YWxpZEZpbGVzfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYyhuYW1lLCB2YWxpZGF0aW9uTmFtZSwgdHlwZSwgYXN5bmNGbiwgZm4pIHtcbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVSZXN1bHQoZGVmZXIsIGZpbGUsIHZhbCkge1xuICAgICAgICBmdW5jdGlvbiByZXNvbHZlSW50ZXJuYWwoZm4pIHtcbiAgICAgICAgICBpZiAoZm4oKSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZWRFcnJvcnMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZmlsZS4kZXJyb3IgPSBuYW1lO1xuICAgICAgICAgICAgICAoZmlsZS4kZXJyb3JNZXNzYWdlcyA9IChmaWxlLiRlcnJvck1lc3NhZ2VzIHx8IHt9KSlbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICBmaWxlLiRlcnJvclBhcmFtID0gdmFsO1xuICAgICAgICAgICAgICBpZiAoaW52YWxpZEZpbGVzLmluZGV4T2YoZmlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZEZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFydW5BbGxWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmaWxlcy5pbmRleE9mKGZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIGZpbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBqID0gZmlsZXMuaW5kZXhPZihmaWxlKTtcbiAgICAgICAgICAgICAgaWYgKGogPiAtMSkgZmlsZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgIGFzeW5jRm4oZmlsZSwgdmFsKS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXNvbHZlSW50ZXJuYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIWZuKGQsIHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlSW50ZXJuYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXR0ckdldHRlcignbmdmVmFsaWRhdGVGb3JjZScsIHskZmlsZTogZmlsZX0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZXMgPSBbdXBsb2FkLmVtcHR5UHJvbWlzZSh0cnVlKV07XG4gICAgICBpZiAoZmlsZXMpIHtcbiAgICAgICAgZmlsZXMgPSBmaWxlcy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IFtmaWxlc10gOiBmaWxlcztcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChkZWZlci5wcm9taXNlKTtcbiAgICAgICAgICBpZiAodHlwZSAmJiAoZmlsZS50eXBlID09IG51bGwgfHwgZmlsZS50eXBlLnNlYXJjaCh0eXBlKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuYW1lID09PSAnZGltZW5zaW9ucycgJiYgdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZkRpbWVuc2lvbnMnLCBhdHRyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGxvYWQuaW1hZ2VEaW1lbnNpb25zKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdChkZWZlciwgZmlsZSxcbiAgICAgICAgICAgICAgICBhdHRyR2V0dGVyKCduZ2ZEaW1lbnNpb25zJywgeyRmaWxlOiBmaWxlLCAkd2lkdGg6IGQud2lkdGgsICRoZWlnaHQ6IGQuaGVpZ2h0fSkpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2R1cmF0aW9uJyAmJiB1cGxvYWQuYXR0ckdldHRlcignbmdmRHVyYXRpb24nLCBhdHRyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGxvYWQubWVkaWFEdXJhdGlvbihmaWxlKS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVSZXN1bHQoZGVmZXIsIGZpbGUsXG4gICAgICAgICAgICAgICAgYXR0ckdldHRlcignbmdmRHVyYXRpb24nLCB7JGZpbGU6IGZpbGUsICRkdXJhdGlvbjogZH0pKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdChkZWZlciwgZmlsZSxcbiAgICAgICAgICAgICAgdXBsb2FkLmdldFZhbGlkYXRpb25BdHRyKGF0dHIsIHNjb3BlLCBuYW1lLCB2YWxpZGF0aW9uTmFtZSwgZmlsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgZGVmZmVyID0gJHEuZGVmZXIoKTtcbiAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbHVlc1tpXSkge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5nTW9kZWwuJG5nZlZhbGlkYXRpb25zLnB1c2goe25hbWU6IG5hbWUsIHZhbGlkOiBpc1ZhbGlkfSk7XG4gICAgICAgIGRlZmZlci5yZXNvbHZlKGlzVmFsaWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVmZmVyLnByb21pc2U7XG4gICAgfVxuXG4gICAgdmFyIGRlZmZlciA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ21heEhlaWdodCcsICdoZWlnaHQubWF4JywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkLmhlaWdodCA8PSB2YWw7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdtaW5IZWlnaHQnLCAnaGVpZ2h0Lm1pbicsIC9pbWFnZS8sXG4gICAgICB0aGlzLmltYWdlRGltZW5zaW9ucywgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICByZXR1cm4gZC5oZWlnaHQgPj0gdmFsO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWF4V2lkdGgnLCAnd2lkdGgubWF4JywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkLndpZHRoIDw9IHZhbDtcbiAgICAgIH0pKTtcbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ21pbldpZHRoJywgJ3dpZHRoLm1pbicsIC9pbWFnZS8sXG4gICAgICB0aGlzLmltYWdlRGltZW5zaW9ucywgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICByZXR1cm4gZC53aWR0aCA+PSB2YWw7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdkaW1lbnNpb25zJywgbnVsbCwgL2ltYWdlLyxcbiAgICAgIGZ1bmN0aW9uIChmaWxlLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHVwbG9hZC5lbXB0eVByb21pc2UodmFsKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygncmF0aW8nLCBudWxsLCAvaW1hZ2UvLFxuICAgICAgdGhpcy5pbWFnZURpbWVuc2lvbnMsIGZ1bmN0aW9uIChkLCB2YWwpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdmFsLnRvU3RyaW5nKCkuc3BsaXQoJywnKSwgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChNYXRoLmFicygoZC53aWR0aCAvIGQuaGVpZ2h0KSAtIHVwbG9hZC5yYXRpb1RvRmxvYXQoc3BsaXRbaV0pKSA8IDAuMDEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWF4UmF0aW8nLCAncmF0aW8ubWF4JywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiAoZC53aWR0aCAvIGQuaGVpZ2h0KSAtIHVwbG9hZC5yYXRpb1RvRmxvYXQodmFsKSA8IDAuMDAwMTtcbiAgICAgIH0pKTtcbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ21pblJhdGlvJywgJ3JhdGlvLm1pbicsIC9pbWFnZS8sXG4gICAgICB0aGlzLmltYWdlRGltZW5zaW9ucywgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICByZXR1cm4gKGQud2lkdGggLyBkLmhlaWdodCkgLSB1cGxvYWQucmF0aW9Ub0Zsb2F0KHZhbCkgPiAtMC4wMDAxO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWF4RHVyYXRpb24nLCAnZHVyYXRpb24ubWF4JywgL2F1ZGlvfHZpZGVvLyxcbiAgICAgIHRoaXMubWVkaWFEdXJhdGlvbiwgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICByZXR1cm4gZCA8PSB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyh2YWwpO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWluRHVyYXRpb24nLCAnZHVyYXRpb24ubWluJywgL2F1ZGlvfHZpZGVvLyxcbiAgICAgIHRoaXMubWVkaWFEdXJhdGlvbiwgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICByZXR1cm4gZCA+PSB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyh2YWwpO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnZHVyYXRpb24nLCBudWxsLCAvYXVkaW98dmlkZW8vLFxuICAgICAgZnVuY3Rpb24gKGZpbGUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZSh2YWwpO1xuICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KSk7XG5cbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ3ZhbGlkYXRlQXN5bmNGbicsIG51bGwsIG51bGwsXG4gICAgICBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gciA9PT0gdHJ1ZSB8fCByID09PSBudWxsIHx8IHIgPT09ICcnO1xuICAgICAgfSkpO1xuXG4gICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKHJ1bkFsbFZhbGlkYXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgICAgaWYgKGZpbGUuJGVycm9yKSB7XG4gICAgICAgICAgICBmaWxlcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcnVuQWxsVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgdmFsaWRhdGVTeW5jKCdtYXhGaWxlcycsIG51bGwsIGZ1bmN0aW9uIChmaWxlLCB2YWwsIGkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZMZW5ndGggKyBpIDwgdmFsO1xuICAgICAgfSk7XG5cbiAgICAgIGRlZmZlci5yZXNvbHZlKHsndmFsaWRGaWxlcyc6IGZpbGVzLCAnaW52YWxpZEZpbGVzJzogaW52YWxpZEZpbGVzfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmZlci5wcm9taXNlO1xuICB9O1xuXG4gIHVwbG9hZC5pbWFnZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIGlmIChmaWxlLiRuZ2ZXaWR0aCAmJiBmaWxlLiRuZ2ZIZWlnaHQpIHtcbiAgICAgIHZhciBkID0gJHEuZGVmZXIoKTtcbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5yZXNvbHZlKHt3aWR0aDogZmlsZS4kbmdmV2lkdGgsIGhlaWdodDogZmlsZS4kbmdmSGVpZ2h0fSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkLnByb21pc2U7XG4gICAgfVxuICAgIGlmIChmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlKSByZXR1cm4gZmlsZS4kbmdmRGltZW5zaW9uUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZScpICE9PSAwKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgnbm90IGltYWdlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwbG9hZC5kYXRhVXJsKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGRhdGFVcmwpIHtcbiAgICAgICAgdmFyIGltZyA9IGFuZ3VsYXIuZWxlbWVudCgnPGltZz4nKS5hdHRyKCdzcmMnLCBkYXRhVXJsKVxuICAgICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuY3NzKCdwb3NpdGlvbicsICdmaXhlZCcpXG4gICAgICAgICAgLmNzcygnbWF4LXdpZHRoJywgJ25vbmUgIWltcG9ydGFudCcpLmNzcygnbWF4LWhlaWdodCcsICdub25lICFpbXBvcnRhbnQnKTtcblxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgICAgICAgIHZhciB3aWR0aCA9IGltZ1swXS5uYXR1cmFsV2lkdGggfHwgaW1nWzBdLmNsaWVudFdpZHRoO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBpbWdbMF0ubmF0dXJhbEhlaWdodCB8fCBpbWdbMF0uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGltZy5yZW1vdmUoKTtcbiAgICAgICAgICBmaWxlLiRuZ2ZXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgIGZpbGUuJG5nZkhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICBpbWcucmVtb3ZlKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdsb2FkIGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbWcub24oJ2xvYWQnLCBzdWNjZXNzKTtcbiAgICAgICAgaW1nLm9uKCdlcnJvcicsIGVycm9yKTtcblxuICAgICAgICB2YXIgc2Vjb25kc0NvdW50ZXIgPSAwO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRFcnJvckluQ2FzZU9mTm9DYWxsYmFjaygpIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW1nWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGltZ1swXS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWNvbmRzQ291bnRlcisrID4gMTApIHtcbiAgICAgICAgICAgICAgICBlcnJvcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZEVycm9ySW5DYXNlT2ZOb0NhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrTG9hZEVycm9ySW5DYXNlT2ZOb0NhbGxiYWNrKCk7XG5cbiAgICAgICAgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0pLmFwcGVuZChpbWcpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ2xvYWQgZXJyb3InKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZmlsZS4kbmdmRGltZW5zaW9uUHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG4gICAgZmlsZS4kbmdmRGltZW5zaW9uUHJvbWlzZVsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSBmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlO1xuICB9O1xuXG4gIHVwbG9hZC5tZWRpYUR1cmF0aW9uID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBpZiAoZmlsZS4kbmdmRHVyYXRpb24pIHtcbiAgICAgIHZhciBkID0gJHEuZGVmZXIoKTtcbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5yZXNvbHZlKGZpbGUuJG5nZkR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZSkgcmV0dXJuIGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdhdWRpbycpICE9PSAwICYmIGZpbGUudHlwZS5pbmRleE9mKCd2aWRlbycpICE9PSAwKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgnbm90IG1lZGlhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwbG9hZC5kYXRhVXJsKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGRhdGFVcmwpIHtcbiAgICAgICAgdmFyIGVsID0gYW5ndWxhci5lbGVtZW50KGZpbGUudHlwZS5pbmRleE9mKCdhdWRpbycpID09PSAwID8gJzxhdWRpbz4nIDogJzx2aWRlbz4nKVxuICAgICAgICAgIC5hdHRyKCdzcmMnLCBkYXRhVXJsKS5jc3MoJ3Zpc2liaWxpdHknLCAnbm9uZScpLmNzcygncG9zaXRpb24nLCAnZml4ZWQnKTtcblxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGVsWzBdLmR1cmF0aW9uO1xuICAgICAgICAgIGZpbGUuJG5nZkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ2xvYWQgZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLm9uKCdsb2FkZWRtZXRhZGF0YScsIHN1Y2Nlc3MpO1xuICAgICAgICBlbC5vbignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkRXJyb3IoKSB7XG4gICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVsWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGVsWzBdLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgICBlcnJvcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZEVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrTG9hZEVycm9yKCk7XG5cbiAgICAgICAgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LmJvZHkpLmFwcGVuZChlbCk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgnbG9hZCBlcnJvcicpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmaWxlLiRuZ2ZEdXJhdGlvblByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlO1xuICAgIGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZVsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSBmaWxlLiRuZ2ZEdXJhdGlvblByb21pc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZTtcbiAgfTtcbiAgcmV0dXJuIHVwbG9hZDtcbn1cbl0pO1xuXG5uZ0ZpbGVVcGxvYWQuc2VydmljZSgnVXBsb2FkUmVzaXplJywgWydVcGxvYWRWYWxpZGF0ZScsICckcScsIGZ1bmN0aW9uIChVcGxvYWRWYWxpZGF0ZSwgJHEpIHtcbiAgdmFyIHVwbG9hZCA9IFVwbG9hZFZhbGlkYXRlO1xuXG4gIC8qKlxuICAgKiBDb25zZXJ2ZSBhc3BlY3QgcmF0aW8gb2YgdGhlIG9yaWdpbmFsIHJlZ2lvbi4gVXNlZnVsIHdoZW4gc2hyaW5raW5nL2VubGFyZ2luZ1xuICAgKiBpbWFnZXMgdG8gZml0IGludG8gYSBjZXJ0YWluIGFyZWEuXG4gICAqIFNvdXJjZTogIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0NzMxOTIyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNXaWR0aCBTb3VyY2UgYXJlYSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3JjSGVpZ2h0IFNvdXJjZSBhcmVhIGhlaWdodFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4V2lkdGggTmVzdGFibGUgYXJlYSBtYXhpbXVtIGF2YWlsYWJsZSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4SGVpZ2h0IE5lc3RhYmxlIGFyZWEgbWF4aW11bSBhdmFpbGFibGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge09iamVjdH0geyB3aWR0aCwgaGVpZ2h0IH1cbiAgICovXG4gIHZhciBjYWxjdWxhdGVBc3BlY3RSYXRpb0ZpdCA9IGZ1bmN0aW9uIChzcmNXaWR0aCwgc3JjSGVpZ2h0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBjZW50ZXJDcm9wKSB7XG4gICAgdmFyIHJhdGlvID0gY2VudGVyQ3JvcCA/IE1hdGgubWF4KG1heFdpZHRoIC8gc3JjV2lkdGgsIG1heEhlaWdodCAvIHNyY0hlaWdodCkgOlxuICAgICAgTWF0aC5taW4obWF4V2lkdGggLyBzcmNXaWR0aCwgbWF4SGVpZ2h0IC8gc3JjSGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHNyY1dpZHRoICogcmF0aW8sIGhlaWdodDogc3JjSGVpZ2h0ICogcmF0aW8sXG4gICAgICBtYXJnaW5YOiBzcmNXaWR0aCAqIHJhdGlvIC0gbWF4V2lkdGgsIG1hcmdpblk6IHNyY0hlaWdodCAqIHJhdGlvIC0gbWF4SGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICAvLyBFeHRyYWN0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcm9tZWxnb21lei9hbmd1bGFyLWZpcmViYXNlLWltYWdlLXVwbG9hZC9ibG9iL21hc3Rlci9hcHAvc2NyaXB0cy9maWxlVXBsb2FkLmpzI0w4OVxuICB2YXIgcmVzaXplID0gZnVuY3Rpb24gKGltYWdlbiwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSwgdHlwZSwgcmF0aW8sIGNlbnRlckNyb3AsIHJlc2l6ZUlmKSB7XG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWFnZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICd2aXNpYmlsaXR5OmhpZGRlbjtwb3NpdGlvbjpmaXhlZDt6LWluZGV4Oi0xMDAwMDAnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlRWxlbWVudCk7XG5cbiAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltZ1dpZHRoID0gaW1hZ2VFbGVtZW50LndpZHRoLCBpbWdIZWlnaHQgPSBpbWFnZUVsZW1lbnQuaGVpZ2h0O1xuICAgICAgaW1hZ2VFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2VFbGVtZW50KTtcbiAgICAgIGlmIChyZXNpemVJZiAhPSBudWxsICYmIHJlc2l6ZUlmKGltZ1dpZHRoLCBpbWdIZWlnaHQpID09PSBmYWxzZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ3Jlc2l6ZUlmJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyYXRpbykge1xuICAgICAgICAgIHZhciByYXRpb0Zsb2F0ID0gdXBsb2FkLnJhdGlvVG9GbG9hdChyYXRpbyk7XG4gICAgICAgICAgdmFyIGltZ1JhdGlvID0gaW1nV2lkdGggLyBpbWdIZWlnaHQ7XG4gICAgICAgICAgaWYgKGltZ1JhdGlvIDwgcmF0aW9GbG9hdCkge1xuICAgICAgICAgICAgd2lkdGggPSBpbWdXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW9GbG9hdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW1nSGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiByYXRpb0Zsb2F0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBpbWdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgIGhlaWdodCA9IGltZ0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNhbGN1bGF0ZUFzcGVjdFJhdGlvRml0KGltZ1dpZHRoLCBpbWdIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIGNlbnRlckNyb3ApO1xuICAgICAgICBjYW52YXNFbGVtZW50LndpZHRoID0gTWF0aC5taW4oZGltZW5zaW9ucy53aWR0aCwgd2lkdGgpO1xuICAgICAgICBjYW52YXNFbGVtZW50LmhlaWdodCA9IE1hdGgubWluKGRpbWVuc2lvbnMuaGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2VFbGVtZW50LFxuICAgICAgICAgIE1hdGgubWluKDAsIC1kaW1lbnNpb25zLm1hcmdpblggLyAyKSwgTWF0aC5taW4oMCwgLWRpbWVuc2lvbnMubWFyZ2luWSAvIDIpLFxuICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjYW52YXNFbGVtZW50LnRvRGF0YVVSTCh0eXBlIHx8ICdpbWFnZS9XZWJQJywgcXVhbGl0eSB8fCAwLjkzNCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGltYWdlRWxlbWVudCk7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICB9O1xuICAgIGltYWdlRWxlbWVudC5zcmMgPSBpbWFnZW47XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH07XG5cbiAgdXBsb2FkLmRhdGFVcmx0b0Jsb2IgPSBmdW5jdGlvbiAoZGF0YXVybCwgbmFtZSwgb3JpZ1NpemUpIHtcbiAgICB2YXIgYXJyID0gZGF0YXVybC5zcGxpdCgnLCcpLCBtaW1lID0gYXJyWzBdLm1hdGNoKC86KC4qPyk7LylbMV0sXG4gICAgICBic3RyID0gYXRvYihhcnJbMV0pLCBuID0gYnN0ci5sZW5ndGgsIHU4YXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgd2hpbGUgKG4tLSkge1xuICAgICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7XG4gICAgfVxuICAgIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFt1OGFycl0sIHt0eXBlOiBtaW1lfSk7XG4gICAgYmxvYi5uYW1lID0gbmFtZTtcbiAgICBibG9iLiRuZ2ZPcmlnU2l6ZSA9IG9yaWdTaXplO1xuICAgIHJldHVybiBibG9iO1xuICB9O1xuXG4gIHVwbG9hZC5pc1Jlc2l6ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHJldHVybiB3aW5kb3cuYXRvYiAmJiBlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpICYmIHdpbmRvdy5CbG9iO1xuICB9O1xuXG4gIGlmICh1cGxvYWQuaXNSZXNpemVTdXBwb3J0ZWQoKSkge1xuICAgIC8vIGFkZCBuYW1lIGdldHRlciB0byB0aGUgYmxvYiBjb25zdHJ1Y3RvciBwcm90b3R5cGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkJsb2IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbmdmTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMuJG5nZk5hbWUgPSB2O1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdXBsb2FkLnJlc2l6ZSA9IGZ1bmN0aW9uIChmaWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZScpICE9PSAwKSByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZShmaWxlKTtcblxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgdXBsb2FkLmRhdGFVcmwoZmlsZSwgdHJ1ZSkudGhlbihmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXNpemUodXJsLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5xdWFsaXR5LCBvcHRpb25zLnR5cGUgfHwgZmlsZS50eXBlLFxuICAgICAgICBvcHRpb25zLnJhdGlvLCBvcHRpb25zLmNlbnRlckNyb3AsIG9wdGlvbnMucmVzaXplSWYpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhVXJsKSB7XG4gICAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gJ2ltYWdlL2pwZWcnICYmIG9wdGlvbnMucmVzdG9yZUV4aWYgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkYXRhVXJsID0gdXBsb2FkLnJlc3RvcmVFeGlmKHVybCwgZGF0YVVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge3Rocm93IGU7fSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmxvYiA9IHVwbG9hZC5kYXRhVXJsdG9CbG9iKGRhdGFVcmwsIGZpbGUubmFtZSwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoYmxvYik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICBpZiAociA9PT0gJ3Jlc2l6ZUlmJykge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiB1cGxvYWQ7XG59XSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gIG5nRmlsZVVwbG9hZC5kaXJlY3RpdmUoJ25nZkRyb3AnLCBbJyRwYXJzZScsICckdGltZW91dCcsICckd2luZG93JywgJ1VwbG9hZCcsICckaHR0cCcsICckcScsXG4gICAgZnVuY3Rpb24gKCRwYXJzZSwgJHRpbWVvdXQsICR3aW5kb3csIFVwbG9hZCwgJGh0dHAsICRxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0FFQycsXG4gICAgICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0ciwgbmdNb2RlbCkge1xuICAgICAgICAgIGxpbmtEcm9wKHNjb3BlLCBlbGVtLCBhdHRyLCBuZ01vZGVsLCAkcGFyc2UsICR0aW1lb3V0LCAkd2luZG93LCBVcGxvYWQsICRodHRwLCAkcSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pO1xuXG4gIG5nRmlsZVVwbG9hZC5kaXJlY3RpdmUoJ25nZk5vRmlsZURyb3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbSkge1xuICAgICAgaWYgKGRyb3BBdmFpbGFibGUoKSkgZWxlbS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIH07XG4gIH0pO1xuXG4gIG5nRmlsZVVwbG9hZC5kaXJlY3RpdmUoJ25nZkRyb3BBdmFpbGFibGUnLCBbJyRwYXJzZScsICckdGltZW91dCcsICdVcGxvYWQnLCBmdW5jdGlvbiAoJHBhcnNlLCAkdGltZW91dCwgVXBsb2FkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0cikge1xuICAgICAgaWYgKGRyb3BBdmFpbGFibGUoKSkge1xuICAgICAgICB2YXIgbW9kZWwgPSAkcGFyc2UoVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZkRyb3BBdmFpbGFibGUnLCBhdHRyKSk7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtb2RlbChzY29wZSk7XG4gICAgICAgICAgaWYgKG1vZGVsLmFzc2lnbikge1xuICAgICAgICAgICAgbW9kZWwuYXNzaWduKHNjb3BlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICBmdW5jdGlvbiBsaW5rRHJvcChzY29wZSwgZWxlbSwgYXR0ciwgbmdNb2RlbCwgJHBhcnNlLCAkdGltZW91dCwgJHdpbmRvdywgdXBsb2FkLCAkaHR0cCwgJHEpIHtcbiAgICB2YXIgYXZhaWxhYmxlID0gZHJvcEF2YWlsYWJsZSgpO1xuXG4gICAgdmFyIGF0dHJHZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSwgc2NvcGUsIHBhcmFtcykge1xuICAgICAgcmV0dXJuIHVwbG9hZC5hdHRyR2V0dGVyKG5hbWUsIGF0dHIsIHNjb3BlLCBwYXJhbXMpO1xuICAgIH07XG5cbiAgICBpZiAoYXR0ckdldHRlcignZHJvcEF2YWlsYWJsZScpKSB7XG4gICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzY29wZVthdHRyR2V0dGVyKCdkcm9wQXZhaWxhYmxlJyldKSB7XG4gICAgICAgICAgc2NvcGVbYXR0ckdldHRlcignZHJvcEF2YWlsYWJsZScpXS52YWx1ZSA9IGF2YWlsYWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZVthdHRyR2V0dGVyKCdkcm9wQXZhaWxhYmxlJyldID0gYXZhaWxhYmxlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFhdmFpbGFibGUpIHtcbiAgICAgIGlmIChhdHRyR2V0dGVyKCduZ2ZIaWRlT25Ecm9wTm90QXZhaWxhYmxlJywgc2NvcGUpID09PSB0cnVlKSB7XG4gICAgICAgIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgcmV0dXJuIGVsZW0uYXR0cignZGlzYWJsZWQnKSB8fCBhdHRyR2V0dGVyKCduZ2ZEcm9wRGlzYWJsZWQnLCBzY29wZSk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJHZXR0ZXIoJ25nZlNlbGVjdCcpID09IG51bGwpIHtcbiAgICAgIHVwbG9hZC5yZWdpc3Rlck1vZGVsQ2hhbmdlVmFsaWRhdG9yKG5nTW9kZWwsIGF0dHIsIHNjb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgbGVhdmVUaW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gJHBhcnNlKGF0dHJHZXR0ZXIoJ25nZlN0b3BQcm9wYWdhdGlvbicpKTtcbiAgICB2YXIgZHJhZ092ZXJEZWxheSA9IDE7XG4gICAgdmFyIGFjdHVhbERyYWdPdmVyQ2xhc3M7XG5cbiAgICBlbGVtWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQoKSB8fCAhdXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdkcm9wJywgYXR0ciwgc2NvcGUpKSByZXR1cm47XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24oc2NvcGUpKSBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAvLyBoYW5kbGluZyBkcmFnb3ZlciBldmVudHMgZnJvbSB0aGUgQ2hyb21lIGRvd25sb2FkIGJhclxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuICAgICAgICB2YXIgYiA9IGV2dC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZDtcbiAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gKCdtb3ZlJyA9PT0gYiB8fCAnbGlua01vdmUnID09PSBiKSA/ICdtb3ZlJyA6ICdjb3B5JztcbiAgICAgIH1cbiAgICAgICR0aW1lb3V0LmNhbmNlbChsZWF2ZVRpbWVvdXQpO1xuICAgICAgaWYgKCFhY3R1YWxEcmFnT3ZlckNsYXNzKSB7XG4gICAgICAgIGFjdHVhbERyYWdPdmVyQ2xhc3MgPSAnQyc7XG4gICAgICAgIGNhbGN1bGF0ZURyYWdPdmVyQ2xhc3Moc2NvcGUsIGF0dHIsIGV2dCwgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgYWN0dWFsRHJhZ092ZXJDbGFzcyA9IGNsYXp6O1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoYWN0dWFsRHJhZ092ZXJDbGFzcyk7XG4gICAgICAgICAgYXR0ckdldHRlcignbmdmRHJhZycsIHNjb3BlLCB7JGlzRHJhZ2dpbmc6IHRydWUsICRjbGFzczogYWN0dWFsRHJhZ092ZXJDbGFzcywgJGV2ZW50OiBldnR9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsZW1bMF0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQoKSB8fCAhdXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdkcm9wJywgYXR0ciwgc2NvcGUpKSByZXR1cm47XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24oc2NvcGUpKSBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsZW1bMF0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQoKSB8fCAhdXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdkcm9wJywgYXR0ciwgc2NvcGUpKSByZXR1cm47XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24oc2NvcGUpKSBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBsZWF2ZVRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhY3R1YWxEcmFnT3ZlckNsYXNzKSBlbGVtLnJlbW92ZUNsYXNzKGFjdHVhbERyYWdPdmVyQ2xhc3MpO1xuICAgICAgICBhY3R1YWxEcmFnT3ZlckNsYXNzID0gbnVsbDtcbiAgICAgICAgYXR0ckdldHRlcignbmdmRHJhZycsIHNjb3BlLCB7JGlzRHJhZ2dpbmc6IGZhbHNlLCAkZXZlbnQ6IGV2dH0pO1xuICAgICAgfSwgZHJhZ092ZXJEZWxheSB8fCAxMDApO1xuICAgIH0sIGZhbHNlKTtcbiAgICBlbGVtWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoaXNEaXNhYmxlZCgpIHx8ICF1cGxvYWQuc2hvdWxkVXBkYXRlT24oJ2Ryb3AnLCBhdHRyLCBzY29wZSkpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbihzY29wZSkpIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChhY3R1YWxEcmFnT3ZlckNsYXNzKSBlbGVtLnJlbW92ZUNsYXNzKGFjdHVhbERyYWdPdmVyQ2xhc3MpO1xuICAgICAgYWN0dWFsRHJhZ092ZXJDbGFzcyA9IG51bGw7XG4gICAgICBleHRyYWN0RmlsZXNBbmRVcGRhdGVNb2RlbChldnQuZGF0YVRyYW5zZmVyLCBldnQsICdkcm9wVXJsJyk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsZW1bMF0uYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xICYmXG4gICAgICAgIGF0dHJHZXR0ZXIoJ25nZkVuYWJsZUZpcmVmb3hQYXN0ZScsIHNjb3BlKSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Rpc2FibGVkKCkgfHwgIXVwbG9hZC5zaG91bGRVcGRhdGVPbigncGFzdGUnLCBhdHRyLCBzY29wZSkpIHJldHVybjtcbiAgICAgIGV4dHJhY3RGaWxlc0FuZFVwZGF0ZU1vZGVsKGV2dC5jbGlwYm9hcmREYXRhIHx8IGV2dC5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEsIGV2dCwgJ3Bhc3RlVXJsJyk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMSAmJlxuICAgICAgYXR0ckdldHRlcignbmdmRW5hYmxlRmlyZWZveFBhc3RlJywgc2NvcGUpKSB7XG4gICAgICBlbGVtLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuICAgICAgZWxlbS5vbigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RmlsZXNBbmRVcGRhdGVNb2RlbChzb3VyY2UsIGV2dCwgdXBkYXRlT25UeXBlKSB7XG4gICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuICAgICAgLy8gaHRtbCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIG9uIHRoZSBzYW1lIHByb2Nlc3Mgb3RoZXJ3aXNlIHRoZSBkYXRhIHdpbGwgYmUgd2lwZWRcbiAgICAgIC8vIGFmdGVyIHByb21pc2UgcmVzb2x2ZSBvciBzZXRUaW1lb3V0LlxuICAgICAgdmFyIGh0bWw7XG4gICAgICB0cnkge1xuICAgICAgICBodG1sID0gc291cmNlICYmIHNvdXJjZS5nZXREYXRhICYmIHNvdXJjZS5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsvKiBGaXggSUUxMSB0aGF0IHRocm93IGVycm9yIGNhbGxpbmcgZ2V0RGF0YSAqL1xuICAgICAgfVxuICAgICAgZXh0cmFjdEZpbGVzKHNvdXJjZS5pdGVtcywgc291cmNlLmZpbGVzLCBhdHRyR2V0dGVyKCduZ2ZBbGxvd0RpcicsIHNjb3BlKSAhPT0gZmFsc2UsXG4gICAgICAgIGF0dHJHZXR0ZXIoJ211bHRpcGxlJykgfHwgYXR0ckdldHRlcignbmdmTXVsdGlwbGUnLCBzY29wZSkpLnRoZW4oZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICB1cGRhdGVNb2RlbChmaWxlcywgZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYWN0RmlsZXNGcm9tSHRtbCh1cGRhdGVPblR5cGUsIGh0bWwpLnRoZW4oZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICB1cGRhdGVNb2RlbChmaWxlcywgZXZ0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoZmlsZXMsIGV2dCkge1xuICAgICAgdXBsb2FkLnVwZGF0ZU1vZGVsKG5nTW9kZWwsIGF0dHIsIHNjb3BlLCBhdHRyR2V0dGVyKCduZ2ZDaGFuZ2UnKSB8fCBhdHRyR2V0dGVyKCduZ2ZEcm9wJyksIGZpbGVzLCBldnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGaWxlc0Zyb21IdG1sKHVwZGF0ZU9uLCBodG1sKSB7XG4gICAgICBpZiAoIXVwbG9hZC5zaG91bGRVcGRhdGVPbih1cGRhdGVPbiwgYXR0ciwgc2NvcGUpIHx8IHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykgcmV0dXJuIHVwbG9hZC5yZWplY3RQcm9taXNlKFtdKTtcbiAgICAgIHZhciB1cmxzID0gW107XG4gICAgICBodG1sLnJlcGxhY2UoLzwoaW1nIHNyY3xpbWcgW14+XSogc3JjKSAqPVxcXCIoW15cXFwiXSopXFxcIi9naSwgZnVuY3Rpb24gKG0sIG4sIHNyYykge1xuICAgICAgICB1cmxzLnB1c2goc3JjKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb21pc2VzID0gW10sIGZpbGVzID0gW107XG4gICAgICBpZiAodXJscy5sZW5ndGgpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVybHMsIGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHVwbG9hZC51cmxUb0Jsb2IodXJsKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGJsb2IpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZShmaWxlcyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZURyYWdPdmVyQ2xhc3Moc2NvcGUsIGF0dHIsIGV2dCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBvYmogPSBhdHRyR2V0dGVyKCduZ2ZEcmFnT3ZlckNsYXNzJywgc2NvcGUsIHskZXZlbnQ6IGV2dH0pLCBkQ2xhc3MgPSAnZHJhZ292ZXInO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcob2JqKSkge1xuICAgICAgICBkQ2xhc3MgPSBvYmo7XG4gICAgICB9IGVsc2UgaWYgKG9iaikge1xuICAgICAgICBpZiAob2JqLmRlbGF5KSBkcmFnT3ZlckRlbGF5ID0gb2JqLmRlbGF5O1xuICAgICAgICBpZiAob2JqLmFjY2VwdCB8fCBvYmoucmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gZXZ0LmRhdGFUcmFuc2Zlci5pdGVtcztcbiAgICAgICAgICBpZiAoaXRlbXMgPT0gbnVsbCB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkQ2xhc3MgPSBvYmouYWNjZXB0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IG9iai5wYXR0ZXJuIHx8IGF0dHJHZXR0ZXIoJ25nZlBhdHRlcm4nLCBzY29wZSwgeyRldmVudDogZXZ0fSk7XG4gICAgICAgICAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICAgIGlmICghdXBsb2FkLnZhbGlkYXRlUGF0dGVybihpdGVtc1tsZW5dLCBwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGRDbGFzcyA9IG9iai5yZWplY3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZENsYXNzID0gb2JqLmFjY2VwdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soZENsYXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RmlsZXMoaXRlbXMsIGZpbGVMaXN0LCBhbGxvd0RpciwgbXVsdGlwbGUpIHtcbiAgICAgIHZhciBtYXhGaWxlcyA9IHVwbG9hZC5nZXRWYWxpZGF0aW9uQXR0cihhdHRyLCBzY29wZSwgJ21heEZpbGVzJyk7XG4gICAgICBpZiAobWF4RmlsZXMgPT0gbnVsbCkge1xuICAgICAgICBtYXhGaWxlcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB9XG4gICAgICB2YXIgbWF4VG90YWxTaXplID0gdXBsb2FkLmdldFZhbGlkYXRpb25BdHRyKGF0dHIsIHNjb3BlLCAnbWF4VG90YWxTaXplJyk7XG4gICAgICBpZiAobWF4VG90YWxTaXplID09IG51bGwpIHtcbiAgICAgICAgbWF4VG90YWxTaXplID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmNsdWRlRGlyID0gYXR0ckdldHRlcignbmdmSW5jbHVkZURpcicsIHNjb3BlKTtcbiAgICAgIHZhciBmaWxlcyA9IFtdLCB0b3RhbFNpemUgPSAwO1xuXG4gICAgICBmdW5jdGlvbiB0cmF2ZXJzZUZpbGVUcmVlKGVudHJ5LCBwYXRoKSB7XG4gICAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbdXBsb2FkLmVtcHR5UHJvbWlzZSgpXTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlRGlyKSB7XG4gICAgICAgICAgICAgIHZhciBmaWxlID0ge3R5cGU6ICdkaXJlY3RvcnknfTtcbiAgICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZS5wYXRoID0gKHBhdGggfHwgJycpICsgZW50cnkubmFtZTtcbiAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaXJSZWFkZXIgPSBlbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgICB2YXIgcmVhZEVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLnNsaWNlKDApLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPD0gbWF4RmlsZXMgJiYgdG90YWxTaXplIDw9IG1heFRvdGFsU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmF2ZXJzZUZpbGVUcmVlKGUsIChwYXRoID8gcGF0aCA6ICcnKSArIGVudHJ5Lm5hbWUgKyAnLycpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcyA9IGVudHJpZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHJlc3VsdHMgfHwgW10sIDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbGUucGF0aCA9IChwYXRoID8gcGF0aCA6ICcnKSArIGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZURpcikge1xuICAgICAgICAgICAgICAgICAgZmlsZSA9IHVwbG9hZC5yZW5hbWUoZmlsZSwgZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gZmlsZS5zaXplO1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZXMgPSBbdXBsb2FkLmVtcHR5UHJvbWlzZSgpXTtcblxuICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDAgJiYgJHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkgJiYgaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSgpICYmIGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkoKS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5ICYmICFhbGxvd0Rpcikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2godHJhdmVyc2VGaWxlVHJlZShlbnRyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IGl0ZW1zW2ldLmdldEFzRmlsZSgpO1xuICAgICAgICAgICAgaWYgKGYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmaWxlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gZi5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID4gbWF4RmlsZXMgfHwgdG90YWxTaXplID4gbWF4VG90YWxTaXplIHx8XG4gICAgICAgICAgICAoIW11bHRpcGxlICYmIGZpbGVzLmxlbmd0aCA+IDApKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbGVMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbGVMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVMaXN0Lml0ZW0oaik7XG4gICAgICAgICAgICBpZiAoZmlsZS50eXBlIHx8IGZpbGUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgdG90YWxTaXplICs9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiBtYXhGaWxlcyB8fCB0b3RhbFNpemUgPiBtYXhUb3RhbFNpemUgfHxcbiAgICAgICAgICAgICAgKCFtdWx0aXBsZSAmJiBmaWxlcy5sZW5ndGggPiAwKSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW11bHRpcGxlICYmICFpbmNsdWRlRGlyICYmIGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoZmlsZXNbaV0gJiYgZmlsZXNbaV0udHlwZSA9PT0gJ2RpcmVjdG9yeScpIGkrKztcbiAgICAgICAgICBkZWZlci5yZXNvbHZlKFtmaWxlc1tpXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVyLnJlc29sdmUoZmlsZXMpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJvcEF2YWlsYWJsZSgpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuICgnZHJhZ2dhYmxlJyBpbiBkaXYpICYmICgnb25kcm9wJyBpbiBkaXYpICYmICEvRWRnZVxcLzEyLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxufSkoKTtcblxuLy8gY3VzdG9taXplZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcbm5nRmlsZVVwbG9hZC5zZXJ2aWNlKCdVcGxvYWRFeGlmJywgWydVcGxvYWRSZXNpemUnLCAnJHEnLCBmdW5jdGlvbiAoVXBsb2FkUmVzaXplLCAkcSkge1xuICB2YXIgdXBsb2FkID0gVXBsb2FkUmVzaXplO1xuXG4gIHVwbG9hZC5pc0V4aWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5GaWxlUmVhZGVyICYmIG5ldyBGaWxlUmVhZGVyKCkucmVhZEFzQXJyYXlCdWZmZXIgJiYgdXBsb2FkLmlzUmVzaXplU3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oY3R4LCBvcmllbnRhdGlvbiwgd2lkdGgsIGhlaWdodCkge1xuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oLTEsIDAsIDAsIDEsIHdpZHRoLCAwKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oLTEsIDAsIDAsIC0xLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIGhlaWdodCk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBjdHgudHJhbnNmb3JtKDAsIDEsIDEsIDAsIDAsIDApO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgwLCAxLCAtMSwgMCwgaGVpZ2h0LCAwKTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oMCwgLTEsIC0xLCAwLCBoZWlnaHQsIHdpZHRoKTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oMCwgLTEsIDEsIDAsIDAsIHdpZHRoKTtcbiAgICB9XG4gIH1cblxuICB1cGxvYWQucmVhZE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICB2YXIgZGVmZXIgPSAkcS5kZWZlcigpO1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBzbGljZWRGaWxlID0gZmlsZS5zbGljZSA/IGZpbGUuc2xpY2UoMCwgNjQgKiAxMDI0KSA6IGZpbGU7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHNsaWNlZEZpbGUpO1xuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBkZWZlci5yZWplY3QoZSk7XG4gICAgfTtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7b3JpZW50YXRpb246IDF9O1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5yZXN1bHQpO1xuICAgICAgaWYgKHZpZXcuZ2V0VWludDE2KDAsIGZhbHNlKSAhPT0gMHhGRkQ4KSByZXR1cm4gZGVmZXIucmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gdmlldy5ieXRlTGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSAyO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWFya2VyID0gdmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEZGRTEpIHtcbiAgICAgICAgICBpZiAodmlldy5nZXRVaW50MzIob2Zmc2V0ICs9IDIsIGZhbHNlKSAhPT0gMHg0NTc4Njk2NikgcmV0dXJuIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcblxuICAgICAgICAgIHZhciBsaXR0bGUgPSB2aWV3LmdldFVpbnQxNihvZmZzZXQgKz0gNiwgZmFsc2UpID09PSAweDQ5NDk7XG4gICAgICAgICAgb2Zmc2V0ICs9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQsIGxpdHRsZSk7XG4gICAgICAgICAgdmFyIHRhZ3MgPSB2aWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzOyBpKyspXG4gICAgICAgICAgICBpZiAodmlldy5nZXRVaW50MTYob2Zmc2V0ICsgKGkgKiAxMiksIGxpdHRsZSkgPT09IDB4MDExMikge1xuICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSB2aWV3LmdldFVpbnQxNihvZmZzZXQgKyAoaSAqIDEyKSArIDgsIGxpdHRsZSk7XG4gICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA+PSAyICYmIG9yaWVudGF0aW9uIDw9IDgpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAoaSAqIDEyKSArIDgsIDEsIGxpdHRsZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpeGVkQXJyYXlCdWZmZXIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0Lm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICAgICAgICAgIHJldHVybiBkZWZlci5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hcmtlciAmIDB4RkYwMCkgIT09IDB4RkYwMCkgYnJlYWs7XG4gICAgICAgIGVsc2Ugb2Zmc2V0ICs9IHZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyKSB7XG4gICAgdmFyIGJpbmFyeSA9ICcnO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbiAgfVxuXG4gIHVwbG9hZC5hcHBseUV4aWZSb3RhdGlvbiA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZS9qcGVnJykgIT09IDApIHtcbiAgICAgIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKGZpbGUpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgdXBsb2FkLnJlYWRPcmllbnRhdGlvbihmaWxlKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHQub3JpZW50YXRpb24gPCAyIHx8IHJlc3VsdC5vcmllbnRhdGlvbiA+IDgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoZmlsZSk7XG4gICAgICB9XG4gICAgICB1cGxvYWQuZGF0YVVybChmaWxlLCB0cnVlKS50aGVuKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmVzdWx0Lm9yaWVudGF0aW9uID4gNCA/IGltZy5oZWlnaHQgOiBpbWcud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzdWx0Lm9yaWVudGF0aW9uID4gNCA/IGltZy53aWR0aCA6IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShjdHgsIHJlc3VsdC5vcmllbnRhdGlvbiwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTChmaWxlLnR5cGUgfHwgJ2ltYWdlL1dlYlAnLCAwLjkzNCk7XG4gICAgICAgICAgICBkYXRhVXJsID0gdXBsb2FkLnJlc3RvcmVFeGlmKGFycmF5QnVmZmVyVG9CYXNlNjQocmVzdWx0LmZpeGVkQXJyYXlCdWZmZXIpLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIHZhciBibG9iID0gdXBsb2FkLmRhdGFVcmx0b0Jsb2IoZGF0YVVybCwgZmlsZS5uYW1lKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoYmxvYik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcblxuICB1cGxvYWQucmVzdG9yZUV4aWYgPSBmdW5jdGlvbiAob3JpZywgcmVzaXplZCkge1xuICAgIHZhciBFeGlmUmVzdG9yZXIgPSB7fTtcblxuICAgIEV4aWZSZXN0b3Jlci5LRVlfU1RSID0gJ0FCQ0RFRkdISUpLTE1OT1AnICtcbiAgICAgICdRUlNUVVZXWFlaYWJjZGVmJyArXG4gICAgICAnZ2hpamtsbW5vcHFyc3R1dicgK1xuICAgICAgJ3d4eXowMTIzNDU2Nzg5Ky8nICtcbiAgICAgICc9JztcblxuICAgIEV4aWZSZXN0b3Jlci5lbmNvZGU2NCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICBjaHIxLCBjaHIyLCBjaHIzID0gJycsXG4gICAgICAgIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQgPSAnJyxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgICAgICBjaHIzID0gaW5wdXRbaSsrXTtcblxuICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcbiAgICAgICAgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuXG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgK1xuICAgICAgICAgIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMSkgK1xuICAgICAgICAgIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMikgK1xuICAgICAgICAgIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMykgK1xuICAgICAgICAgIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jNCk7XG4gICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XG4gICAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgRXhpZlJlc3RvcmVyLnJlc3RvcmUgPSBmdW5jdGlvbiAob3JpZ0ZpbGVCYXNlNjQsIHJlc2l6ZWRGaWxlQmFzZTY0KSB7XG4gICAgICBpZiAob3JpZ0ZpbGVCYXNlNjQubWF0Y2goJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJykpIHtcbiAgICAgICAgb3JpZ0ZpbGVCYXNlNjQgPSBvcmlnRmlsZUJhc2U2NC5yZXBsYWNlKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcsICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhd0ltYWdlID0gdGhpcy5kZWNvZGU2NChvcmlnRmlsZUJhc2U2NCk7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlKTtcblxuICAgICAgdmFyIGltYWdlID0gdGhpcy5leGlmTWFuaXB1bGF0aW9uKHJlc2l6ZWRGaWxlQmFzZTY0LCBzZWdtZW50cyk7XG5cbiAgICAgIHJldHVybiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnICsgdGhpcy5lbmNvZGU2NChpbWFnZSk7XG4gICAgfTtcblxuXG4gICAgRXhpZlJlc3RvcmVyLmV4aWZNYW5pcHVsYXRpb24gPSBmdW5jdGlvbiAocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKSB7XG4gICAgICB2YXIgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpLFxuICAgICAgICBuZXdJbWFnZUFycmF5ID0gdGhpcy5pbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ld0ltYWdlQXJyYXkpO1xuICAgIH07XG5cblxuICAgIEV4aWZSZXN0b3Jlci5nZXRFeGlmQXJyYXkgPSBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgIHZhciBzZWc7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNlZ21lbnRzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIHNlZyA9IHNlZ21lbnRzW3hdO1xuICAgICAgICBpZiAoc2VnWzBdID09PSAyNTUgJiBzZWdbMV0gPT09IDIyNSkgLy8oZmYgZTEpXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfTtcblxuXG4gICAgRXhpZlJlc3RvcmVyLmluc2VydEV4aWYgPSBmdW5jdGlvbiAocmVzaXplZEZpbGVCYXNlNjQsIGV4aWZBcnJheSkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlc2l6ZWRGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpLFxuICAgICAgICBidWYgPSB0aGlzLmRlY29kZTY0KGltYWdlRGF0YSksXG4gICAgICAgIHNlcGFyYXRlUG9pbnQgPSBidWYuaW5kZXhPZigyNTUsIDMpLFxuICAgICAgICBtYWUgPSBidWYuc2xpY2UoMCwgc2VwYXJhdGVQb2ludCksXG4gICAgICAgIGF0byA9IGJ1Zi5zbGljZShzZXBhcmF0ZVBvaW50KSxcbiAgICAgICAgYXJyYXkgPSBtYWU7XG5cbiAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGV4aWZBcnJheSk7XG4gICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChhdG8pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5cblxuICAgIEV4aWZSZXN0b3Jlci5zbGljZTJTZWdtZW50cyA9IGZ1bmN0aW9uIChyYXdJbWFnZUFycmF5KSB7XG4gICAgICB2YXIgaGVhZCA9IDAsXG4gICAgICAgIHNlZ21lbnRzID0gW107XG5cbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PT0gMjE4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTYpIHtcbiAgICAgICAgICBoZWFkICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHJhd0ltYWdlQXJyYXlbaGVhZCArIDJdICogMjU2ICsgcmF3SW1hZ2VBcnJheVtoZWFkICsgM10sXG4gICAgICAgICAgICBlbmRQb2ludCA9IGhlYWQgKyBsZW5ndGggKyAyLFxuICAgICAgICAgICAgc2VnID0gcmF3SW1hZ2VBcnJheS5zbGljZShoZWFkLCBlbmRQb2ludCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChzZWcpO1xuICAgICAgICAgIGhlYWQgPSBlbmRQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZCA+IHJhd0ltYWdlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH07XG5cblxuICAgIEV4aWZSZXN0b3Jlci5kZWNvZGU2NCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIGNocjEsIGNocjIsIGNocjMgPSAnJyxcbiAgICAgICAgZW5jMSwgZW5jMiwgZW5jMywgZW5jNCA9ICcnLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgYnVmID0gW107XG5cbiAgICAgIC8vIHJlbW92ZSBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQS1aLCBhLXosIDAtOSwgKywgLywgb3IgPVxuICAgICAgdmFyIGJhc2U2NHRlc3QgPSAvW15BLVphLXowLTlcXCtcXC9cXD1dL2c7XG4gICAgICBpZiAoYmFzZTY0dGVzdC5leGVjKGlucHV0KSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LlxcbicgK1xuICAgICAgICAgICdWYWxpZCBiYXNlNjQgY2hhcmFjdGVycyBhcmUgQS1aLCBhLXosIDAtOSwgJyArICcsICcgLyAnLGFuZCBcIj1cIlxcbicgK1xuICAgICAgICAgICdFeHBlY3QgZXJyb3JzIGluIGRlY29kaW5nLicpO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGVuYzEgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBidWYucHVzaChjaHIxKTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICBidWYucHVzaChjaHIyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICBidWYucHVzaChjaHIzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XG5cbiAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXhpZlJlc3RvcmVyLnJlc3RvcmUob3JpZywgcmVzaXplZCk7ICAvLzw9IEVYSUZcbiAgfTtcblxuICByZXR1cm4gdXBsb2FkO1xufV0pO1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ng-file-upload/dist/ng-file-upload-all.js\n");

/***/ }),

/***/ "./node_modules/ng-file-upload/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ng-file-upload/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./dist/ng-file-upload-all */ \"./node_modules/ng-file-upload/dist/ng-file-upload-all.js\");\nmodule.exports = 'ngFileUpload';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmctZmlsZS11cGxvYWQvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZmlsZS11cGxvYWQvaW5kZXguanM/MzhmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2Rpc3QvbmctZmlsZS11cGxvYWQtYWxsJyk7XG5tb2R1bGUuZXhwb3J0cyA9ICduZ0ZpbGVVcGxvYWQnOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ng-file-upload/index.js\n");

/***/ })

}]);