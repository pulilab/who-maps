(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[597],{

/***/ "./node_modules/@uirouter/core/lib/common/common.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/common.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar predicates_1 = __webpack_require__(/*! ./predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar hof_1 = __webpack_require__(/*! ./hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar coreservices_1 = __webpack_require__(/*! ./coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = Object.assign || _extend;\nexports.equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nexports.identity = identity;\nfunction noop() { }\nexports.noop = noop;\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(Object.create(parent), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = exports.extend.apply(null, _defaultsList);\n    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\nexports.defaults = defaults;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var prop_1 in obj) {\n        if (propNames.indexOf(prop_1) !== -1) {\n            objCopy[prop_1] = obj[prop_1];\n        }\n    }\n    return objCopy;\n}\nexports.pick = pick;\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, ['a', 'b']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(hof_1.not(exports.inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 âˆ’ 1 aka Number.MAX_SAFE_INTEGER\n    var i, result = [];\n    for (i = 0; i < maxArrayLen; i++) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    }\n    return result;\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nexports._extend = _extend;\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function composedSort(a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanM/OWRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmFuZG9tIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIFVJLVJvdXRlciBjb2RlXG4gKlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIGNvbW1vblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4vaG9mXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4vY29yZXNlcnZpY2VzXCIpO1xudmFyIHcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogd2luZG93O1xudmFyIGFuZ3VsYXIgPSB3LmFuZ3VsYXIgfHwge307XG5leHBvcnRzLmZyb21Kc29uID0gYW5ndWxhci5mcm9tSnNvbiB8fCBKU09OLnBhcnNlLmJpbmQoSlNPTik7XG5leHBvcnRzLnRvSnNvbiA9IGFuZ3VsYXIudG9Kc29uIHx8IEpTT04uc3RyaW5naWZ5LmJpbmQoSlNPTik7XG5leHBvcnRzLmNvcHkgPSBhbmd1bGFyLmNvcHkgfHwgX2NvcHk7XG5leHBvcnRzLmZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2ggfHwgX2ZvckVhY2g7XG5leHBvcnRzLmV4dGVuZCA9IE9iamVjdC5hc3NpZ24gfHwgX2V4dGVuZDtcbmV4cG9ydHMuZXF1YWxzID0gYW5ndWxhci5lcXVhbHMgfHwgX2VxdWFscztcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHsgcmV0dXJuIHg7IH1cbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4vKipcbiAqIEJ1aWxkcyBwcm94eSBmdW5jdGlvbnMgb24gdGhlIGB0b2Agb2JqZWN0IHdoaWNoIHBhc3MgdGhyb3VnaCB0byB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKiBGb3IgZWFjaCBrZXkgaW4gYGZuTmFtZXNgLCBjcmVhdGVzIGEgcHJveHkgZnVuY3Rpb24gb24gdGhlIGB0b2Agb2JqZWN0LlxuICogVGhlIHByb3h5IGZ1bmN0aW9uIGNhbGxzIHRoZSByZWFsIGZ1bmN0aW9uIG9uIHRoZSBgZnJvbWAgb2JqZWN0LlxuICpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhbiBuZXcgY2xhc3MgaW5zdGFuY2Ugd2hvc2UgZnVuY3Rpb25zIGFyZSBwcmVib3VuZCB0byB0aGUgbmV3J2Qgb2JqZWN0LlxuICogYGBganNcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAqICAgICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gRm9vLnByb3RvdHlwZSB0byAndGhpcycsXG4gKiAgICAgLy8gdGhlbiBjb3BpZXMgdGhlbSB0byAndGhpcydcbiAqICAgICBiaW5kRnVuY3Rpb25zKEZvby5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xuICogICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gKiAgIH1cbiAqXG4gKiAgIGxvZygpIHtcbiAqICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuICogICB9XG4gKiB9XG4gKlxuICogbGV0IG15Rm9vID0gbmV3IEZvbyhbMSwyLDNdKTtcbiAqIHZhciBsb2dpdCA9IG15Rm9vLmxvZztcbiAqIGxvZ2l0KCk7IC8vIGxvZ3MgWzEsIDIsIDNdIGZyb20gdGhlIG15Rm9vICd0aGlzJyBpbnN0YW5jZVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBib3VuZCB2ZXJzaW9uIG9mIGEgc2VydmljZSBmdW5jdGlvbiwgYW5kIGNvcGllcyBpdCB0byBhbm90aGVyIG9iamVjdFxuICogYGBgXG4gKlxuICogdmFyIFNvbWVTZXJ2aWNlID0ge1xuICogICB0aGlzLmRhdGEgPSBbMywgNCwgNV07XG4gKiAgIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIENvbnN0cnVjdG9yIGZuXG4gKiBmdW5jdGlvbiBPdGhlclRoaW5nKCkge1xuICogICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gU29tZVNlcnZpY2UgdG8gU29tZVNlcnZpY2UsXG4gKiAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgIGJpbmRGdW5jdGlvbnMoU29tZVNlcnZpY2UsIHRoaXMsIFNvbWVTZXJ2aWNlKTtcbiAqIH1cbiAqXG4gKiBsZXQgbXlPdGhlclRoaW5nID0gbmV3IE90aGVyVGhpbmcoKTtcbiAqIG15T3RoZXJUaGluZy5sb2coKTsgLy8gbG9ncyBbMywgNCwgNV0gZnJvbSBTb21lU2VydmljZSdzICd0aGlzJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNvdXJjZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc291cmNlIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25zIHRvIGJlIGJvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgYm91bmQgZnVuY3Rpb25zXG4gKiBAcGFyYW0gYmluZCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb2JqZWN0IHdoaWNoIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBib3VuZCB0b1xuICogQHBhcmFtIGZuTmFtZXMgVGhlIGZ1bmN0aW9uIG5hbWVzIHdoaWNoIHdpbGwgYmUgYm91bmQgKERlZmF1bHRzIHRvIGFsbCB0aGUgZnVuY3Rpb25zIGZvdW5kIG9uIHRoZSAnZnJvbScgb2JqZWN0KVxuICogQHBhcmFtIGxhdGViaW5kIElmIHRydWUsIHRoZSBiaW5kaW5nIG9mIHRoZSBmdW5jdGlvbiBpcyBkZWxheWVkIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgaW52b2tlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm94eUZ1bmN0aW9ucyhzb3VyY2UsIHRhcmdldCwgYmluZCwgZm5OYW1lcywgbGF0ZWJpbmQpIHtcbiAgICBpZiAobGF0ZWJpbmQgPT09IHZvaWQgMCkgeyBsYXRlYmluZCA9IGZhbHNlOyB9XG4gICAgdmFyIGJpbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZSgpW2ZuTmFtZV0uYmluZChiaW5kKCkpO1xuICAgIH07XG4gICAgdmFyIG1ha2VMYXRlUmViaW5kRm4gPSBmdW5jdGlvbiAoZm5OYW1lKSB7IHJldHVybiBmdW5jdGlvbiBsYXRlUmViaW5kRnVuY3Rpb24oKSB7XG4gICAgICAgIHRhcmdldFtmbk5hbWVdID0gYmluZEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRbZm5OYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07IH07XG4gICAgZm5OYW1lcyA9IGZuTmFtZXMgfHwgT2JqZWN0LmtleXMoc291cmNlKCkpO1xuICAgIHJldHVybiBmbk5hbWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgICAgIGFjY1tuYW1lXSA9IGxhdGViaW5kID8gbWFrZUxhdGVSZWJpbmRGbihuYW1lKSA6IGJpbmRGdW5jdGlvbihuYW1lKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm94eUZ1bmN0aW9ucyA9IGNyZWF0ZVByb3h5RnVuY3Rpb25zO1xuLyoqXG4gKiBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGhlbHBlci5cbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoaWNoIGhhcyBgcGFyZW50YCBvYmplY3QgYXMgaXRzIHByb3RvdHlwZSwgYW5kIHRoZW4gY29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gYGV4dHJhYCBvbnRvIGl0XG4gKi9cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIGV4dHJhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKE9iamVjdC5jcmVhdGUocGFyZW50KSwgZXh0cmEpO1xufTtcbi8qKlxuICogR2l2ZW4gYW4gYXJndW1lbnRzIG9iamVjdCwgY29udmVydHMgdGhlIGFyZ3VtZW50cyBhdCBpbmRleCBpZHggYW5kIGFib3ZlIHRvIGFuIGFycmF5LlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGVzNiByZXN0IHBhcmFtZXRlcnMuXG4gKlxuICogT3B0aW9uYWxseSwgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGlkeCBtYXkgaXRzZWxmIGFscmVhZHkgYmUgYW4gYXJyYXkuXG4gKlxuICogRm9yIGV4YW1wbGUsXG4gKiBnaXZlbiBlaXRoZXI6XG4gKiAgICAgICAgYXJndW1lbnRzID0gWyBvYmosIFwiZm9vXCIsIFwiYmFyXCIgXVxuICogb3I6XG4gKiAgICAgICAgYXJndW1lbnRzID0gWyBvYmosIFtcImZvb1wiLCBcImJhclwiXSBdXG4gKiB0aGVuOlxuICogICAgICAgIHJlc3RBcmdzKGFyZ3VtZW50cywgMSkgPT0gW1wiZm9vXCIsIFwiYmFyXCJdXG4gKlxuICogVGhpcyBhbGxvd3MgZnVuY3Rpb25zIGxpa2UgcGljaygpIHRvIGJlIGltcGxlbWVudGVkIHN1Y2ggdGhhdCBpdCBhbGxvd3MgZWl0aGVyIGEgYnVuY2hcbiAqIG9mIHN0cmluZyBhcmd1bWVudHMgKGxpa2UgZXM2IHJlc3QgcGFyYW1ldGVycyksIG9yIGEgc2luZ2xlIGFycmF5IG9mIHN0cmluZ3M6XG4gKlxuICogZ2l2ZW46XG4gKiAgICAgICAgdmFyIG9iaiA9IHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9O1xuICogdGhlbjpcbiAqICAgICAgICBwaWNrKG9iaiwgXCJmb29cIiwgXCJiYXJcIik7ICAgLy8gcmV0dXJucyB7IGZvbzogMSwgYmFyOiAyIH1cbiAqICAgICAgICBwaWNrKG9iaiwgW1wiZm9vXCIsIFwiYmFyXCJdKTsgLy8gcmV0dXJucyB7IGZvbzogMSwgYmFyOiAyIH1cbiAqL1xudmFyIHJlc3RBcmdzID0gZnVuY3Rpb24gKGFyZ3MsIGlkeCkge1xuICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoQXJyYXkucHJvdG90eXBlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCBpZHgpKTtcbn07XG4vKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBhcnJheSwgKHVzaW5nIGluZGV4T2YpICovXG5leHBvcnRzLmluQXJyYXkgPSBob2ZfMS5jdXJyeShfaW5BcnJheSk7XG5mdW5jdGlvbiBfaW5BcnJheShhcnJheSwgb2JqKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKSAhPT0gLTE7XG59XG5leHBvcnRzLl9pbkFycmF5ID0gX2luQXJyYXk7XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5LCBhbmQgYW4gaXRlbSwgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGFycmF5LCBpdCByZW1vdmVzIGl0IChpbi1wbGFjZSkuXG4gKiBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZFxuICovXG5leHBvcnRzLnJlbW92ZUZyb20gPSBob2ZfMS5jdXJyeShfcmVtb3ZlRnJvbSk7XG5mdW5jdGlvbiBfcmVtb3ZlRnJvbShhcnJheSwgb2JqKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2Yob2JqKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuX3JlbW92ZUZyb20gPSBfcmVtb3ZlRnJvbTtcbi8qKiBwdXNoZXMgYSB2YWx1ZXMgdG8gYW4gYXJyYXkgYW5kIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnRzLnB1c2hUbyA9IGhvZl8xLmN1cnJ5KF9wdXNoVG8pO1xuZnVuY3Rpb24gX3B1c2hUbyhhcnIsIHZhbCkge1xuICAgIHJldHVybiAoYXJyLnB1c2godmFsKSwgdmFsKTtcbn1cbmV4cG9ydHMuX3B1c2hUbyA9IF9wdXNoVG87XG4vKiogR2l2ZW4gYW4gYXJyYXkgb2YgKGRlcmVnaXN0cmF0aW9uKSBmdW5jdGlvbnMsIGNhbGxzIGFsbCBmdW5jdGlvbnMgYW5kIHJlbW92ZXMgZWFjaCBvbmUgZnJvbSB0aGUgc291cmNlIGFycmF5ICovXG5leHBvcnRzLmRlcmVnQWxsID0gZnVuY3Rpb24gKGZ1bmN0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbnMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgZm4oKTtcbiAgICAgICAgZXhwb3J0cy5yZW1vdmVGcm9tKGZ1bmN0aW9ucywgZm4pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQXBwbGllcyBhIHNldCBvZiBkZWZhdWx0cyB0byBhbiBvcHRpb25zIG9iamVjdC4gIFRoZSBvcHRpb25zIG9iamVjdCBpcyBmaWx0ZXJlZFxuICogdG8gb25seSB0aG9zZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QuXG4gKiBFYXJsaWVyIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdCB0YWtlIHByZWNlZGVuY2Ugd2hlbiBhcHBseWluZyBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdHMob3B0cykge1xuICAgIHZhciBkZWZhdWx0c0xpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBkZWZhdWx0c0xpc3RbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBfZGVmYXVsdHNMaXN0ID0gZGVmYXVsdHNMaXN0LmNvbmNhdCh7fSkucmV2ZXJzZSgpO1xuICAgIHZhciBkZWZhdWx0VmFscyA9IGV4cG9ydHMuZXh0ZW5kLmFwcGx5KG51bGwsIF9kZWZhdWx0c0xpc3QpO1xuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh7fSwgZGVmYXVsdFZhbHMsIHBpY2sob3B0cyB8fCB7fSwgT2JqZWN0LmtleXMoZGVmYXVsdFZhbHMpKSk7XG59XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVhY2ggZWxlbWVudCBvZiB0aGUgbGlzdCBpbnRvIGEgc2luZ2xlIG9iamVjdCwgdXNpbmcgZXh0ZW5kICovXG5leHBvcnRzLm1lcmdlUiA9IGZ1bmN0aW9uIChtZW1vLCBpdGVtKSB7IHJldHVybiBleHBvcnRzLmV4dGVuZChtZW1vLCBpdGVtKTsgfTtcbi8qKlxuICogRmluZHMgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgVGhlIGZpcnN0IHN0YXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBUaGUgc2Vjb25kIHN0YXRlLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cbiAqL1xuZnVuY3Rpb24gYW5jZXN0b3JzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIGZvciAodmFyIG4gaW4gZmlyc3QucGF0aCkge1xuICAgICAgICBpZiAoZmlyc3QucGF0aFtuXSAhPT0gc2Vjb25kLnBhdGhbbl0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcGF0aC5wdXNoKGZpcnN0LnBhdGhbbl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMuYW5jZXN0b3JzID0gYW5jZXN0b3JzO1xuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYFxuICogdmFyIGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9O1xuICogdmFyIGFiID0gcGljayhmb28sIFsnYScsICdiJ10pOyAvLyB7IGE6IDEsIGI6IDIgfVxuICogYGBgXG4gKiBAcGFyYW0gb2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gcHJvcE5hbWVzIGFuIEFycmF5IG9mIHN0cmluZ3MsIHdoaWNoIGFyZSB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydHkgbmFtZXNcbiAqL1xuZnVuY3Rpb24gcGljayhvYmosIHByb3BOYW1lcykge1xuICAgIHZhciBvYmpDb3B5ID0ge307XG4gICAgZm9yICh2YXIgcHJvcF8xIGluIG9iaikge1xuICAgICAgICBpZiAocHJvcE5hbWVzLmluZGV4T2YocHJvcF8xKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9iakNvcHlbcHJvcF8xXSA9IG9ialtwcm9wXzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpDb3B5O1xufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBvbWl0KGZvbywgWydhJywgJ2InXSk7IC8vIHsgYzogMyB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcE5hbWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pbkFycmF5KHByb3BOYW1lcykpKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKGFjY1trZXldID0gb2JqW2tleV0sIGFjYyk7IH0sIHt9KTtcbn1cbmV4cG9ydHMub21pdCA9IG9taXQ7XG4vKipcbiAqIE1hcHMgYW4gYXJyYXksIG9yIG9iamVjdCB0byBhIHByb3BlcnR5IChieSBuYW1lKVxuICovXG5mdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgaG9mXzEucHJvcChwcm9wTmFtZSkpO1xufVxuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xuLyoqIEZpbHRlcnMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0J3MgcHJvcGVydGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyciA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pLCByZXN1bHQgPSBhcnIgPyBbXSA6IHt9O1xuICAgIHZhciBhY2NlcHQgPSBhcnIgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmVzdWx0LnB1c2goeCk7IH0gOiBmdW5jdGlvbiAoeCwga2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHg7IH07XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSlcbiAgICAgICAgICAgIGFjY2VwdChpdGVtLCBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKiogRmluZHMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXksIG9yIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUgKi9cbmZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnRzLm1hcE9iaiA9IG1hcDtcbi8qKiBNYXBzIGFuIGFycmF5IG9yIG9iamVjdCBwcm9wZXJ0aWVzIHVzaW5nIGEgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge307XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiByZXN1bHRbaV0gPSBjYWxsYmFjayhpdGVtLCBpKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBpdHMgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4gKiBsZXQgdmFscyA9IHZhbHVlcyhmb28pOyAvLyBbIDEsIDIsIDMgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XTsgfSk7XG59O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDEsIHRydWUsIHt9LCBcImhlbGxvIHdvcmxkXCJdO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKlxuICogdmFscy5wdXNoKDApO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYWxsVHJ1ZVIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtbyAmJiBlbGVtOyB9O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiAgKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICpcbiAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5hbnlUcnVlUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vIHx8IGVsZW07IH07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0UiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vLmNvbmNhdChlbGVtKTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIHJlY3Vyc2l2ZWx5IHVuLW5lc3RzIGFsbCBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMuZmxhdHRlblIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShlbGVtKSA/IG1lbW8uY29uY2F0KGVsZW0ucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKSkgOiBwdXNoUihtZW1vLCBlbGVtKTtcbn07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHB1c2hlcyBhbiBvYmplY3QgdG8gYW4gYXJyYXksIHRoZW4gcmV0dXJucyB0aGUgYXJyYXkuXG4gKiBNb3N0bHkganVzdCBmb3IgW1tmbGF0dGVuUl1dIGFuZCBbW3VuaXFSXV1cbiAqL1xuZnVuY3Rpb24gcHVzaFIoYXJyLCBvYmopIHtcbiAgICBhcnIucHVzaChvYmopO1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnB1c2hSID0gcHVzaFI7XG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgZmlsdGVycyBvdXQgZHVwbGljYXRlcyAqL1xuZXhwb3J0cy51bmlxUiA9IGZ1bmN0aW9uIChhY2MsIHRva2VuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pO1xufTtcbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLnVubmVzdFIsIFtdKTsgfTtcbi8qKlxuICogUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGZsYXR0ZW4oaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKTsgfTtcbi8qKlxuICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaXNOdW1iZXIgPSAob2JqKSA9PiB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcic7XG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xuICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcbiAqXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xuICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLmFzc2VydFByZWRpY2F0ZSA9IGFzc2VydEZuO1xuLyoqXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIGRhdGEgPSB7IGZvbzogMSwgYmFyOiAyIH07XG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB2YWx1ZXMgaXMgWzEsIDJdXG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJywgJ2JheicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYXNzZXJ0TWFwID0gYXNzZXJ0Rm47XG5mdW5jdGlvbiBhc3NlcnRGbihwcmVkaWNhdGVPck1hcCwgZXJyTXNnKSB7XG4gICAgaWYgKGVyck1zZyA9PT0gdm9pZCAwKSB7IGVyck1zZyA9IFwiYXNzZXJ0IGZhaWx1cmVcIjsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVPck1hcChvYmopO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGVyck1zZykgPyBlcnJNc2cob2JqKSA6IGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5hc3NlcnRGbiA9IGFzc2VydEZuO1xuLyoqXG4gKiBMaWtlIF8ucGFpcnM6IEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhbiBhcnJheSBvZiBrZXkvdmFsdWUgcGFpcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogcGFpcnMoeyBmb286IFwiRk9PXCIsIGJhcjogXCJCQVIgfSkgLy8gWyBbIFwiZm9vXCIsIFwiRk9PXCIgXSwgWyBcImJhclwiOiBcIkJBUlwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMucGFpcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIG9ialtrZXldXTsgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiB0d28gb3IgbW9yZSBwYXJhbGxlbCBhcnJheXMsIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIHdoZXJlXG4gKiBlYWNoIHR1cGxlIGlzIGNvbXBvc2VkIG9mIFsgYVtpXSwgYltpXSwgLi4uIHpbaV0gXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgZm9vID0gWyAwLCAyLCA0LCA2IF07XG4gKiBsZXQgYmFyID0gWyAxLCAzLCA1LCA3IF07XG4gKiBsZXQgYmF6ID0gWyAxMCwgMzAsIDUwLCA3MCBdO1xuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIpOyAgICAgICAvLyBbIFswLCAxXSwgWzIsIDNdLCBbNCwgNV0sIFs2LCA3XSBdXG4gKiBhcnJheVR1cGxlcyhmb28sIGJhciwgYmF6KTsgIC8vIFsgWzAsIDEsIDEwXSwgWzIsIDMsIDMwXSwgWzQsIDUsIDUwXSwgWzYsIDcsIDcwXSBdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXJyYXlUdXBsZXMoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHZhciBtYXhBcnJheUxlbiA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChtaW4sIGFycikgeyByZXR1cm4gTWF0aC5taW4oYXJyLmxlbmd0aCwgbWluKTsgfSwgOTAwNzE5OTI1NDc0MDk5MSk7IC8vIGFrYSAyXjUzIOKIkiAxIGFrYSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgIHZhciBpLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4QXJyYXlMZW47IGkrKykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXG4gICAgICAgIC8vIFVucm9sbCB3aGVuIHRoZXJlIGFyZSAxLTQgYXJndW1lbnRzXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV0sIGFyZ3NbMl1baV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXSwgYXJnc1szXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmdzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJyYXlUdXBsZXMgPSBhcnJheVR1cGxlcztcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gKlxuICogRWFjaCBpdGVyYXRpb24gc2V0cyB0aGUga2V5L3ZhbCBwYWlyIG9uIHRoZSBtZW1vIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBtZW1vIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gKlxuICogRWFjaCBrZXlWYWx1ZVR1cGxlIHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIHZhbHVlcyBbIGtleTogc3RyaW5nLCB2YWx1ZTogYW55IF1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIHBhaXJzID0gWyBbXCJmb29rZXlcIiwgXCJmb292YWxcIl0sIFtcImJhcmtleVwiLCBcImJhcnZhbFwiXSBdXG4gKlxuICogdmFyIHBhaXJzVG9PYmogPSBwYWlycy5yZWR1Y2UoKG1lbW8sIHBhaXIpID0+IGFwcGx5UGFpcnMobWVtbywgcGFpciksIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqXG4gKiAvLyBPciwgbW9yZSBzaW1wbHk6XG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZShhcHBseVBhaXJzLCB7fSlcbiAqIC8vIHBhaXJzVG9PYmogPT0geyBmb29rZXk6IFwiZm9vdmFsXCIsIGJhcmtleTogXCJiYXJ2YWxcIiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXBwbHlQYWlycyhtZW1vLCBrZXlWYWxUdXBsZSkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShrZXlWYWxUdXBsZSkpXG4gICAgICAgIGtleSA9IGtleVZhbFR1cGxlWzBdLCB2YWx1ZSA9IGtleVZhbFR1cGxlWzFdO1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFyYW1ldGVycyB0byBhcHBseVBhaXJzXCIpO1xuICAgIG1lbW9ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBtZW1vO1xufVxuZXhwb3J0cy5hcHBseVBhaXJzID0gYXBwbHlQYWlycztcbi8qKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSAqL1xuZnVuY3Rpb24gdGFpbChhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdIHx8IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMudGFpbCA9IHRhaWw7XG4vKipcbiAqIHNoYWxsb3cgY29weSBmcm9tIHNyYyB0byBkZXN0XG4gKlxuICogbm90ZTogVGhpcyBpcyBhIHNoYWxsb3cgY29weSwgd2hpbGUgYW5ndWxhci5jb3B5IGlzIGEgZGVlcCBjb3B5LlxuICogdWktcm91dGVyIHVzZXMgYGNvcHlgIG9ubHkgdG8gbWFrZSBjb3BpZXMgb2Ygc3RhdGUgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gX2NvcHkoc3JjLCBkZXN0KSB7XG4gICAgaWYgKGRlc3QpXG4gICAgICAgIE9iamVjdC5rZXlzKGRlc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVsZXRlIGRlc3Rba2V5XTsgfSk7XG4gICAgaWYgKCFkZXN0KVxuICAgICAgICBkZXN0ID0ge307XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKGRlc3QsIHNyYyk7XG59XG4vKiogTmFpdmUgZm9yRWFjaCBpbXBsZW1lbnRhdGlvbiB3b3JrcyB3aXRoIE9iamVjdHMgb3IgQXJyYXlzICovXG5mdW5jdGlvbiBfZm9yRWFjaChvYmosIGNiLCBfdGhpcykge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gb2JqLmZvckVhY2goY2IsIF90aGlzKTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2Iob2JqW2tleV0sIGtleSk7IH0pO1xufVxuZnVuY3Rpb24gX2V4dGVuZCh0b09iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0b09ialtrZXlzW2pdXSA9IG9ialtrZXlzW2pdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmo7XG59XG5leHBvcnRzLl9leHRlbmQgPSBfZXh0ZW5kO1xuZnVuY3Rpb24gX2VxdWFscyhvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG8yKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMilcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXG4gICAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMjtcbiAgICBpZiAodDEgIT09IHQyIHx8IHQxICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciB0dXAgPSBbbzEsIG8yXTtcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0FycmF5KSh0dXApKVxuICAgICAgICByZXR1cm4gX2FycmF5c0VxKG8xLCBvMik7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNEYXRlKSh0dXApKVxuICAgICAgICByZXR1cm4gbzEuZ2V0VGltZSgpID09PSBvMi5nZXRUaW1lKCk7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNSZWdFeHApKHR1cCkpXG4gICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09PSBvMi50b1N0cmluZygpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzRnVuY3Rpb24pKHR1cCkpXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBtZWhcbiAgICB2YXIgcHJlZGljYXRlcyA9IFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgcHJlZGljYXRlc18xLmlzQXJyYXksIHByZWRpY2F0ZXNfMS5pc0RhdGUsIHByZWRpY2F0ZXNfMS5pc1JlZ0V4cF07XG4gICAgaWYgKHByZWRpY2F0ZXMubWFwKGhvZl8xLmFueSkucmVkdWNlKGZ1bmN0aW9uIChiLCBmbikgeyByZXR1cm4gYiB8fCAhIWZuKHR1cCk7IH0sIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBrZXksIGtleXMgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBvMSkge1xuICAgICAgICBpZiAoIV9lcXVhbHMobzFba2V5XSwgbzJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG8yKSB7XG4gICAgICAgIGlmICgha2V5c1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9hcnJheXNFcShhMSwgYTIpIHtcbiAgICBpZiAoYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXJyYXlUdXBsZXMoYTEsIGEyKS5yZWR1Y2UoZnVuY3Rpb24gKGIsIHQpIHsgcmV0dXJuIGIgJiYgX2VxdWFscyh0WzBdLCB0WzFdKTsgfSwgdHJ1ZSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHNvcnQgZnVuY3Rpb25cbiAqXG4gKiBDcmVhdGVzIGEgc29ydCBmdW5jdGlvbiB3aGljaCBzb3J0cyBieSBhIG51bWVyaWMgcHJvcGVydHkuXG4gKlxuICogVGhlIGBwcm9wRm5gIHNob3VsZCByZXR1cm4gdGhlIHByb3BlcnR5IGFzIGEgbnVtYmVyIHdoaWNoIGNhbiBiZSBzb3J0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIHJldHVybnMgdGhlIGBwcmlvcml0eWAgcHJvcC5cbiAqIGBgYGpzXG4gKiB2YXIgc29ydGZuID0gc29ydEJ5KG9iaiA9PiBvYmoucHJpb3JpdHkpXG4gKiAvLyBlcXVpdmFsZW50IHRvOlxuICogdmFyIGxvbmdoYW5kU29ydEZuID0gKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIHVzZXMgW1twcm9wXV1cbiAqIGBgYGpzXG4gKiB2YXIgc29ydGZuID0gc29ydEJ5KHByb3AoJ3ByaW9yaXR5JykpXG4gKiBgYGBcbiAqXG4gKiBUaGUgYGNoZWNrRm5gIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGUgb2JqZWN0cyBmcm9tIHNvcnRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIG9ubHkgc29ydHMgb2JqZWN0cyB3aXRoIHR5cGUgPT09ICdGT08nXG4gKiBgYGBqc1xuICogdmFyIHNvcnRmbiA9IHNvcnRCeShwcm9wKCdwcmlvcml0eScpLCBwcm9wRXEoJ3R5cGUnLCAnRk9PJykpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJvcEZuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwcm9wZXJ0eSAoYXMgYSBudW1iZXIpXG4gKiBAcGFyYW0gY2hlY2tGbiBhIHByZWRpY2F0ZVxuICpcbiAqIEByZXR1cm4gYSBzb3J0IGZ1bmN0aW9uIGxpa2U6IGAoYSwgYikgPT4gKGNoZWNrRm4oYSkgJiYgY2hlY2tGbihiKSkgPyBwcm9wRm4oYSkgLSBwcm9wRm4oYikgOiAwYFxuICovXG5leHBvcnRzLnNvcnRCeSA9IGZ1bmN0aW9uIChwcm9wRm4sIGNoZWNrRm4pIHtcbiAgICBpZiAoY2hlY2tGbiA9PT0gdm9pZCAwKSB7IGNoZWNrRm4gPSBob2ZfMS52YWwodHJ1ZSk7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChjaGVja0ZuKGEpICYmIGNoZWNrRm4oYikpID8gcHJvcEZuKGEpIC0gcHJvcEZuKGIpIDogMDtcbiAgICB9O1xufTtcbi8qKlxuICogQ29tcG9zZXMgYSBsaXN0IG9mIHNvcnQgZnVuY3Rpb25zXG4gKlxuICogQ3JlYXRlcyBhIHNvcnQgZnVuY3Rpb24gY29tcG9zZWQgb2YgbXVsdGlwbGUgc29ydCBmdW5jdGlvbnMuXG4gKiBFYWNoIHNvcnQgZnVuY3Rpb24gaXMgaW52b2tlZCBpbiBzZXJpZXMuXG4gKiBUaGUgZmlyc3Qgc29ydCBmdW5jdGlvbiB0byByZXR1cm4gbm9uLXplcm8gXCJ3aW5zXCIuXG4gKlxuICogQHBhcmFtIHNvcnRGbnMgbGlzdCBvZiBzb3J0IGZ1bmN0aW9uc1xuICovXG5leHBvcnRzLmNvbXBvc2VTb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3J0Rm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc29ydEZuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcG9zZWRTb3J0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRGbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBmbikgeyByZXR1cm4gcHJldiB8fCBmbihhLCBiKTsgfSwgMCk7XG4gICAgfTtcbn07XG4vLyBpc3N1ZSAjMjY3NlxuZXhwb3J0cy5zaWxlbmNlVW5jYXVnaHRJblByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiAwOyB9KSAmJiBwcm9taXNlO1xufTtcbmV4cG9ydHMuc2lsZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcikpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/common.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/coreservices.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/coreservices.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanM/ZWJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAoZm5uYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZubmFtZSArIFwiKCk6IE5vIGNvcmVzZXJ2aWNlcyBpbXBsZW1lbnRhdGlvbiBmb3IgVUktUm91dGVyIGlzIGxvYWRlZC5cIik7XG59OyB9O1xudmFyIHNlcnZpY2VzID0ge1xuICAgICRxOiB1bmRlZmluZWQsXG4gICAgJGluamVjdG9yOiB1bmRlZmluZWQsXG59O1xuZXhwb3J0cy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZXNlcnZpY2VzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/coreservices.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/glob.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/glob.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vZ2xvYi5qcz85NTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb3JlXG4gKi9cbi8qKlxuICogTWF0Y2hlcyBzdGF0ZSBuYW1lcyB1c2luZyBnbG9iLWxpa2UgcGF0dGVybiBzdHJpbmdzLlxuICpcbiAqIEdsb2JzIGNhbiBiZSB1c2VkIGluIHNwZWNpZmljIEFQSXMgaW5jbHVkaW5nOlxuICpcbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaXNdXVxuICogLSBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dXG4gKiAtIFRoZSBmaXJzdCBhcmd1bWVudCB0byBIb29rIFJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgbGlrZSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICogICAgLSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gYW5kIFtbSG9va01hdGNoQ3JpdGVyaW9uXV1cbiAqXG4gKiBBIGBHbG9iYCBzdHJpbmcgaXMgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgc3RhdGUgbmFtZXMuXG4gKiBOZXN0ZWQgc3RhdGUgbmFtZXMgYXJlIHNwbGl0IGludG8gc2VnbWVudHMgKHNlcGFyYXRlZCBieSBhIGRvdCkgd2hlbiBwcm9jZXNzaW5nLlxuICogVGhlIHN0YXRlIG5hbWVkIGBmb28uYmFyLmJhemAgaXMgc3BsaXQgaW50byB0aHJlZSBzZWdtZW50cyBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqXG4gKiBHbG9icyB3b3JrIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICpcbiAqICMjIyBFeGFjdCBtYXRjaDpcbiAqXG4gKiBUaGUgZ2xvYiBgJ0EuQidgIG1hdGNoZXMgdGhlIHN0YXRlIG5hbWVkIGV4YWN0bHkgYCdBLkInYC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJ0EnYCAgICAgICB8IGAnQSdgICAgICAgICAgICAgICAgfCBgJ0InYCAsIGAnQS5DJ2AgICAgICB8XG4gKiB8IGAnQS5CJ2AgICAgIHwgYCdBLkInYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgIHxcbiAqIHwgYCdmb28nYCAgICAgfCBgJ2ZvbydgICAgICAgICAgICAgIHwgYCdGT08nYCAsIGAnZm9vLmJhcidgfFxuICpcbiAqICMjIyBTaW5nbGUgc3RhciAoYCpgKVxuICpcbiAqIEEgc2luZ2xlIHN0YXIgKGAqYCkgaXMgYSB3aWxkY2FyZCB0aGF0IG1hdGNoZXMgZXhhY3RseSBvbmUgc2VnbWVudC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZCAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkIHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJyonYCAgICAgICB8IGAnQSdgICwgYCdaJ2AgICAgICAgIHwgYCdBLkInYCAsIGAnWi5ZLlgnYCAgICAgICB8XG4gKiB8IGAnQS4qJ2AgICAgIHwgYCdBLkInYCAsIGAnQS5DJ2AgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgIHxcbiAqIHwgYCdBLiouKidgICAgfCBgJ0EuQi5DJ2AgLCBgJ0EuWC5ZJ2B8IGAnQSdgLCBgJ0EuQidgICwgYCdaLlkuWCdgfFxuICpcbiAqICMjIyBEb3VibGUgc3RhciAoYCoqYClcbiAqXG4gKiBBIGRvdWJsZSBzdGFyIChgJyoqJ2ApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzICp6ZXJvIG9yIG1vcmUgc2VnbWVudHMqXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWQgICAgICAgICAgICAgICAgICAgICAgICAgICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgICAgICAgICB8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCcqKidgICAgICAgfCBgJ0EnYCAsIGAnQS5CJ2AsIGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgfCAobWF0Y2hlcyBhbGwgc3RhdGVzKSAgICAgICAgICAgICAgfFxuICogfCBgJ0EuKionYCAgICB8IGAnQSdgICwgYCdBLkInYCAsIGAnQS5DLlgnYCAgICAgICAgICAgICAgICAgICB8IGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGAnKiouWCdgICAgIHwgYCdYJ2AgLCBgJ0EuWCdgICwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EubG9naW4uWidgICAgICAgICAgICAgIHxcbiAqIHwgYCdBLioqLlgnYCAgfCBgJ0EuWCdgICwgYCdBLkIuWCdgICwgYCdBLkIuQy5YJ2AgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgICAgICAgICAgfFxuICpcbiAqL1xudmFyIEdsb2IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2IodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmdsb2IgPSB0ZXh0LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciByZWdleHBTdHJpbmcgPSB0aGlzLnRleHQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICBpZiAoc2VnID09PSAnKionKVxuICAgICAgICAgICAgICAgIHJldHVybiAnKD86fCg/OlxcXFwuW14uXSopKiknO1xuICAgICAgICAgICAgaWYgKHNlZyA9PT0gJyonKVxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXC5bXi5dKic7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwuJyArIHNlZztcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIHJlZ2V4cFN0cmluZyArIFwiJFwiKTtcbiAgICB9XG4gICAgR2xvYi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KCcuJyArIG5hbWUpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBnbG9iLWxpa2UgY2hhcmFjdGVycyBpbiBpdCAqL1xuICAgIEdsb2IuaXMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gISEvWyEsKl0rLy5leGVjKHRleHQpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBnbG9iIGZyb20gdGhlIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGlzbid0IEdsb2ItbGlrZSAqL1xuICAgIEdsb2IuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBHbG9iLmlzKHRleHQpID8gbmV3IEdsb2IodGV4dCkgOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2I7XG59KCkpO1xuZXhwb3J0cy5HbG9iID0gR2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/glob.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/hof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/hof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanM/NTUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSGlnaGVyIG9yZGVyIGZ1bmN0aW9uc1xuICpcbiAqIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9ob2ZcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBmb3IgW1BhcnRpYWwgQXBwbGljYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcnRpYWxfYXBwbGljYXRpb24pIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHdpdGggTiBwYXJhbWV0ZXJzLCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgcGFydGlhbCBhcHBsaWNhdGlvbi5cbiAqIFRoZSBuZXcgZnVuY3Rpb24gYWNjZXB0cyBhbnl3aGVyZSBmcm9tIDEgdG8gTiBwYXJhbWV0ZXJzLiAgV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIE0gcGFyYW1ldGVycyxcbiAqIHdoZXJlIE0gaXMgbGVzcyB0aGFuIE4sIGl0IHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy4gIEl0IGNvbnRpbnVlcyB0b1xuICogYWNjZXB0IG1vcmUgcGFyYW1ldGVycyB1bnRpbCBhbGwgTiBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzdXBwbGllZC5cbiAqXG4gKlxuICogVGhpcyBjb250cml2ZWQgZXhhbXBsZSB1c2VzIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gYXMgYW4gcHJlZGljYXRlLCB3aGljaCByZXR1cm5zIHRydWVcbiAqIGlmIGFuIG9iamVjdCBpcyBmb3VuZCBpbiBib3RoIGFycmF5cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIC8vIHJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgaW4gYm90aCBvZiB0aGUgdHdvIGFycmF5c1xuICogZnVuY3Rpb24gaW5Cb3RoKGFycmF5MSwgYXJyYXkyLCBvYmplY3QpIHtcbiAqICAgcmV0dXJuIGFycmF5MS5pbmRleE9mKG9iamVjdCkgIT09IC0xICYmXG4gKiAgICAgICAgICBhcnJheTIuaW5kZXhPZihvYmplY3QpICE9PSAxO1xuICogfVxuICogbGV0IG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajdcbiAqIGxldCBmb29zID0gW29iajEsIG9iajNdXG4gKiBsZXQgYmFycyA9IFtvYmozLCBvYmo0LCBvYmo1XVxuICpcbiAqIC8vIEEgY3VycmllZCBcImNvcHlcIiBvZiBpbkJvdGhcbiAqIGxldCBjdXJyaWVkSW5Cb3RoID0gY3VycnkoaW5Cb3RoKTtcbiAqIC8vIFBhcnRpYWxseSBhcHBseSBib3RoIHRoZSBhcnJheTEgYW5kIGFycmF5MlxuICogbGV0IGluRm9vc0FuZEJhcnMgPSBjdXJyaWVkSW5Cb3RoKGZvb3MsIGJhcnMpO1xuICpcbiAqIC8vIFN1cHBseSB0aGUgZmluYWwgYXJndW1lbnQ7IHNpbmNlIGFsbCBhcmd1bWVudHMgYXJlXG4gKiAvLyBzdXBwbGllZCwgdGhlIG9yaWdpbmFsIGluQm90aCBmdW5jdGlvbiBpcyB0aGVuIGNhbGxlZC5cbiAqIGxldCBvYmoxSW5Cb3RoID0gaW5Gb29zQW5kQmFycyhvYmoxKTsgLy8gZmFsc2VcbiAqXG4gKiAvLyBVc2UgdGhlIGluRm9vc0FuZEJhcnMgYXMgYSBwcmVkaWNhdGUuXG4gKiAvLyBGaWx0ZXIsIG9uIGVhY2ggaXRlcmF0aW9uLCBzdXBwbGllcyB0aGUgZmluYWwgYXJndW1lbnRcbiAqIGxldCBhbGxPYmpzID0gWyBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3IF07XG4gKiBsZXQgZm91bmRJbkJvdGggPSBhbGxPYmpzLmZpbHRlcihpbkZvb3NBbmRCYXJzKTsgLy8gWyBvYmozIF1cbiAqXG4gKiBgYGBcbiAqXG4gKiBTdG9sZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mzk0NzQ3L2phdmFzY3JpcHQtY3VycnktZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZm5cbiAqIEByZXR1cm5zIHsqfGZ1bmN0aW9uKCk6ICgqfGFueSl9XG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gICAgdmFyIGluaXRpYWxfYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTtcbiAgICB2YXIgZnVuY19hcmdzX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjdXJyaWVkKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IGZ1bmNfYXJnc19sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmllZChhcmdzLmNvbmNhdChbXS5zbGljZS5hcHBseShhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjdXJyaWVkKGluaXRpYWxfYXJncyk7XG59XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgcmlnaHQtdG8tbGVmdFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBjb21wb3NlZCA9IGNvbXBvc2UoZixnLGgpXG4gKiB0aGVuLCBjb21wb3NlZCBpczogZihnKGgoeCkpKVxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IHN0YXJ0LCByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgbGVmdC10by1yaWdodFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBwaXBlZCA9IHBpcGUoZixnLGgpO1xuICogdGhlbiwgcGlwZWQgaXM6IGgoZyhmKHgpKSlcbiAqL1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmdW5jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn1cbmV4cG9ydHMucGlwZSA9IHBpcGU7XG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKi9cbmV4cG9ydHMucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV07IH07XG59O1xuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUgYW5kIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIGJhc2VkIG9uIHdoZXRoZXJcbiAqIHRoZSBwYXNzZWQgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoYXQgbWF0Y2hlcyB0aGUgdmFsdWVcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3BFcShcIm5hbWVcIiwgXCJibGFyZ1wiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gdHJ1ZVxuICovXG5leHBvcnRzLnByb3BFcSA9IGN1cnJ5KGZ1bmN0aW9uIChuYW1lLCB2YWwsIG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXSA9PT0gdmFsOyB9KTtcbi8qKlxuICogR2l2ZW4gYSBkb3R0ZWQgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gKiBsZXQgb2JqID0geyBpZDogMSwgbmVzdGVkT2JqOiB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH0sIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3AoXCJuZXN0ZWRPYmoubmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKiBsZXQgcHJvcE5vdEZvdW5kID0gcHJvcChcInRoaXMucHJvcGVydHkuZG9lc250LmV4aXN0XCIpO1xuICogcHJvcE5vdEZvdW5kKG9iaikgPT09IHVuZGVmaW5lZFxuICovXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcGlwZS5hcHBseShudWxsLCBuYW1lLnNwbGl0KFwiLlwiKS5tYXAoZXhwb3J0cy5wcm9wKSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRydXRoeSBvciBmYWxzZXkgdmFsdWUsIHJldHVybnMgYVxuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvcHBvc2l0ZSAoZmFsc2V5IG9yIHRydXRoeSkgdmFsdWUgZ2l2ZW4gdGhlIHNhbWUgaW5wdXRzXG4gKi9cbmV4cG9ydHMubm90ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59O1xuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYm90aCBmdW5jdGlvbnMgcmV0dXJuIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBhbmQoZm4xLCBmbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgJiYgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcbiAqIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIG9yKGZuMSwgZm4yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpIHx8IGZuMi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0cy5vciA9IG9yO1xuLyoqXG4gKiBDaGVjayBpZiBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGZuMSBhIHByZWRpY2F0ZSBmdW5jdGlvbiBgZm4xYFxuICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIGBmbjFgIGlzIHRydWUgZm9yIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbiAoZm4xKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGIsIHgpIHsgcmV0dXJuIGIgJiYgISFmbjEoeCk7IH0sIHRydWUpOyB9O1xufTtcbmV4cG9ydHMuYW55ID0gZnVuY3Rpb24gKGZuMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiIHx8ICEhZm4xKHgpOyB9LCBmYWxzZSk7IH07XG59O1xuLyoqIEdpdmVuIGEgY2xhc3MsIHJldHVybnMgYSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBvZiB0aGF0IGNsYXNzICovXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gY3RvciB8fCBvYmogaW5zdGFuY2VvZiBjdG9yKTtcbiAgICB9O1xufTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFub3RoZXIgdmFsdWUgaXMgPT09IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSAqL1xuZXhwb3J0cy5lcSA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB2YWwgPT09IG90aGVyO1xufTsgfTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgdmFsdWUgKi9cbmV4cG9ydHMudmFsID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH07IH07XG5mdW5jdGlvbiBpbnZva2UoZm5OYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9ialtmbk5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuaW52b2tlID0gaW52b2tlO1xuLyoqXG4gKiBTb3J0YSBsaWtlIFBhdHRlcm4gTWF0Y2hpbmcgKGEgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBjb25kaXRpb25hbCBjb25zdHJ1Y3QpXG4gKlxuICogU2VlIGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/UGF0dGVybk1hdGNoaW5nXG4gKlxuICogVGhpcyBpcyBhIGNvbmRpdGlvbmFsIGNvbnN0cnVjdCB3aGljaCBhbGxvd3MgYSBzZXJpZXMgb2YgcHJlZGljYXRlcyBhbmQgb3V0cHV0IGZ1bmN0aW9uc1xuICogdG8gYmUgY2hlY2tlZCBhbmQgdGhlbiBhcHBsaWVkLiAgRWFjaCBwcmVkaWNhdGUgcmVjZWl2ZXMgdGhlIGlucHV0LiAgSWYgdGhlIHByZWRpY2F0ZVxuICogcmV0dXJucyB0cnV0aHksIHRoZW4gaXRzIG1hdGNoaW5nIG91dHB1dCBmdW5jdGlvbiAobWFwcGluZyBmdW5jdGlvbikgaXMgcHJvdmlkZWQgd2l0aFxuICogdGhlIGlucHV0IGFuZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICpcbiAqIEVhY2ggY29tYmluYXRpb24gKDItdHVwbGUpIG9mIHByZWRpY2F0ZSArIG91dHB1dCBmdW5jdGlvbiBzaG91bGQgYmUgcGxhY2VkIGluIGFuIGFycmF5XG4gKiBvZiBzaXplIDI6IFsgcHJlZGljYXRlLCBtYXBGbiBdXG4gKlxuICogVGhlc2UgMi10dXBsZXMgc2hvdWxkIGJlIHB1dCBpbiBhbiBvdXRlciBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogLy8gSGVyZSdzIGEgMi10dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgaXNTdHJpbmcgcHJlZGljYXRlXG4gKiAvLyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIGlucHV0XG4gKiBsZXQgZmlyc3RUdXBsZSA9IFsgYW5ndWxhci5pc1N0cmluZywgKGlucHV0KSA9PiBgSGVyZXMgeW91ciBzdHJpbmcgJHtpbnB1dH1gIF07XG4gKlxuICogLy8gU2Vjb25kIHR1cGxlOiBwcmVkaWNhdGUgXCJpc051bWJlclwiLCBtYXBmbiByZXR1cm5zIGEgZGVzY3JpcHRpb25cbiAqIGxldCBzZWNvbmRUdXBsZSA9IFsgYW5ndWxhci5pc051bWJlciwgKGlucHV0KSA9PiBgKCR7aW5wdXR9KSBUaGF0J3MgYSBudW1iZXIhYCBdO1xuICpcbiAqIGxldCB0aGlyZCA9IFsgKGlucHV0KSA9PiBpbnB1dCA9PT0gbnVsbCwgIChpbnB1dCkgPT4gYE9oLCBudWxsLi4uYCBdO1xuICpcbiAqIGxldCBmb3VydGggPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IHVuZGVmaW5lZCwgIChpbnB1dCkgPT4gYG5vdGRlZmluZWRgIF07XG4gKlxuICogbGV0IGRlc2NyaXB0aW9uT2YgPSBwYXR0ZXJuKFsgZmlyc3RUdXBsZSwgc2Vjb25kVHVwbGUsIHRoaXJkLCBmb3VydGggXSk7XG4gKlxuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZih1bmRlZmluZWQpKTsgLy8gJ25vdGRlZmluZWQnXG4gKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKDU1KSk7IC8vICcoNTUpIFRoYXQncyBhIG51bWJlciEnXG4gKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKFwiZm9vXCIpKTsgLy8gJ0hlcmUncyB5b3VyIHN0cmluZyBmb28nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RydWN0IEEgMkQgYXJyYXkuICBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IHNob3VsZCBiZSBhbiBhcnJheSwgYSAyLXR1cGxlLFxuICogd2l0aCBhIFByZWRpY2F0ZSBhbmQgYSBtYXBwaW5nL291dHB1dCBmdW5jdGlvblxuICogQHJldHVybnMge2Z1bmN0aW9uKGFueSk6ICp9XG4gKi9cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RydWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RydWN0W2ldWzBdKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RbaV1bMV0oeCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvZi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/hof.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module common */ /** for typedoc */\n__export(__webpack_require__(/*! ./common */ \"./node_modules/@uirouter/core/lib/common/common.js\"));\n__export(__webpack_require__(/*! ./coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\"));\n__export(__webpack_require__(/*! ./glob */ \"./node_modules/@uirouter/core/lib/common/glob.js\"));\n__export(__webpack_require__(/*! ./hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\"));\n__export(__webpack_require__(/*! ./predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\"));\n__export(__webpack_require__(/*! ./queue */ \"./node_modules/@uirouter/core/lib/common/queue.js\"));\n__export(__webpack_require__(/*! ./strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\"));\n__export(__webpack_require__(/*! ./trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2luZGV4LmpzP2E2NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvZlwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ3NcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/predicates.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/predicates.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar hof_1 = __webpack_require__(/*! ./hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar stateObject_1 = __webpack_require__(/*! ../state/stateObject */ \"./node_modules/@uirouter/core/lib/state/stateObject.js\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nexports.isState = stateObject_1.StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9wcmVkaWNhdGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcHJlZGljYXRlcy5qcz8xZDVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIFByZWRpY2F0ZXNcbiAqXG4gKiBUaGVzZSBwcmVkaWNhdGVzIHJldHVybiB0cnVlL2ZhbHNlIGJhc2VkIG9uIHRoZSBpbnB1dC5cbiAqIEFsdGhvdWdoIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIHRoZXkgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX3ByZWRpY2F0ZXNcbiAqL1xuLyoqICovXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XG52YXIgc3RhdGVPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS9zdGF0ZU9iamVjdFwiKTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgdGlzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgKHgpID09PSB0OyB9OyB9O1xuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IHRpcygndW5kZWZpbmVkJyk7XG5leHBvcnRzLmlzRGVmaW5lZCA9IGhvZl8xLm5vdChleHBvcnRzLmlzVW5kZWZpbmVkKTtcbmV4cG9ydHMuaXNOdWxsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gPT09IG51bGw7IH07XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaG9mXzEub3IoZXhwb3J0cy5pc051bGwsIGV4cG9ydHMuaXNVbmRlZmluZWQpO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gdGlzKCdmdW5jdGlvbicpO1xuZXhwb3J0cy5pc051bWJlciA9IHRpcygnbnVtYmVyJyk7XG5leHBvcnRzLmlzU3RyaW5nID0gdGlzKCdzdHJpbmcnKTtcbmV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7IH07XG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZXhwb3J0cy5pc0RhdGUgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IERhdGVdJzsgfSk7XG5leHBvcnRzLmlzUmVnRXhwID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJzsgfSk7XG5leHBvcnRzLmlzU3RhdGUgPSBzdGF0ZU9iamVjdF8xLlN0YXRlT2JqZWN0LmlzU3RhdGU7XG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBpbmplY3RhYmxlXG4gKlxuICogQSB2YWx1ZSBpcyBcImluamVjdGFibGVcIiBpZiBpdCBpcyBhIGZ1bmN0aW9uLCBvciBpZiBpdCBpcyBhbiBuZzEgYXJyYXktbm90YXRpb24tc3R5bGUgYXJyYXlcbiAqIHdoZXJlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIGFycmF5IGFyZSBTdHJpbmdzLCBleGNlcHQgdGhlIGxhc3Qgb25lLCB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGlzSW5qZWN0YWJsZSh2YWwpIHtcbiAgICBpZiAoZXhwb3J0cy5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCkge1xuICAgICAgICB2YXIgaGVhZCA9IHZhbC5zbGljZSgwLCAtMSksIHRhaWwgPSB2YWwuc2xpY2UoLTEpO1xuICAgICAgICByZXR1cm4gIShoZWFkLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pc1N0cmluZykpLmxlbmd0aCB8fCB0YWlsLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pc0Z1bmN0aW9uKSkubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNGdW5jdGlvbih2YWwpO1xufVxuZXhwb3J0cy5pc0luamVjdGFibGUgPSBpc0luamVjdGFibGU7XG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBsb29rcyBsaWtlIGEgUHJvbWlzZVxuICpcbiAqIEl0IGlzIHByb2JhYmx5IGEgUHJvbWlzZSBpZiBpdCdzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhIGB0aGVuYCBwcm9wZXJ0eSB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuaXNQcm9taXNlID0gaG9mXzEuYW5kKGV4cG9ydHMuaXNPYmplY3QsIGhvZl8xLnBpcGUoaG9mXzEucHJvcCgndGhlbicpLCBleHBvcnRzLmlzRnVuY3Rpb24pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWRpY2F0ZXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/predicates.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/queue.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/queue.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module common\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9xdWV1ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3F1ZXVlLmpzP2VjODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgY29tbW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUXVldWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXVlKF9pdGVtcywgX2xpbWl0KSB7XG4gICAgICAgIGlmIChfaXRlbXMgPT09IHZvaWQgMCkgeyBfaXRlbXMgPSBbXTsgfVxuICAgICAgICBpZiAoX2xpbWl0ID09PSB2b2lkIDApIHsgX2xpbWl0ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9pdGVtcyA9IF9pdGVtcztcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XG4gICAgfVxuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLl9saW1pdCAmJiBpdGVtcy5sZW5ndGggPiB0aGlzLl9saW1pdClcbiAgICAgICAgICAgIGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faXRlbXM7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHJldHVybiBpZHggPiAtMSAmJiB0aGlzLl9pdGVtcy5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnBlZWtIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KCkpO1xuZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/queue.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/strings.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/strings.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(/*! ./predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ \"./node_modules/@uirouter/core/lib/transition/rejectFactory.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ./hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar transition_1 = __webpack_require__(/*! ../transition/transition */ \"./node_modules/@uirouter/core/lib/transition/transition.js\");\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ \"./node_modules/@uirouter/core/lib/resolve/resolvable.js\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vc3RyaW5ncy5qcz9hMzAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBGdW5jdGlvbnMgdGhhdCBtYW5pcHVsYXRlIHN0cmluZ3NcbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCB0aGV5IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9zdHJpbmdzXG4gKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKTtcbnZhciByZWplY3RGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5XCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4vaG9mXCIpO1xudmFyIHRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBzaG9ydGVuZWQgdG8gYSBtYXhpbXVtIGxlbmd0aFxuICpcbiAqIElmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBsZXNzIHRoYW4gdGhlIGBtYXhgIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXG4gKiBFbHNlIHJldHVybiB0aGUgc3RyaW5nLCBzaG9ydGVuZWQgdG8gYG1heCAtIDNgIGFuZCBhcHBlbmQgdGhyZWUgZG90cyAoXCIuLi5cIikuXG4gKlxuICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZXR1cm5cbiAqIEBwYXJhbSBzdHIgdGhlIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBtYXhMZW5ndGgobWF4LCBzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBtYXgpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4IC0gMykgKyBcIi4uLlwiO1xufVxuZXhwb3J0cy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcsIHdpdGggc3BhY2VzIGFkZGVkIHRvIHRoZSBlbmQsIHVwIHRvIGEgZGVzaXJlZCBzdHIgbGVuZ3RoXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIHRoZSBkZXNpcmVkIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXG4gKiBFbHNlIHJldHVybnMgdGhlIHN0cmluZywgd2l0aCBleHRyYSBzcGFjZXMgb24gdGhlIGVuZCwgc3VjaCB0aGF0IGl0IHJlYWNoZXMgYGxlbmd0aGAgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHBhZFN0cmluZyhsZW5ndGgsIHN0cikge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICBzdHIgKz0gXCIgXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMucGFkU3RyaW5nID0gcGFkU3RyaW5nO1xuZnVuY3Rpb24ga2Vib2JTdHJpbmcoY2FtZWxDYXNlKSB7XG4gICAgcmV0dXJuIGNhbWVsQ2FzZVxuICAgICAgICAucmVwbGFjZSgvXihbQS1aXSkvLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuICQxLnRvTG93ZXJDYXNlKCk7IH0pIC8vIHJlcGxhY2UgZmlyc3QgY2hhclxuICAgICAgICAucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuIFwiLVwiICsgJDEudG9Mb3dlckNhc2UoKTsgfSk7IC8vIHJlcGxhY2UgcmVzdFxufVxuZXhwb3J0cy5rZWJvYlN0cmluZyA9IGtlYm9iU3RyaW5nO1xuZnVuY3Rpb24gX3RvSnNvbihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbn1cbmZ1bmN0aW9uIF9mcm9tSnNvbihqc29uKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyhqc29uKSA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xufVxuZnVuY3Rpb24gcHJvbWlzZVRvU3RyaW5nKHApIHtcbiAgICByZXR1cm4gXCJQcm9taXNlKFwiICsgSlNPTi5zdHJpbmdpZnkocCkgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uVG9TdHJpbmcoZm4pIHtcbiAgICB2YXIgZm5TdHIgPSBmblRvU3RyaW5nKGZuKTtcbiAgICB2YXIgbmFtZWRGdW5jdGlvbk1hdGNoID0gZm5TdHIubWF0Y2goL14oZnVuY3Rpb24gW14gXStcXChbXildKlxcKSkvKTtcbiAgICB2YXIgdG9TdHIgPSBuYW1lZEZ1bmN0aW9uTWF0Y2ggPyBuYW1lZEZ1bmN0aW9uTWF0Y2hbMV0gOiBmblN0cjtcbiAgICB2YXIgZm5OYW1lID0gZm5bJ25hbWUnXSB8fCBcIlwiO1xuICAgIGlmIChmbk5hbWUgJiYgdG9TdHIubWF0Y2goL2Z1bmN0aW9uIFxcKC8pKSB7XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gJyArIGZuTmFtZSArIHRvU3RyLnN1YnN0cig5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvU3RyO1xufVxuZXhwb3J0cy5mdW5jdGlvblRvU3RyaW5nID0gZnVuY3Rpb25Ub1N0cmluZztcbmZ1bmN0aW9uIGZuVG9TdHJpbmcoZm4pIHtcbiAgICB2YXIgX2ZuID0gcHJlZGljYXRlc18xLmlzQXJyYXkoZm4pID8gZm4uc2xpY2UoLTEpWzBdIDogZm47XG4gICAgcmV0dXJuIF9mbiAmJiBfZm4udG9TdHJpbmcoKSB8fCBcInVuZGVmaW5lZFwiO1xufVxuZXhwb3J0cy5mblRvU3RyaW5nID0gZm5Ub1N0cmluZztcbnZhciBzdHJpbmdpZnlQYXR0ZXJuRm4gPSBudWxsO1xudmFyIHN0cmluZ2lmeVBhdHRlcm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaXNSZWplY3Rpb24gPSByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZTtcbiAgICBzdHJpbmdpZnlQYXR0ZXJuRm4gPSBzdHJpbmdpZnlQYXR0ZXJuRm4gfHwgaG9mXzEucGF0dGVybihbXG4gICAgICAgIFtob2ZfMS5ub3QocHJlZGljYXRlc18xLmlzRGVmaW5lZCksIGhvZl8xLnZhbChcInVuZGVmaW5lZFwiKV0sXG4gICAgICAgIFtwcmVkaWNhdGVzXzEuaXNOdWxsLCBob2ZfMS52YWwoXCJudWxsXCIpXSxcbiAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1Byb21pc2UsIGhvZl8xLnZhbChcIltQcm9taXNlXVwiKV0sXG4gICAgICAgIFtpc1JlamVjdGlvbiwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX3RyYW5zaXRpb25SZWplY3Rpb24udG9TdHJpbmcoKTsgfV0sXG4gICAgICAgIFtob2ZfMS5pcyhyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxuICAgICAgICBbaG9mXzEuaXModHJhbnNpdGlvbl8xLlRyYW5zaXRpb24pLCBob2ZfMS5pbnZva2UoXCJ0b1N0cmluZ1wiKV0sXG4gICAgICAgIFtob2ZfMS5pcyhyZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSksIGhvZl8xLmludm9rZShcInRvU3RyaW5nXCIpXSxcbiAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUsIGZ1bmN0aW9uVG9TdHJpbmddLFxuICAgICAgICBbaG9mXzEudmFsKHRydWUpLCBjb21tb25fMS5pZGVudGl0eV1cbiAgICBdKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybkZuKHZhbHVlKTtcbn07XG5mdW5jdGlvbiBzdHJpbmdpZnkobykge1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbCkge1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdbY2lyY3VsYXIgcmVmXSc7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybih2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobywgZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiBmb3JtYXQodmFsKTsgfSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4vKiogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgc3RyaW5nIG9uIGEgY2hhcmFjdGVyIG9yIHN1YnN0cmluZyAqL1xuZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0ciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBbXCJcIiwgXCJcIl07XG4gICAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKGNoYXIpO1xuICAgIGlmIChpZHggPT09IC0xKVxuICAgICAgICByZXR1cm4gW3N0ciwgXCJcIl07XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyKDAsIGlkeCksIHN0ci5zdWJzdHIoaWR4ICsgMSldO1xufTsgfTtcbi8qKlxuICogU3BsaXRzIG9uIGEgZGVsaW1pdGVyLCBidXQgcmV0dXJucyB0aGUgZGVsaW1pdGVycyBpbiB0aGUgYXJyYXlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdmFyIHNwbGl0T25TbGFzaGVzID0gc3BsaXRPbkRlbGltKCcvJyk7XG4gKiBzcGxpdE9uU2xhc2hlcyhcIi9mb29cIik7IC8vIFtcIi9cIiwgXCJmb29cIl1cbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvby9cIik7IC8vIFtcIi9cIiwgXCJmb29cIiwgXCIvXCJdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc3BsaXRPbkRlbGltKGRlbGltKSB7XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIihcIiArIGRlbGltICsgXCIpXCIsIFwiZ1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHJlKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG59XG5leHBvcnRzLnNwbGl0T25EZWxpbSA9IHNwbGl0T25EZWxpbTtcbjtcbi8qKlxuICogUmVkdWNlIGZuIHRoYXQgam9pbnMgbmVpZ2hib3Jpbmcgc3RyaW5nc1xuICpcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybnMgYSBuZXcgYXJyYXlcbiAqIHdoZXJlIGFsbCBuZWlnaGJvcmluZyBzdHJpbmdzIGhhdmUgYmVlbiBqb2luZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIGxldCBhcnIgPSBbXCJmb29cIiwgXCJiYXJcIiwgMSwgXCJiYXpcIiwgXCJcIiwgXCJxdXhcIiBdO1xuICogYXJyLnJlZHVjZShqb2luTmVpZ2hib3JzUiwgW10pIC8vIFtcImZvb2JhclwiLCAxLCBcImJhenF1eFwiIF1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBqb2luTmVpZ2hib3JzUihhY2MsIHgpIHtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKGNvbW1vbl8xLnRhaWwoYWNjKSkgJiYgcHJlZGljYXRlc18xLmlzU3RyaW5nKHgpKVxuICAgICAgICByZXR1cm4gYWNjLnNsaWNlKDAsIC0xKS5jb25jYXQoY29tbW9uXzEudGFpbChhY2MpICsgeCk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnB1c2hSKGFjYywgeCk7XG59XG5leHBvcnRzLmpvaW5OZWlnaGJvcnNSID0gam9pbk5laWdoYm9yc1I7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/strings.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/trace.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/trace.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar strings_1 = __webpack_require__(/*! ./strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/** @hidden */ var _tid = hof_1.parse(\"$id\");\n/** @hidden */ var _rid = hof_1.parse(\"router.$id\");\n/** @hidden */ var transLbl = function (trans) { return \"Transition #\" + _tid(trans) + \"-\" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Started  -> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Ignored  <> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        console.log(transLbl(trans) + \":   <- Hook returned: \" + strings_1.maxLength(200, strings_1.stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":         Resolving \" + path + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":               <- Resolved  \" + resolvable + \" to: \" + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Rejected \" + strings_1.stringify(trans) + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Success  \" + strings_1.stringify(trans) + \", final state: \" + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi90cmFjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzP2IzNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqICMgVHJhbnNpdGlvbiB0cmFjaW5nIChkZWJ1ZylcbiAqXG4gKiBFbmFibGUgdHJhbnNpdGlvbiB0cmFjaW5nIHRvIHByaW50IHRyYW5zaXRpb24gaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUsXG4gKiBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXG4gKiBUcmFjaW5nIGxvZ3MgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBUcmFuc2l0aW9uIHRvIHlvdXIgY29uc29sZS5cbiAqXG4gKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW1RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cbiAqXG4gKiAjIyMgRVM2XG4gKiBgYGBqc1xuICogaW1wb3J0IHt0cmFjZX0gZnJvbSBcInVpLXJvdXRlci1uZzJcIjsgLy8gb3IgXCJhbmd1bGFyLXVpLXJvdXRlclwiXG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7IC8vIFRSQU5TSVRJT04gYW5kIFZJRVdDT05GSUdcbiAqIGBgYFxuICpcbiAqICMjIyBDSlNcbiAqIGBgYGpzXG4gKiBsZXQgdHJhY2UgPSByZXF1aXJlKFwiYW5ndWxhci11aS1yb3V0ZXJcIikudHJhY2U7IC8vIG9yIFwidWktcm91dGVyLW5nMlwiXG4gKiB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIsIFwiVklFV0NPTkZJR1wiKTtcbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iYWxzXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gd2luZG93W1wiYW5ndWxhci11aS1yb3V0ZXJcIl0udHJhY2U7IC8vIG9yIFwidWktcm91dGVyLW5nMlwiXG4gKiB0cmFjZS5lbmFibGUoKTsgLy8gVHJhY2UgZXZlcnl0aGluZyAodmVyeSB2ZXJib3NlKVxuICogYGBgXG4gKlxuICogIyMjIEFuZ3VsYXIgMTpcbiAqIGBgYGpzXG4gKiBhcHAucnVuKCR0cmFjZSA9PiAkdHJhY2UuZW5hYmxlKCkpO1xuICogYGBgXG4gKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhY2VcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHVpVmlld1N0cmluZyh2aWV3RGF0YSkge1xuICAgIGlmICghdmlld0RhdGEpXG4gICAgICAgIHJldHVybiAndWktdmlldyAoZGVmdW5jdCknO1xuICAgIHJldHVybiBcIlt1aS12aWV3I1wiICsgdmlld0RhdGEuaWQgKyBcIiB0YWcgXCIgK1xuICAgICAgICAoXCJpbiB0ZW1wbGF0ZSBmcm9tICdcIiArICh2aWV3RGF0YS5jcmVhdGlvbkNvbnRleHQgJiYgdmlld0RhdGEuY3JlYXRpb25Db250ZXh0Lm5hbWUgfHwgJyhyb290KScpICsgXCInIHN0YXRlXTogXCIpICtcbiAgICAgICAgKFwiZnFuOiAnXCIgKyB2aWV3RGF0YS5mcW4gKyBcIicsIFwiKSArXG4gICAgICAgIChcIm5hbWU6ICdcIiArIHZpZXdEYXRhLm5hbWUgKyBcIkBcIiArIHZpZXdEYXRhLmNyZWF0aW9uQ29udGV4dCArIFwiJylcIik7XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIHZpZXdDb25maWdTdHJpbmcgPSBmdW5jdGlvbiAodmlld0NvbmZpZykge1xuICAgIHJldHVybiBcIltWaWV3Q29uZmlnI1wiICsgdmlld0NvbmZpZy4kaWQgKyBcIiBmcm9tICdcIiArICh2aWV3Q29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWUgfHwgJyhyb290KScpICsgXCInIHN0YXRlXTogdGFyZ2V0IHVpLXZpZXc6ICdcIiArIHZpZXdDb25maWcudmlld0RlY2wuJHVpVmlld05hbWUgKyBcIkBcIiArIHZpZXdDb25maWcudmlld0RlY2wuJHVpVmlld0NvbnRleHRBbmNob3IgKyBcIidcIjtcbn07XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplZENhdChpbnB1dCkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNOdW1iZXIoaW5wdXQpID8gQ2F0ZWdvcnlbaW5wdXRdIDogQ2F0ZWdvcnlbQ2F0ZWdvcnlbaW5wdXRdXTtcbn1cbi8qKlxuICogVHJhY2UgY2F0ZWdvcmllcyBFbnVtXG4gKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYSBjYXRlZ29yeSB1c2luZyBbW1RyYWNlLmVuYWJsZV1dIG9yIFtbVHJhY2UuZGlzYWJsZV1dXG4gKlxuICogYHRyYWNlLmVuYWJsZShDYXRlZ29yeS5UUkFOU0lUSU9OKWBcbiAqXG4gKiBUaGVzZSBjYW4gYWxzbyBiZSBwcm92aWRlZCB1c2luZyBhIG1hdGNoaW5nIHN0cmluZywgb3IgcG9zaXRpb24gb3JkaW5hbFxuICpcbiAqIGB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIpYFxuICpcbiAqIGB0cmFjZS5lbmFibGUoMSlgXG4gKi9cbnZhciBDYXRlZ29yeTtcbihmdW5jdGlvbiAoQ2F0ZWdvcnkpIHtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlJFU09MVkVcIl0gPSAwXSA9IFwiUkVTT0xWRVwiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVFJBTlNJVElPTlwiXSA9IDFdID0gXCJUUkFOU0lUSU9OXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJIT09LXCJdID0gMl0gPSBcIkhPT0tcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlVJVklFV1wiXSA9IDNdID0gXCJVSVZJRVdcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlZJRVdDT05GSUdcIl0gPSA0XSA9IFwiVklFV0NPTkZJR1wiO1xufSkoQ2F0ZWdvcnkgPSBleHBvcnRzLkNhdGVnb3J5IHx8IChleHBvcnRzLkNhdGVnb3J5ID0ge30pKTtcbi8qKiBAaGlkZGVuICovIHZhciBfdGlkID0gaG9mXzEucGFyc2UoXCIkaWRcIik7XG4vKiogQGhpZGRlbiAqLyB2YXIgX3JpZCA9IGhvZl8xLnBhcnNlKFwicm91dGVyLiRpZFwiKTtcbi8qKiBAaGlkZGVuICovIHZhciB0cmFuc0xibCA9IGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gXCJUcmFuc2l0aW9uICNcIiArIF90aWQodHJhbnMpICsgXCItXCIgKyBfcmlkKHRyYW5zKTsgfTtcbi8qKlxuICogUHJpbnRzIFVJLVJvdXRlciBUcmFuc2l0aW9uIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICovXG52YXIgVHJhY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gVHJhY2UoKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB7fTtcbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMgPSAwO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKGVuYWJsZWQsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFjYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKENhdGVnb3J5KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHBhcnNlSW50KGssIDEwKTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiAhaXNOYU4oayk7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBDYXRlZ29yeVtrZXldOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRlZ29yaWVzLm1hcChub3JtYWxpemVkQ2F0KS5mb3JFYWNoKGZ1bmN0aW9uIChjYXRlZ29yeSkgeyByZXR1cm4gX3RoaXMuX2VuYWJsZWRbY2F0ZWdvcnldID0gZW5hYmxlZDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGEgdHJhY2UgW1tDYXRlZ29yeV1dXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHRyYWNlLmVuYWJsZShcIlRSQU5TSVRJT05cIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGVuYWJsZS4gSWYgYGNhdGVnb3JpZXNgIGlzIG9taXR0ZWQsIGFsbCBjYXRlZ29yaWVzIGFyZSBlbmFibGVkLlxuICAgICAqICAgICAgICBBbHNvIHRha2VzIHN0cmluZ3MgKGNhdGVnb3J5IG5hbWUpIG9yIG9yZGluYWwgKGNhdGVnb3J5IHBvc2l0aW9uKVxuICAgICAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KHRydWUsIGNhdGVnb3JpZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYSB0cmFjZSBbW0NhdGVnb3J5XV1cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogdHJhY2UuZGlzYWJsZShcIlZJRVdDT05GSUdcIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGRpc2FibGUuIElmIGBjYXRlZ29yaWVzYCBpcyBvbWl0dGVkLCBhbGwgY2F0ZWdvcmllcyBhcmUgZGlzYWJsZWQuXG4gICAgICogICAgICAgIEFsc28gdGFrZXMgc3RyaW5ncyAoY2F0ZWdvcnkgbmFtZSkgb3Igb3JkaW5hbCAoY2F0ZWdvcnkgcG9zaXRpb24pXG4gICAgICovXG4gICAgVHJhY2UucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KGZhbHNlLCBjYXRlZ29yaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW5hYmxlZCBzdGF0ZXVzIG9mIGEgW1tDYXRlZ29yeV1dXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHRyYWNlLmVuYWJsZWQoXCJWSUVXQ09ORklHXCIpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgdGhlIGNhdGVnb3J5IGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkW25vcm1hbGl6ZWRDYXQoY2F0ZWdvcnkpXTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVHJhbnNpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogU3RhcnRlZCAgLT4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogSWdub3JlZCAgPD4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHN0ZXAsIHRyYW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZXZlbnQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5ob29rVHlwZVwiKShvcHRpb25zKSB8fCBcImludGVybmFsXCIsIGNvbnRleHQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWVcIikob3B0aW9ucykgfHwgaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dFwiKShvcHRpb25zKSB8fCBcInVua25vd25cIiwgbmFtZSA9IHN0cmluZ3NfMS5mdW5jdGlvblRvU3RyaW5nKHN0ZXAucmVnaXN0ZXJlZEhvb2suY2FsbGJhY2spO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICBIb29rIC0+IFwiICsgZXZlbnQgKyBcIiBjb250ZXh0OiBcIiArIGNvbnRleHQgKyBcIiwgXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgbmFtZSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VIb29rUmVzdWx0ID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQsIHRyYW5zLCB0cmFuc2l0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5IT09LKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgPC0gSG9vayByZXR1cm5lZDogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgc3RyaW5nc18xLnN0cmluZ2lmeShob29rUmVzdWx0KSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB3aGVuLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgUmVzb2x2aW5nIFwiICsgcGF0aCArIFwiIChcIiArIHdoZW4gKyBcIilcIik7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmFibGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgICAgICAgPC0gUmVzb2x2ZWQgIFwiICsgcmVzb2x2YWJsZSArIFwiIHRvOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBzdHJpbmdzXzEuc3RyaW5naWZ5KHJlc29sdmFibGUuZGF0YSkpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IDwtIFJlamVjdGVkIFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykgKyBcIiwgcmVhc29uOiBcIiArIHJlYXNvbik7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVN1Y2Nlc3MgPSBmdW5jdGlvbiAoZmluYWxTdGF0ZSwgdHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiA8LSBTdWNjZXNzICBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpICsgXCIsIGZpbmFsIHN0YXRlOiBcIiArIGZpbmFsU3RhdGUubmFtZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSwgZXh0cmEpIHtcbiAgICAgICAgaWYgKGV4dHJhID09PSB2b2lkIDApIHsgZXh0cmEgPSBcIlwiOyB9XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwidWktdmlldzogXCIgKyBzdHJpbmdzXzEucGFkU3RyaW5nKDMwLCBldmVudCkgKyBcIiBcIiArIHVpVmlld1N0cmluZyh2aWV3RGF0YSkgKyBleHRyYSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQgPSBmdW5jdGlvbiAodmlld0RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy50cmFjZVVJVmlld0V2ZW50KFwiVXBkYXRpbmdcIiwgdmlld0RhdGEsIFwiIHdpdGggVmlld0NvbmZpZyBmcm9tIGNvbnRleHQ9J1wiICsgY29udGV4dCArIFwiJ1wiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3RmlsbCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgaHRtbCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoXCJGaWxsXCIsIHZpZXdEYXRhLCBcIiB3aXRoOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBodG1sKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHZpZXdDb25maWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVklFV0NPTkZJRzogXCIgKyBldmVudCArIFwiIFwiICsgdmlld0NvbmZpZ1N0cmluZyh2aWV3Q29uZmlnKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHZpZXdEYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZJRVdDT05GSUc6IFwiICsgZXZlbnQgKyBcIiBcIiArIHVpVmlld1N0cmluZyh2aWV3RGF0YSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNlO1xufSgpKTtcbmV4cG9ydHMuVHJhY2UgPSBUcmFjZTtcbi8qKlxuICogVGhlIFtbVHJhY2VdXSBzaW5nbGV0b25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogaW1wb3J0IHt0cmFjZX0gZnJvbSBcImFuZ3VsYXItdWktcm91dGVyXCI7XG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7XG4gKiBgYGBcbiAqL1xudmFyIHRyYWNlID0gbmV3IFRyYWNlKCk7XG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/common/trace.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/globals.js":
/*!****************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/globals.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = __webpack_require__(/*! ./params/stateParams */ \"./node_modules/@uirouter/core/lib/params/stateParams.js\");\nvar queue_1 = __webpack_require__(/*! ./common/queue */ \"./node_modules/@uirouter/core/lib/common/queue.js\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\nexports.UIRouterGlobals = UIRouterGlobals;\n//# sourceMappingURL=globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanM/ZTc4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHN0YXRlUGFyYW1zXzEgPSByZXF1aXJlKFwiLi9wYXJhbXMvc3RhdGVQYXJhbXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9xdWV1ZVwiKTtcbi8qKlxuICogR2xvYmFsIHJvdXRlciBzdGF0ZVxuICpcbiAqIFRoaXMgaXMgd2hlcmUgd2UgaG9sZCB0aGUgZ2xvYmFsIG11dGFibGUgc3RhdGUgc3VjaCBhcyBjdXJyZW50IHN0YXRlLCBjdXJyZW50XG4gKiBwYXJhbXMsIGN1cnJlbnQgdHJhbnNpdGlvbiwgZXRjLlxuICovXG52YXIgVUlSb3V0ZXJHbG9iYWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSVJvdXRlckdsb2JhbHMoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgc3RhdGVQYXJhbXNfMS5TdGF0ZVBhcmFtcygpO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPSAtMTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25IaXN0b3J5ID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xuICAgIH1cbiAgICBVSVJvdXRlckdsb2JhbHMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBVSVJvdXRlckdsb2JhbHM7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlckdsb2JhbHMgPSBVSVJvdXRlckdsb2JhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/globals.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/coreResolvables.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/coreResolvables.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar transition_1 = __webpack_require__(/*! ../transition/transition */ \"./node_modules/@uirouter/core/lib/transition/transition.js\");\nvar router_1 = __webpack_require__(/*! ../router */ \"./node_modules/@uirouter/core/lib/router.js\");\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, \"\");\n    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, \"\");\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nexports.registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n//# sourceMappingURL=coreResolvables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2NvcmVSZXNvbHZhYmxlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzPzJiZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIi4uL3JvdXRlclwiKTtcbmZ1bmN0aW9uIGFkZENvcmVSZXNvbHZhYmxlcyh0cmFucykge1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogcm91dGVyXzEuVUlSb3V0ZXIsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zLnJvdXRlcjsgfSwgZGF0YTogdHJhbnMucm91dGVyIH0sIFwiXCIpO1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogdHJhbnNpdGlvbl8xLlRyYW5zaXRpb24sIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zOyB9LCBkYXRhOiB0cmFucyB9LCBcIlwiKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckdHJhbnNpdGlvbiQnLCBkZXBzOiBbXSwgcmVzb2x2ZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuczsgfSwgZGF0YTogdHJhbnMgfSwgXCJcIik7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHN0YXRlUGFyYW1zJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMucGFyYW1zKCk7IH0sIGRhdGE6IHRyYW5zLnBhcmFtcygpIH0sIFwiXCIpO1xuICAgIHRyYW5zLmVudGVyaW5nKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHN0YXRlJCcsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9LCBkYXRhOiBzdGF0ZSB9LCBzdGF0ZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlZ2lzdGVyQWRkQ29yZVJlc29sdmFibGVzID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCBhZGRDb3JlUmVzb2x2YWJsZXMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVSZXNvbHZhYmxlcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/coreResolvables.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ \"./node_modules/@uirouter/core/lib/transition/rejectFactory.js\");\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace_1.trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return rejectFactory_1.Rejection.ignored().toPromise();\n}\nexports.registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n//# sourceMappingURL=ignoredTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qcz9mYjYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHNraXBzIGEgdHJhbnNpdGlvbiBpZiBpdCBzaG91bGQgYmUgaWdub3JlZFxuICpcbiAqIFRoaXMgaG9vayBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIG9uQmVmb3JlIHBoYXNlLlxuICpcbiAqIElmIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBpZ25vcmVkIChiZWNhdXNlIG5vIHBhcmFtZXRlciBvciBzdGF0ZXMgY2hhbmdlZClcbiAqIHRoZW4gdGhlIHRyYW5zaXRpb24gaXMgaWdub3JlZCBhbmQgbm90IHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gaWdub3JlZEhvb2sodHJhbnMpIHtcbiAgICB2YXIgaWdub3JlZFJlYXNvbiA9IHRyYW5zLl9pZ25vcmVkUmVhc29uKCk7XG4gICAgaWYgKCFpZ25vcmVkUmVhc29uKVxuICAgICAgICByZXR1cm47XG4gICAgdHJhY2VfMS50cmFjZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkKHRyYW5zKTtcbiAgICB2YXIgcGVuZGluZyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb247XG4gICAgLy8gVGhlIHVzZXIgY2xpY2tlZCBhIGxpbmsgZ29pbmcgYmFjayB0byB0aGUgKmN1cnJlbnQgc3RhdGUqICgnQScpXG4gICAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYWxzbyBhIHBlbmRpbmcgdHJhbnNpdGlvbiBpbiBmbGlnaHQgKHRvICdCJylcbiAgICAvLyBBYm9ydCB0aGUgdHJhbnNpdGlvbiB0byAnQicgYmVjYXVzZSB0aGUgdXNlciBub3cgd2FudHMgdG8gYmUgYmFjayBhdCAnQScuXG4gICAgaWYgKGlnbm9yZWRSZWFzb24gPT09ICdTYW1lQXNDdXJyZW50JyAmJiBwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaWdub3JlZCgpLnRvUHJvbWlzZSgpO1xufVxuZXhwb3J0cy5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaWdub3JlZEhvb2ssIHsgcHJpb3JpdHk6IC05OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZWRUcmFuc2l0aW9uLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/invalidTransition.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/invalidTransition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nexports.registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n//# sourceMappingURL=invalidTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pbnZhbGlkVHJhbnNpdGlvbi5qcz8yODdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWplY3RzIHRoZSBUcmFuc2l0aW9uIGlmIGl0IGlzIGludmFsaWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGZvciBleGFtcGxlLCBwYXJhbSB2YWx1ZXMgZG8gbm90IHZhbGlkYXRlKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25Ib29rKHRyYW5zKSB7XG4gICAgaWYgKCF0cmFucy52YWxpZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0cmFucy5lcnJvcigpKTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkVHJhbnNpdGlvbi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/invalidTransition.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/lazyLoad.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/lazyLoad.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2xhenlMb2FkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9sYXp5TG9hZC5qcz9mZjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBwZXJmb3JtcyBsYXp5IGxvYWRpbmdcbiAqXG4gKiBXaGVuIGVudGVyaW5nIGEgc3RhdGUgXCJhYmNcIiB3aGljaCBoYXMgYSBgbGF6eUxvYWRgIGZ1bmN0aW9uIGRlZmluZWQ6XG4gKiAtIEludm9rZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiAodW5sZXNzIGl0IGlzIGFscmVhZHkgaW4gcHJvY2VzcylcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwiaW4gcHJvY2Vzc1wiXG4gKiAgIC0gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwcm9taXNlICh0aGF0IHJlc29sdmVzIHdoZW4gbGF6eSBsb2FkaW5nIGlzIGNvbXBsZXRlKVxuICogLSBXYWl0IGZvciB0aGUgcHJvbWlzZSB0byBzZXR0bGVcbiAqICAgLSBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyB0byBhIFtbTGF6eUxvYWRSZXN1bHRdXSwgdGhlbiByZWdpc3RlciB0aG9zZSBzdGF0ZXNcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwibm90IGluIHByb2Nlc3NcIlxuICogLSBJZiB0aGUgaG9vayB3YXMgc3VjY2Vzc2Z1bFxuICogICAtIFJlbW92ZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiBmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvblxuICogLSBJZiBhbGwgdGhlIGhvb2tzIHdlcmUgc3VjY2Vzc2Z1bFxuICogICAtIFJldHJ5IHRoZSB0cmFuc2l0aW9uIChieSByZXR1cm5pbmcgYSBUYXJnZXRTdGF0ZSlcbiAqXG4gKiBgYGBcbiAqIC5zdGF0ZSgnYWJjJywge1xuICogICBjb21wb25lbnQ6ICdmb29Db21wb25lbnQnLFxuICogICBsYXp5TG9hZDogKCkgPT4gU3lzdGVtLmltcG9ydCgnLi9mb29Db21wb25lbnQnKVxuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXVxuICovXG52YXIgbGF6eUxvYWRIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgcm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXI7XG4gICAgZnVuY3Rpb24gcmV0cnlUcmFuc2l0aW9uKCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5vcmlnaW5hbFRyYW5zaXRpb24oKS5vcHRpb25zKCkuc291cmNlICE9PSAndXJsJykge1xuICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIG5vdCB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgICAgICAgICAvLyBUaGUgbGF6eSBzdGF0ZSBzaG91bGQgYmUgbG9hZGVkIG5vdywgc28gcmUtdHJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uXG4gICAgICAgICAgICB2YXIgb3JpZyA9IHRyYW5zaXRpb24udGFyZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChvcmlnLmlkZW50aWZpZXIoKSwgb3JpZy5wYXJhbXMoKSwgb3JpZy5vcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgICAgIC8vIFJ1biB0aGUgVVJMIHJ1bGVzIGFuZCBmaW5kIHRoZSBiZXN0IG1hdGNoXG4gICAgICAgIHZhciAkdXJsID0gcm91dGVyLnVybFNlcnZpY2U7XG4gICAgICAgIHZhciByZXN1bHQgPSAkdXJsLm1hdGNoKCR1cmwucGFydHMoKSk7XG4gICAgICAgIHZhciBydWxlID0gcmVzdWx0ICYmIHJlc3VsdC5ydWxlO1xuICAgICAgICAvLyBJZiB0aGUgYmVzdCBtYXRjaCBpcyBhIHN0YXRlLCByZWRpcmVjdCB0aGUgdHJhbnNpdGlvbiAoaW5zdGVhZFxuICAgICAgICAvLyBvZiBjYWxsaW5nIHN5bmMoKSB3aGljaCBzdXBlcnNlZGVzIHRoZSBjdXJyZW50IHRyYW5zaXRpb24pXG4gICAgICAgIGlmIChydWxlICYmIHJ1bGUudHlwZSA9PT0gXCJTVEFURVwiKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlLnN0YXRlO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJlc3VsdC5tYXRjaDtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChzdGF0ZSwgcGFyYW1zLCB0cmFuc2l0aW9uLm9wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQsIHNvIGxldCAuc3luYygpIGNob29zZSB0aGUgYmVzdCBub24tc3RhdGUgbWF0Y2gvb3RoZXJ3aXNlXG4gICAgICAgIHJvdXRlci51cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VzID0gdHJhbnNpdGlvbi5lbnRlcmluZygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpOyB9KTtcbiAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKS50aGVuKHJldHJ5VHJhbnNpdGlvbik7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7IGVudGVyaW5nOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUubGF6eUxvYWQ7IH0gfSwgbGF6eUxvYWRIb29rKTtcbn07XG4vKipcbiAqIEludm9rZXMgYSBzdGF0ZSdzIGxhenkgbG9hZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIGxhenkgbG9hZFxuICogQHJldHVybnMgQSBwcm9taXNlIGZvciB0aGUgbGF6eSBsb2FkIHJlc3VsdFxuICovXG5mdW5jdGlvbiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKSB7XG4gICAgdmFyIGxhenlMb2FkRm4gPSBzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7XG4gICAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxuICAgIHZhciBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGF6eUxvYWQ7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBkZWxldGUgbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ10gPVxuICAgICAgICAgICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihsYXp5TG9hZEZuKHRyYW5zaXRpb24sIHN0YXRlKSlcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGFueSBsYXp5IGxvYWRlZCBzdGF0ZSBkZWZpbml0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUmVnaXN0cnkocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgQXJyYXkuaXNBcnJheShyZXN1bHQuc3RhdGVzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihzdGF0ZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZXhwb3J0cy5sYXp5TG9hZFN0YXRlID0gbGF6eUxvYWRTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenlMb2FkLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/lazyLoad.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9vbkVudGVyRXhpdFJldGFpbi5qcz9kNDEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIGZhY3Rvcnkgd2hpY2ggY3JlYXRlcyBhbiBvbkVudGVyLCBvbkV4aXQgb3Igb25SZXRhaW4gdHJhbnNpdGlvbiBob29rIGZ1bmN0aW9uXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGludm9rZXMgdGhlIChmb3IgaW5zdGFuY2UpIHN0YXRlLm9uRW50ZXIgaG9vayB3aGVuIHRoZVxuICogc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX3N0YXRlID0gc3RhdGUuJCRzdGF0ZSgpO1xuICAgICAgICB2YXIgaG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgcmV0dXJuIGhvb2tGbih0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRXhpdFxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCwgdGhlIHN0YXRlJ3MgLm9uRXhpdCBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IChzdGF0ZSkgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRXhpdF1dXG4gKi9cbnZhciBvbkV4aXRIb29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRXhpdCcpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRXhpdEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRXhpdDsgfSB9LCBvbkV4aXRIb29rKTtcbn07XG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIHdhcyBhbHJlYWR5IGVudGVyZWQsIGFuZCBpcyBub3QgYmVpbmcgZXhpdGVkIG9yIHJlLWVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vblJldGFpbiBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IChzdGF0ZSkgPT4gISFzdGF0ZS5vblJldGFpbiB9LCBvblJldGFpbkhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKi9cbnZhciBvblJldGFpbkhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25SZXRhaW4nKTtcbmV4cG9ydHMucmVnaXN0ZXJPblJldGFpbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uUmV0YWluOyB9IH0sIG9uUmV0YWluSG9vayk7XG59O1xuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FbnRlclxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FbnRlciB9LCBvbkVudGVySG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICovXG52YXIgb25FbnRlckhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FbnRlcicpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRW50ZXJIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRW50ZXI7IH0gfSwgb25FbnRlckhvb2spO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRW50ZXJFeGl0UmV0YWluLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/redirectTo.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/redirectTo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3JlZGlyZWN0VG8uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3JlZGlyZWN0VG8uanM/ZjI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgc3RhdGUgb3IgcGFyYW1zXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiAoc3RhdGUpID0+ICEhc3RhdGUucmVkaXJlY3RUbyB9LCByZWRpcmVjdEhvb2spO2BcbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlZGlyZWN0VG9dXVxuICovXG52YXIgcmVkaXJlY3RUb0hvb2sgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICB2YXIgcmVkaXJlY3QgPSB0cmFucy50bygpLnJlZGlyZWN0VG87XG4gICAgaWYgKCFyZWRpcmVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciAkc3RhdGUgPSB0cmFucy5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhyZXN1bHQpKVxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQocmVzdWx0LCB0cmFucy5wYXJhbXMoKSwgdHJhbnMub3B0aW9ucygpKTtcbiAgICAgICAgaWYgKHJlc3VsdFsnc3RhdGUnXSB8fCByZXN1bHRbJ3BhcmFtcyddKVxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQocmVzdWx0WydzdGF0ZSddIHx8IHRyYW5zLnRvKCksIHJlc3VsdFsncGFyYW1zJ10gfHwgdHJhbnMucGFyYW1zKCksIHRyYW5zLm9wdGlvbnMoKSk7XG4gICAgfVxuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZWRpcmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4ocmVkaXJlY3QodHJhbnMpKS50aGVuKGhhbmRsZVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVSZXN1bHQocmVkaXJlY3QpO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJSZWRpcmVjdFRvSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5yZWRpcmVjdFRvOyB9IH0sIHJlZGlyZWN0VG9Ib29rKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcmVjdFRvLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/redirectTo.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ \"./node_modules/@uirouter/core/lib/resolve/resolveContext.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3Jlc29sdmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3Jlc29sdmUuanM/OTgwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBFQUdFUiBSZXNvbHZhYmxlcyBpbiB0aGUgVG8gUGF0aFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgpO2BcbiAqXG4gKiBXaGVuIGEgVHJhbnNpdGlvbiBzdGFydHMsIHRoaXMgaG9vayByZXNvbHZlcyBhbGwgdGhlIEVBR0VSIFJlc29sdmFibGVzLCB3aGljaCB0aGUgdHJhbnNpdGlvbiB0aGVuIHdhaXRzIGZvci5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG52YXIgZWFnZXJSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcygpLnRvKVxuICAgICAgICAucmVzb2x2ZVBhdGgoXCJFQUdFUlwiLCB0cmFucylcbiAgICAgICAgLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckVhZ2VyUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogMTAwMCB9KTtcbn07XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIExBWlkgUmVzb2x2YWJsZXMgZm9yIHRoZSBzdGF0ZSAoYW5kIGFsbCBpdHMgYW5jZXN0b3JzKSBpbiB0aGUgVG8gUGF0aFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogKCkgPT4gdHJ1ZSB9LCBsYXp5UmVzb2x2ZVN0YXRlKTtgXG4gKlxuICogV2hlbiBhIFN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoaXMgaG9vayByZXNvbHZlcyBhbGwgdGhlIFJlc29sdmFibGVzIGZvciB0aGlzIHN0YXRlLCB3aGljaCB0aGUgdHJhbnNpdGlvbiB0aGVuIHdhaXRzIGZvci5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG52YXIgbGF6eVJlc29sdmVTdGF0ZSA9IGZ1bmN0aW9uICh0cmFucywgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAgICAgLnN1YkNvbnRleHQoc3RhdGUuJCRzdGF0ZSgpKVxuICAgICAgICAucmVzb2x2ZVBhdGgoXCJMQVpZXCIsIHRyYW5zKVxuICAgICAgICAudGhlbihjb21tb25fMS5ub29wKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyTGF6eVJlc29sdmVTdGF0ZSA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6IGhvZl8xLnZhbCh0cnVlKSB9LCBsYXp5UmVzb2x2ZVN0YXRlLCB7IHByaW9yaXR5OiAxMDAwIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/resolve.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/updateGlobals.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/updateGlobals.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of \"the current transition\" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of \"the current state\"\n * ([[Globals.current]] and [[Globals.$current]]) and \"the current param values\" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        common_1.copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nexports.registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n//# sourceMappingURL=updateGlobals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VwZGF0ZUdsb2JhbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VwZGF0ZUdsb2JhbHMuanM/YWZlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHVwZGF0ZXMgZ2xvYmFsIFVJLVJvdXRlciBzdGF0ZVxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCB1cGRhdGVHbG9iYWxTdGF0ZSk7YFxuICpcbiAqIEJlZm9yZSBhIFtbVHJhbnNpdGlvbl1dIHN0YXJ0cywgdXBkYXRlcyB0aGUgZ2xvYmFsIHZhbHVlIG9mIFwidGhlIGN1cnJlbnQgdHJhbnNpdGlvblwiIChbW0dsb2JhbHMudHJhbnNpdGlvbl1dKS5cbiAqIEFmdGVyIGEgc3VjY2Vzc2Z1bCBbW1RyYW5zaXRpb25dXSwgdXBkYXRlcyB0aGUgZ2xvYmFsIHZhbHVlcyBvZiBcInRoZSBjdXJyZW50IHN0YXRlXCJcbiAqIChbW0dsb2JhbHMuY3VycmVudF1dIGFuZCBbW0dsb2JhbHMuJGN1cnJlbnRdXSkgYW5kIFwidGhlIGN1cnJlbnQgcGFyYW0gdmFsdWVzXCIgKFtbR2xvYmFscy5wYXJhbXNdXSkuXG4gKlxuICogU2VlIGFsc28gdGhlIGRlcHJlY2F0ZWQgcHJvcGVydGllczpcbiAqIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25dXSwgW1tTdGF0ZVNlcnZpY2UuY3VycmVudF1dLCBbW1N0YXRlU2VydmljZS5wYXJhbXNdXVxuICovXG52YXIgdXBkYXRlR2xvYmFsU3RhdGUgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICB2YXIgZ2xvYmFscyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzO1xuICAgIHZhciB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMuZW5xdWV1ZSh0cmFucyk7XG4gICAgICAgIGdsb2JhbHMuJGN1cnJlbnQgPSB0cmFucy4kdG8oKTtcbiAgICAgICAgZ2xvYmFscy5jdXJyZW50ID0gZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuICAgICAgICBjb21tb25fMS5jb3B5KHRyYW5zLnBhcmFtcygpLCBnbG9iYWxzLnBhcmFtcyk7XG4gICAgfTtcbiAgICB2YXIgY2xlYXJDdXJyZW50VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90IGNsZWFyIGdsb2JhbHMudHJhbnNpdGlvbiBpZiBhIGRpZmZlcmVudCB0cmFuc2l0aW9uIGhhcyBzdGFydGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICBpZiAoZ2xvYmFscy50cmFuc2l0aW9uID09PSB0cmFucylcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICB0cmFucy5vblN1Y2Nlc3Moe30sIHRyYW5zaXRpb25TdWNjZXNzZnVsLCB7IHByaW9yaXR5OiAxMDAwMCB9KTtcbiAgICB0cmFucy5wcm9taXNlLnRoZW4oY2xlYXJDdXJyZW50VHJhbnNpdGlvbiwgY2xlYXJDdXJyZW50VHJhbnNpdGlvbik7XG59O1xuZXhwb3J0cy5yZWdpc3RlclVwZGF0ZUdsb2JhbFN0YXRlID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCB1cGRhdGVHbG9iYWxTdGF0ZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlR2xvYmFscy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/updateGlobals.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/url.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/url.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VybC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXJsLmpzPzNiMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyB0aGUgVVJMIGFmdGVyIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGVVcmwpO2BcbiAqL1xudmFyIHVwZGF0ZVVybCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0cmFuc2l0aW9uLm9wdGlvbnMoKTtcbiAgICB2YXIgJHN0YXRlID0gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgIHZhciAkdXJsUm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXIudXJsUm91dGVyO1xuICAgIC8vIERvbnQgdXBkYXRlIHRoZSB1cmwgaW4gdGhlc2Ugc2l0dWF0aW9uczpcbiAgICAvLyBUaGUgdHJhbnNpdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgVVJMIHN5bmMgKG9wdGlvbnMuc291cmNlID09PSAndXJsJylcbiAgICAvLyBUaGUgdXNlciBkb2Vzbid0IHdhbnQgdGhlIHVybCB0byB1cGRhdGUgKG9wdGlvbnMubG9jYXRpb24gPT09IGZhbHNlKVxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBzdGF0ZSwgYW5kIGFsbCBwYXJlbnRzIGhhdmUgbm8gbmF2aWdhYmxlIHVybFxuICAgIGlmIChvcHRpb25zLnNvdXJjZSAhPT0gJ3VybCcgJiYgb3B0aW9ucy5sb2NhdGlvbiAmJiAkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlKSB7XG4gICAgICAgIHZhciB1cmxPcHRpb25zID0geyByZXBsYWNlOiBvcHRpb25zLmxvY2F0aW9uID09PSAncmVwbGFjZScgfTtcbiAgICAgICAgJHVybFJvdXRlci5wdXNoKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUudXJsLCAkc3RhdGUucGFyYW1zLCB1cmxPcHRpb25zKTtcbiAgICB9XG4gICAgJHVybFJvdXRlci51cGRhdGUodHJ1ZSk7XG59O1xuZXhwb3J0cy5yZWdpc3RlclVwZGF0ZVVybCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZVVybCwgeyBwcmlvcml0eTogOTk5OSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/url.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/views.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/views.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3ZpZXdzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy92aWV3cy5qcz8wYmQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHdhaXRzIGZvciB0aGUgdmlld3MgdG8gbG9hZFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtgXG4gKlxuICogQWxsb3dzIHRoZSB2aWV3cyB0byBkbyBhc3luYyB3b3JrIGluIFtbVmlld0NvbmZpZy5sb2FkXV0gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGNvbnRpbnVlcy5cbiAqIEluIGFuZ3VsYXIgMSwgdGhpcyBpbmNsdWRlcyBsb2FkaW5nIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBsb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgdmFyIGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKFwiZW50ZXJpbmdcIik7XG4gICAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAkcS5hbGwoZW50ZXJpbmdWaWV3cy5tYXAoZnVuY3Rpb24gKHZpZXcpIHsgcmV0dXJuICRxLndoZW4odmlldy5sb2FkKCkpOyB9KSkudGhlbihjb21tb25fMS5ub29wKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEVudGVyaW5nVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25GaW5pc2goe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtcbn07XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggYWN0aXZhdGVzIHRoZSBuZXcgdmlld3Mgd2hlbiBhIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO2BcbiAqXG4gKiBBZnRlciBhIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHRoaXMgaG9vayBkZWFjdGl2YXRlcyB0aGUgb2xkIHZpZXdzIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLFxuICogYW5kIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICpcbiAqIFNlZSBbW1ZpZXdTZXJ2aWNlXV1cbiAqL1xudmFyIGFjdGl2YXRlVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgIHZhciBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xuICAgIHZhciBleGl0aW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKFwiZXhpdGluZ1wiKTtcbiAgICBpZiAoIWVudGVyaW5nVmlld3MubGVuZ3RoICYmICFleGl0aW5nVmlld3MubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyICR2aWV3ID0gdHJhbnNpdGlvbi5yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgZXhpdGluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZjKSB7IHJldHVybiAkdmlldy5kZWFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgIGVudGVyaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmMpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgICR2aWV3LnN5bmMoKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/hooks/views.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @coreapi\n * @module common\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./common/index */ \"./node_modules/@uirouter/core/lib/common/index.js\"));\n__export(__webpack_require__(/*! ./params/index */ \"./node_modules/@uirouter/core/lib/params/index.js\"));\n__export(__webpack_require__(/*! ./path/index */ \"./node_modules/@uirouter/core/lib/path/index.js\"));\n__export(__webpack_require__(/*! ./resolve/index */ \"./node_modules/@uirouter/core/lib/resolve/index.js\"));\n__export(__webpack_require__(/*! ./state/index */ \"./node_modules/@uirouter/core/lib/state/index.js\"));\n__export(__webpack_require__(/*! ./transition/index */ \"./node_modules/@uirouter/core/lib/transition/index.js\"));\n__export(__webpack_require__(/*! ./url/index */ \"./node_modules/@uirouter/core/lib/url/index.js\"));\n__export(__webpack_require__(/*! ./view/index */ \"./node_modules/@uirouter/core/lib/view/index.js\"));\n__export(__webpack_require__(/*! ./globals */ \"./node_modules/@uirouter/core/lib/globals.js\"));\n__export(__webpack_require__(/*! ./router */ \"./node_modules/@uirouter/core/lib/router.js\"));\n__export(__webpack_require__(/*! ./vanilla */ \"./node_modules/@uirouter/core/lib/vanilla.js\"));\n__export(__webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/interface.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbmRleC5qcz9jMzdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb24vaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1zL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGgvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybC9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92aWV3L2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcm91dGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGFcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/interface.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2ludGVyZmFjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaW50ZXJmYWNlLmpzPzE2MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICMgQ29yZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzXG4gKlxuICogVGhlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgdGhhdCBhcmUgY29yZSB0byB1aS1yb3V0ZXIgYW5kIGRvIG5vdCBiZWxvbmdcbiAqIHRvIGEgbW9yZSBzcGVjaWZpYyBzdWJzeXN0ZW0gKHN1Y2ggYXMgcmVzb2x2ZSkuXG4gKlxuICogQGNvcmVhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xudmFyIFVJUm91dGVyUGx1Z2luQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlSb3V0ZXJQbHVnaW5CYXNlKCkge1xuICAgIH1cbiAgICBVSVJvdXRlclBsdWdpbkJhc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7IH07XG4gICAgcmV0dXJuIFVJUm91dGVyUGx1Z2luQmFzZTtcbn0oKSk7XG5leHBvcnRzLlVJUm91dGVyUGx1Z2luQmFzZSA9IFVJUm91dGVyUGx1Z2luQmFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/interface.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./param */ \"./node_modules/@uirouter/core/lib/params/param.js\"));\n__export(__webpack_require__(/*! ./paramTypes */ \"./node_modules/@uirouter/core/lib/params/paramTypes.js\"));\n__export(__webpack_require__(/*! ./stateParams */ \"./node_modules/@uirouter/core/lib/params/stateParams.js\"));\n__export(__webpack_require__(/*! ./paramType */ \"./node_modules/@uirouter/core/lib/params/paramType.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL2luZGV4LmpzPzFmN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1UeXBlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVBhcmFtc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVR5cGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/params/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/param.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/param.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar paramType_1 = __webpack_require__(/*! ./paramType */ \"./node_modules/@uirouter/core/lib/params/paramType.js\");\n/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ var isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue['__cacheable'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") },\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            if (_this.config.$$fn['__cacheable']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val)\n                    return tuple.to;\n            }\n            return val;\n        };\n        value = replaceSpecialValues(value);\n        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtLmpzPzQwODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHBhcmFtc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBwYXJhbVR5cGVfMSA9IHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKTtcbi8qKiBAaGlkZGVuICovIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqIEBoaWRkZW4gKi8gdmFyIGlzU2hvcnRoYW5kID0gZnVuY3Rpb24gKGNmZykge1xuICAgIHJldHVybiBbXCJ2YWx1ZVwiLCBcInR5cGVcIiwgXCJzcXVhc2hcIiwgXCJhcnJheVwiLCBcImR5bmFtaWNcIl0uZmlsdGVyKGhhc093bi5iaW5kKGNmZyB8fCB7fSkpLmxlbmd0aCA9PT0gMDtcbn07XG4vKiogQGludGVybmFsYXBpICovXG52YXIgRGVmVHlwZTtcbihmdW5jdGlvbiAoRGVmVHlwZSkge1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIlBBVEhcIl0gPSAwXSA9IFwiUEFUSFwiO1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIlNFQVJDSFwiXSA9IDFdID0gXCJTRUFSQ0hcIjtcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJDT05GSUdcIl0gPSAyXSA9IFwiQ09ORklHXCI7XG59KShEZWZUeXBlID0gZXhwb3J0cy5EZWZUeXBlIHx8IChleHBvcnRzLkRlZlR5cGUgPSB7fSkpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjZmcpIHtcbiAgICBjZmcgPSBpc1Nob3J0aGFuZChjZmcpICYmIHsgdmFsdWU6IGNmZyB9IHx8IGNmZztcbiAgICBnZXRTdGF0aWNEZWZhdWx0VmFsdWVbJ19fY2FjaGVhYmxlJ10gPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGdldFN0YXRpY0RlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGNmZy52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjZmcsIHtcbiAgICAgICAgJCRmbjogcHJlZGljYXRlc18xLmlzSW5qZWN0YWJsZShjZmcudmFsdWUpID8gY2ZnLnZhbHVlIDogZ2V0U3RhdGljRGVmYXVsdFZhbHVlLFxuICAgIH0pO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoY2ZnLCB1cmxUeXBlLCBsb2NhdGlvbiwgaWQsIHBhcmFtVHlwZXMpIHtcbiAgICBpZiAoY2ZnLnR5cGUgJiYgdXJsVHlwZSAmJiB1cmxUeXBlLm5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbSAnXCIgKyBpZCArIFwiJyBoYXMgdHdvIHR5cGUgY29uZmlndXJhdGlvbnMuXCIpO1xuICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSA9PT0gJ3N0cmluZycgJiYgcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlKSlcbiAgICAgICAgcmV0dXJuIHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSk7XG4gICAgaWYgKHVybFR5cGUpXG4gICAgICAgIHJldHVybiB1cmxUeXBlO1xuICAgIGlmICghY2ZnLnR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsb2NhdGlvbiA9PT0gRGVmVHlwZS5DT05GSUcgPyBcImFueVwiIDpcbiAgICAgICAgICAgIGxvY2F0aW9uID09PSBEZWZUeXBlLlBBVEggPyBcInBhdGhcIiA6XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIID8gXCJxdWVyeVwiIDogXCJzdHJpbmdcIjtcbiAgICAgICAgcmV0dXJuIHBhcmFtVHlwZXMudHlwZSh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNmZy50eXBlIGluc3RhbmNlb2YgcGFyYW1UeXBlXzEuUGFyYW1UeXBlID8gY2ZnLnR5cGUgOiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIHJldHVybnMgZmFsc2UsIHRydWUsIG9yIHRoZSBzcXVhc2ggdmFsdWUgdG8gaW5kaWNhdGUgdGhlIFwiZGVmYXVsdCBwYXJhbWV0ZXIgdXJsIHNxdWFzaCBwb2xpY3lcIi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgZGVmYXVsdFBvbGljeSkge1xuICAgIHZhciBzcXVhc2ggPSBjb25maWcuc3F1YXNoO1xuICAgIGlmICghaXNPcHRpb25hbCB8fCBzcXVhc2ggPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHNxdWFzaCkgfHwgc3F1YXNoID09IG51bGwpXG4gICAgICAgIHJldHVybiBkZWZhdWx0UG9saWN5O1xuICAgIGlmIChzcXVhc2ggPT09IHRydWUgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgIHJldHVybiBzcXVhc2g7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcXVhc2ggcG9saWN5OiAnXCIgKyBzcXVhc2ggKyBcIicuIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgb3IgYXJiaXRyYXJ5IHN0cmluZ1wiKTtcbn1cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmZ1bmN0aW9uIGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCkge1xuICAgIHZhciByZXBsYWNlLCBjb25maWd1cmVkS2V5cywgZGVmYXVsdFBvbGljeSA9IFtcbiAgICAgICAgeyBmcm9tOiBcIlwiLCB0bzogKGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogXCJcIikgfSxcbiAgICAgICAgeyBmcm9tOiBudWxsLCB0bzogKGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogXCJcIikgfSxcbiAgICBdO1xuICAgIHJlcGxhY2UgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb25maWcucmVwbGFjZSkgPyBjb25maWcucmVwbGFjZSA6IFtdO1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3F1YXNoKSlcbiAgICAgICAgcmVwbGFjZS5wdXNoKHsgZnJvbTogc3F1YXNoLCB0bzogdW5kZWZpbmVkIH0pO1xuICAgIGNvbmZpZ3VyZWRLZXlzID0gY29tbW9uXzEubWFwKHJlcGxhY2UsIGhvZl8xLnByb3AoXCJmcm9tXCIpKTtcbiAgICByZXR1cm4gY29tbW9uXzEuZmlsdGVyKGRlZmF1bHRQb2xpY3ksIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBjb25maWd1cmVkS2V5cy5pbmRleE9mKGl0ZW0uZnJvbSkgPT09IC0xOyB9KS5jb25jYXQocmVwbGFjZSk7XG59XG4vKiogQGludGVybmFsYXBpICovXG52YXIgUGFyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcmFtKGlkLCB0eXBlLCBjb25maWcsIGxvY2F0aW9uLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xuICAgICAgICBjb25maWcgPSB1bndyYXBTaG9ydGhhbmQoY29uZmlnKTtcbiAgICAgICAgdHlwZSA9IGdldFR5cGUoY29uZmlnLCB0eXBlLCBsb2NhdGlvbiwgaWQsIHVybE1hdGNoZXJGYWN0b3J5LnBhcmFtVHlwZXMpO1xuICAgICAgICB2YXIgYXJyYXlNb2RlID0gZ2V0QXJyYXlNb2RlKCk7XG4gICAgICAgIHR5cGUgPSBhcnJheU1vZGUgPyB0eXBlLiRhc0FycmF5KGFycmF5TW9kZSwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKSA6IHR5cGU7XG4gICAgICAgIHZhciBpc09wdGlvbmFsID0gY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQgfHwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLmR5bmFtaWMpID8gISFjb25maWcuZHluYW1pYyA6ICEhdHlwZS5keW5hbWljO1xuICAgICAgICB2YXIgcmF3ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChjb25maWcucmF3KSA/ICEhY29uZmlnLnJhdyA6ICEhdHlwZS5yYXc7XG4gICAgICAgIHZhciBzcXVhc2ggPSBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsLCB1cmxNYXRjaGVyRmFjdG9yeS5kZWZhdWx0U3F1YXNoUG9saWN5KCkpO1xuICAgICAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XG4gICAgICAgIHZhciBpbmhlcml0ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChjb25maWcuaW5oZXJpdCkgPyAhIWNvbmZpZy5pbmhlcml0IDogISF0eXBlLmluaGVyaXQ7XG4gICAgICAgIC8vIGFycmF5IGNvbmZpZzogcGFyYW0gbmFtZSAocGFyYW1bXSkgb3ZlcnJpZGVzIGRlZmF1bHQgc2V0dGluZ3MuICBleHBsaWNpdCBjb25maWcgb3ZlcnJpZGVzIHBhcmFtIG5hbWUuXG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5TW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHRzID0geyBhcnJheTogKGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCA/IFwiYXV0b1wiIDogZmFsc2UpIH07XG4gICAgICAgICAgICB2YXIgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSA9IGlkLm1hdGNoKC9cXFtcXF0kLykgPyB7IGFycmF5OiB0cnVlIH0gOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoYXJyYXlEZWZhdWx0cywgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSwgY29uZmlnKS5hcnJheTtcbiAgICAgICAgfVxuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgeyBpZDogaWQsIHR5cGU6IHR5cGUsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaXNPcHRpb25hbDogaXNPcHRpb25hbCwgZHluYW1pYzogZHluYW1pYywgcmF3OiByYXcsIHNxdWFzaDogc3F1YXNoLCByZXBsYWNlOiByZXBsYWNlLCBpbmhlcml0OiBpbmhlcml0LCBhcnJheTogYXJyYXlNb2RlLCBjb25maWc6IGNvbmZpZyB9KTtcbiAgICB9XG4gICAgUGFyYW0ucHJvdG90eXBlLmlzRGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgJiYgdGhpcy50eXBlLmVxdWFscyh0aGlzLnZhbHVlKCksIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtJbnRlcm5hbF0gR2V0cyB0aGUgZGVjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIGlmIHRoZSB2YWx1ZSBpcyBkZWZpbmVkLCBvdGhlcndpc2UsIHJldHVybnMgdGhlXG4gICAgICogZGVmYXVsdCB2YWx1ZSwgd2hpY2ggbWF5IGJlIHRoZSByZXN1bHQgb2YgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBQYXJhbS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFtJbnRlcm5hbF0gR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcGFyYW1ldGVyLCB3aGljaCBtYXkgYmUgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBnZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlKVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5qZWN0YWJsZSBmdW5jdGlvbnMgY2Fubm90IGJlIGNhbGxlZCBhdCBjb25maWd1cmF0aW9uIHRpbWVcIik7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShfdGhpcy5jb25maWcuJCRmbik7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFfdGhpcy50eXBlLmlzKGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSAoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIikgZm9yIHBhcmFtZXRlciAnXCIgKyBfdGhpcy5pZCArIFwiJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgUGFyYW1UeXBlIChcIiArIF90aGlzLnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuJCRmblsnX19jYWNoZWFibGUnXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSA9IHsgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXBsYWNlU3BlY2lhbFZhbHVlcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5yZXBsYWNlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAodHVwbGUuZnJvbSA9PT0gdmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGUudG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VTcGVjaWFsVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXREZWZhdWx0VmFsdWUoKSA6IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS5pc1NlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgIH07XG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG4gICAgICAgIGlmICgocHJlZGljYXRlc18xLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgdGhpcy5pc09wdGlvbmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgbm90IG9mIHRoZSBjb3JyZWN0IFBhcmFtVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFBhcmFtVHlwZVxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXMobm9ybWFsaXplZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgUGFyYW1UeXBlJ3MgcmVnZXhwXG4gICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy50eXBlLmVuY29kZShub3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuICEocHJlZGljYXRlc18xLmlzU3RyaW5nKGVuY29kZWQpICYmICF0aGlzLnR5cGUucGF0dGVybi5leGVjKGVuY29kZWQpKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1BhcmFtOlwiICsgdGhpcy5pZCArIFwiIFwiICsgdGhpcy50eXBlICsgXCIgc3F1YXNoOiAnXCIgKyB0aGlzLnNxdWFzaCArIFwiJyBvcHRpb25hbDogXCIgKyB0aGlzLmlzT3B0aW9uYWwgKyBcIn1cIjtcbiAgICB9O1xuICAgIFBhcmFtLnZhbHVlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFyYW1zXzEgPSBwYXJhbXM7IF9pIDwgcGFyYW1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNfMVtfaV07XG4gICAgICAgICAgICBwYXJhbVZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1WYWx1ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBbW1BhcmFtXV0gb2JqZWN0cyB3aGljaCBoYXZlIGRpZmZlcmVudCBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEZpbHRlcnMgYSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIgaW4gdHdvIHBhcmFtIHZhbHVlIG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXM6IFRoZSBsaXN0IG9mIFBhcmFtIG9iamVjdHMgdG8gZmlsdGVyXG4gICAgICogQHBhcmFtIHZhbHVlczE6IFRoZSBmaXJzdCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqIEBwYXJhbSB2YWx1ZXMyOiB0aGUgc2Vjb25kIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbnkgUGFyYW0gb2JqZWN0cyB3aG9zZSB2YWx1ZXMgd2VyZSBkaWZmZXJlbnQgYmV0d2VlbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyXG4gICAgICovXG4gICAgUGFyYW0uY2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udHlwZS5lcXVhbHModmFsdWVzMVtwYXJhbS5pZF0sIHZhbHVlczJbcGFyYW0uaWRdKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIHBhcmFtIHZhbHVlIG9iamVjdHMgYXJlIGVxdWFsIChmb3IgYSBzZXQgb2YgW1tQYXJhbV1dIG9iamVjdHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHZhbHVlczEgVGhlIGZpcnN0IHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzMiBUaGUgc2Vjb25kIHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtIHZhbHVlcyBpbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyIGFyZSBlcXVhbFxuICAgICAqL1xuICAgIFBhcmFtLmVxdWFscyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIFBhcmFtLmNoYW5nZWQocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKS5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHZhbGlkLCBhY2NvcmRpbmcgdG8gdGhlIFBhcmFtIGRlZmluaXRpb25zICovXG4gICAgUGFyYW0udmFsaWRhdGVzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhbTtcbn0oKSk7XG5leHBvcnRzLlBhcmFtID0gUGFyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/params/param.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/paramType.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/paramType.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGUuanM/ZDYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICpcbiAqIEEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gaXMgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMuXG4gKiBXaGVuIGEgcGFyYW0gdHlwZSBkZWZpbml0aW9uIGlzIHJlZ2lzdGVyZWQsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICpcbiAqIFRoaXMgY2xhc3MgaGFzIG5haXZlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxsIHRoZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBtZXRob2RzLlxuICpcbiAqIFVzZWQgYnkgW1tVcmxNYXRjaGVyXV0gd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyYW1UeXBlRGVmID0ge1xuICogICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxuICogICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBhbmd1bGFyLmlzTnVtYmVyKHZhbCkgJiYgaXNGaW5pdGUodmFsKSAmJiB2YWwgJSAxID09PSAwOyB9LFxuICogICBwYXR0ZXJuOiAvXFxkKy9cbiAqIH1cbiAqXG4gKiB2YXIgcGFyYW1UeXBlID0gbmV3IFBhcmFtVHlwZShwYXJhbVR5cGVEZWYpO1xuICogYGBgXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIFBhcmFtVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRlZiAgQSBjb25maWd1cmF0aW9uIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY3VzdG9tIHR5cGUgZGVmaW5pdGlvbi4gIFRoZSBvYmplY3Qnc1xuICAgICAqICAgICAgICBwcm9wZXJ0aWVzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kcyBhbmQvb3IgcGF0dGVybiBpbiBgUGFyYW1UeXBlYCdzIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAgICogQHJldHVybnMgYSBuZXcgUGFyYW1UeXBlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcmFtVHlwZShkZWYpIHtcbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRoaXMucGF0dGVybiA9IC8uKi87XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0aGlzLmluaGVyaXQgPSB0cnVlO1xuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgZGVmKTtcbiAgICB9XG4gICAgLy8gY29uc2lkZXIgdGhlc2UgZm91ciBtZXRob2RzIHRvIGJlIFwiYWJzdHJhY3QgbWV0aG9kc1wiIHRoYXQgc2hvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB0cnVlOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB2YWw7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09IGI7IH07XG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kc3ViUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG4gICAgfTtcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ7UGFyYW1UeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYW4gZW5jb2RlZCBzdHJpbmcsIG9yIGEgZGVjb2RlZCBvYmplY3QsIHJldHVybnMgYSBkZWNvZGVkIG9iamVjdCAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBjdXN0b20gUGFyYW1UeXBlIGFzIGFuIGFycmF5IG9mIFBhcmFtVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cbiAgICAgKiBlLmcuOlxuICAgICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcbiAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG4gICAgICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICAgICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICAgICAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJGFzQXJyYXkgPSBmdW5jdGlvbiAobW9kZSwgaXNTZWFyY2gpIHtcbiAgICAgICAgaWYgKCFtb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiAmJiAhaXNTZWFyY2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInYXV0bycgYXJyYXkgbW9kZSBpcyBmb3IgcXVlcnkgcGFyYW1ldGVycyBvbmx5XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5VHlwZSh0aGlzLCBtb2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhbVR5cGU7XG59KCkpO1xuZXhwb3J0cy5QYXJhbVR5cGUgPSBQYXJhbVR5cGU7XG4vKipcbiAqIFdyYXBzIHVwIGEgYFBhcmFtVHlwZWAgb2JqZWN0IHRvIGhhbmRsZSBhcnJheSB2YWx1ZXMuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZnVuY3Rpb24gQXJyYXlUeXBlKHR5cGUsIG1vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIFdyYXAgbm9uLWFycmF5IHZhbHVlIGFzIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlXcmFwKHZhbCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSA/IHZhbCA6IChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbCkgPyBbdmFsXSA6IFtdKTtcbiAgICB9XG4gICAgLy8gVW53cmFwIGFycmF5IHZhbHVlIGZvciBcImF1dG9cIiBtb2RlLiBSZXR1cm4gdW5kZWZpbmVkIGZvciBlbXB0eSBhcnJheS5cbiAgICBmdW5jdGlvbiBhcnJheVVud3JhcCh2YWwpIHtcbiAgICAgICAgc3dpdGNoICh2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBtb2RlID09PSBcImF1dG9cIiA/IHZhbFswXSA6IHZhbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5SGFuZGxlcihjYWxsYmFjaywgYWxsVHJ1dGh5TW9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB2YXIgYXJyID0gYXJyYXlXcmFwKHZhbCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbW9uXzEubWFwKGFyciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIChhbGxUcnV0aHlNb2RlID09PSB0cnVlKSA/IGNvbW1vbl8xLmZpbHRlcihyZXN1bHQsIGZ1bmN0aW9uICh4KSB7IHJldHVybiAheDsgfSkubGVuZ3RoID09PSAwIDogYXJyYXlVbndyYXAocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gV3JhcHMgdHlwZSAoLmVxdWFscykgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWxzSGFuZGxlcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsMSwgdmFsMikge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheVdyYXAodmFsMSksIHJpZ2h0ID0gYXJyYXlXcmFwKHZhbDIpO1xuICAgICAgICAgICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhsZWZ0W2ldLCByaWdodFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBbJ2VuY29kZScsICdkZWNvZGUnLCAnZXF1YWxzJywgJyRub3JtYWxpemUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwYXJhbVR5cGVGbiA9IHR5cGVbbmFtZV0uYmluZCh0eXBlKTtcbiAgICAgICAgdmFyIHdyYXBwZXJGbiA9IG5hbWUgPT09ICdlcXVhbHMnID8gYXJyYXlFcXVhbHNIYW5kbGVyIDogYXJyYXlIYW5kbGVyO1xuICAgICAgICBfdGhpc1tuYW1lXSA9IHdyYXBwZXJGbihwYXJhbVR5cGVGbik7XG4gICAgfSk7XG4gICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgZHluYW1pYzogdHlwZS5keW5hbWljLFxuICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgIHBhdHRlcm46IHR5cGUucGF0dGVybixcbiAgICAgICAgaW5oZXJpdDogdHlwZS5pbmhlcml0LFxuICAgICAgICBpczogYXJyYXlIYW5kbGVyKHR5cGUuaXMuYmluZCh0eXBlKSwgdHJ1ZSksXG4gICAgICAgICRhcnJheU1vZGU6IG1vZGVcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/params/paramType.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/paramTypes.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/paramTypes.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar paramType_1 = __webpack_require__(/*! ./paramType */ \"./node_modules/@uirouter/core/lib/params/paramType.js\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, [\"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\"]);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qcz83YTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcmFtVHlwZV8xID0gcmVxdWlyZShcIi4vcGFyYW1UeXBlXCIpO1xuLyoqXG4gKiBBIHJlZ2lzdHJ5IGZvciBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhpcyByZWdpc3RyeSBtYW5hZ2VzIHRoZSBidWlsdC1pbiAoYW5kIGN1c3RvbSkgcGFyYW1ldGVyIHR5cGVzLlxuICpcbiAqIFRoZSBidWlsdC1pbiBwYXJhbWV0ZXIgdHlwZXMgYXJlOlxuICpcbiAqIC0gW1tzdHJpbmddXVxuICogLSBbW3BhdGhdXVxuICogLSBbW3F1ZXJ5XV1cbiAqIC0gW1toYXNoXV1cbiAqIC0gW1tpbnRdXVxuICogLSBbW2Jvb2xdXVxuICogLSBbW2RhdGVdXVxuICogLSBbW2pzb25dXVxuICogLSBbW2FueV1dXG4gKi9cbnZhciBQYXJhbVR5cGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgZnVuY3Rpb24gUGFyYW1UeXBlcygpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5lbnF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy50eXBlUXVldWUgPSBbXTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRUeXBlcyA9IGNvbW1vbl8xLnBpY2soUGFyYW1UeXBlcy5wcm90b3R5cGUsIFtcImhhc2hcIiwgXCJzdHJpbmdcIiwgXCJxdWVyeVwiLCBcInBhdGhcIiwgXCJpbnRcIiwgXCJib29sXCIsIFwiZGF0ZVwiLCBcImpzb25cIiwgXCJhbnlcIl0pO1xuICAgICAgICAvLyBSZWdpc3RlciBkZWZhdWx0IHR5cGVzLiBTdG9yZSB0aGVtIGluIHRoZSBwcm90b3R5cGUgb2YgdGhpcy50eXBlcy5cbiAgICAgICAgdmFyIG1ha2VUeXBlID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1UeXBlXzEuUGFyYW1UeXBlKGNvbW1vbl8xLmV4dGVuZCh7IG5hbWU6IG5hbWUgfSwgZGVmaW5pdGlvbikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnR5cGVzID0gY29tbW9uXzEuaW5oZXJpdChjb21tb25fMS5tYXAodGhpcy5kZWZhdWx0VHlwZXMsIG1ha2VUeXBlKSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgUGFyYW1UeXBlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHt9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgcGFyYW1ldGVyIHR5cGVcbiAgICAgKlxuICAgICAqIEVuZCB1c2VycyBzaG91bGQgY2FsbCBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSwgd2hpY2ggZGVsZWdhdGVzIHRvIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChkZWZpbml0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVzW25hbWVdO1xuICAgICAgICBpZiAodGhpcy50eXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgdHlwZSBuYW1lZCAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5cIik7XG4gICAgICAgIHRoaXMudHlwZXNbbmFtZV0gPSBuZXcgcGFyYW1UeXBlXzEuUGFyYW1UeXBlKGNvbW1vbl8xLmV4dGVuZCh7IG5hbWU6IG5hbWUgfSwgZGVmaW5pdGlvbikpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbkZuKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVRdWV1ZS5wdXNoKHsgbmFtZTogbmFtZSwgZGVmOiBkZWZpbml0aW9uRm4gfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5xdWV1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFR5cGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLl9mbHVzaFR5cGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMudHlwZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHR5cGUucGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IG92ZXJyaWRlIGEgdHlwZSdzIC5wYXR0ZXJuIGF0IHJ1bnRpbWUuXCIpO1xuICAgICAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMudHlwZXNbdHlwZS5uYW1lXSwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZSh0eXBlLmRlZikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYW1UeXBlcztcbn0oKSk7XG5leHBvcnRzLlBhcmFtVHlwZXMgPSBQYXJhbVR5cGVzO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGluaXREZWZhdWx0VHlwZXMoKSB7XG4gICAgdmFyIG1ha2VEZWZhdWx0VHlwZSA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgdmFyIHZhbFRvU3RyaW5nID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsLnRvU3RyaW5nKCkgOiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZWZhdWx0VHlwZUJhc2UgPSB7XG4gICAgICAgICAgICBlbmNvZGU6IHZhbFRvU3RyaW5nLFxuICAgICAgICAgICAgZGVjb2RlOiB2YWxUb1N0cmluZyxcbiAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhTdHJpbmcpLFxuICAgICAgICAgICAgcGF0dGVybjogLy4qLyxcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT0gYjsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgZGVmYXVsdFR5cGVCYXNlLCBkZWYpO1xuICAgIH07XG4gICAgLy8gRGVmYXVsdCBQYXJhbWV0ZXIgVHlwZSBEZWZpbml0aW9uc1xuICAgIGNvbW1vbl8xLmV4dGVuZChQYXJhbVR5cGVzLnByb3RvdHlwZSwge1xuICAgICAgICBzdHJpbmc6IG1ha2VEZWZhdWx0VHlwZSh7fSksXG4gICAgICAgIHBhdGg6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvW14vXSovLFxuICAgICAgICB9KSxcbiAgICAgICAgcXVlcnk6IG1ha2VEZWZhdWx0VHlwZSh7fSksXG4gICAgICAgIGhhc2g6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgfSksXG4gICAgICAgIGludDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcHJlZGljYXRlc18xLmlzTnVsbE9yVW5kZWZpbmVkKHZhbCkgJiYgdGhpcy5kZWNvZGUodmFsLnRvU3RyaW5nKCkpID09PSB2YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0dGVybjogLy0/XFxkKy8sXG4gICAgICAgIH0pLFxuICAgICAgICBib29sOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgJiYgMSB8fCAwOyB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKSAhPT0gMDsgfSxcbiAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhCb29sZWFuKSxcbiAgICAgICAgICAgIHBhdHRlcm46IC8wfDEvXG4gICAgICAgIH0pLFxuICAgICAgICBkYXRlOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzKHZhbCkgPyB1bmRlZmluZWQgOiBbXG4gICAgICAgICAgICAgICAgICAgIHZhbC5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAgICAgICAgICAgKCcwJyArIHZhbC5nZXREYXRlKCkpLnNsaWNlKC0yKVxuICAgICAgICAgICAgICAgIF0uam9pbihcIi1cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXModmFsKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLmNhcHR1cmUuZXhlYyh2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG5ldyBEYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSAtIDEsIG1hdGNoWzNdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsLnZhbHVlT2YoKSk7IH0sXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZ2V0RnVsbFllYXInLCAnZ2V0TW9udGgnLCAnZ2V0RGF0ZSddXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZm4pIHsgcmV0dXJuIGFjYyAmJiBsW2ZuXSgpID09PSByW2ZuXSgpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAvWzAtOV17NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgICAgICAgICBjYXB0dXJlOiAvKFswLTldezR9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMS0yXVswLTldfDNbMC0xXSkvXG4gICAgICAgIH0pLFxuICAgICAgICBqc29uOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS50b0pzb24sXG4gICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmZyb21Kc29uLFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKE9iamVjdCksXG4gICAgICAgICAgICBlcXVhbHM6IGNvbW1vbl8xLmVxdWFscyxcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi9cbiAgICAgICAgfSksXG4gICAgICAgIC8vIGRvZXMgbm90IGVuY29kZS9kZWNvZGVcbiAgICAgICAgYW55OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS5pZGVudGl0eSxcbiAgICAgICAgICAgIGRlY29kZTogY29tbW9uXzEuaWRlbnRpdHksXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIGVxdWFsczogY29tbW9uXzEuZXF1YWxzLFxuICAgICAgICB9KSxcbiAgICB9KTtcbn1cbmluaXREZWZhdWx0VHlwZXMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/params/paramTypes.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/stateParams.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/stateParams.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\n/** @internalapi */\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3N0YXRlUGFyYW1zLmpzPzE3NTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHBhcmFtc1xuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xudmFyIFN0YXRlUGFyYW1zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBzZXQgb2YgcGFyYW1ldGVycyB3aXRoIGFsbCBwYXJhbWV0ZXJzIGluaGVyaXRlZCBiZXR3ZWVuIHRoZSBjb21tb24gcGFyZW50cyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG4gICAgICovXG4gICAgU3RhdGVQYXJhbXMucHJvdG90eXBlLiRpbmhlcml0ID0gZnVuY3Rpb24gKG5ld1BhcmFtcywgJGN1cnJlbnQsICR0bykge1xuICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwYXJlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudHNbaV0gfHwgIXBhcmVudHNbaV0ucGFyYW1zKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcGFyZW50UGFyYW1zID0gT2JqZWN0LmtleXMocGFyZW50c1tpXS5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRQYXJhbXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwYXJlbnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdExpc3QuaW5kZXhPZihwYXJlbnRQYXJhbXNbal0pID49IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGluaGVyaXRMaXN0LnB1c2gocGFyZW50UGFyYW1zW2pdKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRbcGFyZW50UGFyYW1zW2pdXSA9IHRoaXNbcGFyZW50UGFyYW1zW2pdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBpbmhlcml0ZWQsIG5ld1BhcmFtcyk7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIFN0YXRlUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVQYXJhbXMgPSBTdGF0ZVBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUGFyYW1zLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/params/stateParams.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\n__export(__webpack_require__(/*! ./pathNode */ \"./node_modules/@uirouter/core/lib/path/pathNode.js\"));\n__export(__webpack_require__(/*! ./pathFactory */ \"./node_modules/@uirouter/core/lib/path/pathFactory.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvaW5kZXguanM/YWFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vcGF0aE5vZGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGF0aEZhY3RvcnlcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/path/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/pathFactory.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/pathFactory.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/** @module path */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\nvar pathNode_1 = __webpack_require__(/*! ./pathNode */ \"./node_modules/@uirouter/core/lib/path/pathNode.js\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = pathNode_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = common_1.arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathUtils;\n}());\nPathUtils.nonDynamicParams = function (node) {\n    return node.state.parameters({ inherit: false })\n        .filter(function (param) { return !param.dynamic; });\n};\n/** Gets the raw parameter values from a path */\nPathUtils.paramValues = function (path) {\n    return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});\n};\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=pathFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aEZhY3RvcnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aEZhY3RvcnkuanM/ZWMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG52YXIgcGF0aE5vZGVfMSA9IHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIGZ1bmN0aW9ucyB3aGljaCBjb252ZXJ0IFRhcmdldFN0YXRlcywgTm9kZXMgYW5kIHBhdGhzIGZyb20gb25lIHR5cGUgdG8gYW5vdGhlci5cbiAqL1xudmFyIFBhdGhVdGlscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aFV0aWxzKCkge1xuICAgIH1cbiAgICAvKiogR2l2ZW4gYSBQYXRoTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cbiAgICBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY29tbW9uXzEudGFpbChwYXRoKS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHN0YXRlLCBzdGF0ZSwgcGF0aC5tYXAoaG9mXzEucHJvcChcInBhcmFtVmFsdWVzXCIpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpO1xuICAgIH07XG4gICAgUGF0aFV0aWxzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXJhbXMgPSB0YXJnZXRTdGF0ZS5wYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlLiRzdGF0ZSgpLnBhdGgubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUoc3RhdGUpLmFwcGx5UmF3UGFyYW1zKHRvUGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogUGF0aE5vZGVbXSBhbmQgYSBUYXJnZXRTdGF0ZSwgYnVpbGRzIGEgdG9QYXRoOiBQYXRoTm9kZVtdICovXG4gICAgUGF0aFV0aWxzLmJ1aWxkVG9QYXRoID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZS5vcHRpb25zKCkuaW5oZXJpdCkge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGhVdGlscy5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGFuZCBhZGRzIHRvIG5vZGVzLlxuICAgICAqXG4gICAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAoJHZpZXcsIHBhdGgsIHN0YXRlcykge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcbiAgICAgICAgcGF0aC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoc3RhdGVzLCBub2RlLnN0YXRlKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHZpZXdEZWNscyA9IGNvbW1vbl8xLnZhbHVlcyhub2RlLnN0YXRlLnZpZXdzIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPT09IG5vZGU7IH0pO1xuICAgICAgICAgICAgdmFyIHZpZXdDb25maWdzID0gdmlld0RlY2xzLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gJHZpZXcuY3JlYXRlVmlld0NvbmZpZyhzdWJQYXRoLCB2aWV3KTsgfSk7XG4gICAgICAgICAgICBub2RlLnZpZXdzID0gdmlld0NvbmZpZ3MucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZyb21QYXRoIGFuZCBhIHRvUGF0aCwgcmV0dXJucyBhIG5ldyB0byBwYXRoIHdoaWNoIGluaGVyaXRzIHBhcmFtZXRlcnMgZnJvbSB0aGUgZnJvbVBhdGhcbiAgICAgKlxuICAgICAqIEZvciBhIHBhcmFtZXRlciBpbiBhIG5vZGUgdG8gYmUgaW5oZXJpdGVkIGZyb20gdGhlIGZyb20gcGF0aDpcbiAgICAgKiAtIFRoZSB0b1BhdGgncyBub2RlIG11c3QgaGF2ZSBhIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGZyb21QYXRoIChieSBzdGF0ZSkuXG4gICAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUga2V5cyBwcm92aWRlZCBpbiB0b0tleXMgYXJlIGludGVuZGVkIHRvIGJlIHRob3NlIHBhcmFtIGtleXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYnkgc29tZVxuICAgICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuICAgICAqIGl0IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbVBhdGguXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgdG9LZXlzKSB7XG4gICAgICAgIGlmICh0b0tleXMgPT09IHZvaWQgMCkgeyB0b0tleXMgPSBbXTsgfVxuICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBub2RlICYmIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub0luaGVyaXQgPSBmcm9tUGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pbmhlcml0OyB9KVxuICAgICAgICAgICAgLm1hcChob2ZfMS5wcm9wKCdpZCcpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIFtbUGF0aE5vZGVdXSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgW1tQYXRoTm9kZV1dIHdpdGggcGFyYW0gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBtYXRjaGluZyBub2RlIGluIGZyb21QYXRoLiAgT25seSBpbmhlcml0IGtleXMgdGhhdCBhcmVuJ3QgZm91bmQgaW4gXCJ0b0tleXNcIiBmcm9tIHRoZSBub2RlIGluIFwiZnJvbVBhdGhcIlwiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSh0b05vZGUpIHtcbiAgICAgICAgICAgIC8vIEFsbCBwYXJhbSB2YWx1ZXMgZm9yIHRoZSBub2RlIChtYXkgaW5jbHVkZSBkZWZhdWx0IGtleS92YWxzLCB3aGVuIGtleSB3YXMgbm90IGZvdW5kIGluIHRvUGFyYW1zKVxuICAgICAgICAgICAgdmFyIHRvUGFyYW1WYWxzID0gY29tbW9uXzEuZXh0ZW5kKHt9LCB0b05vZGUgJiYgdG9Ob2RlLnBhcmFtVmFsdWVzKTtcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gb25seSB0aG9zZSBrZXlzIGZvdW5kIGluIHRvUGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5jb21pbmdQYXJhbVZhbHMgPSBjb21tb25fMS5waWNrKHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdmFyIGZyb21QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KG5vZGVQYXJhbVZhbHMoZnJvbVBhdGgsIHRvTm9kZS5zdGF0ZSkgfHwge30sIG5vSW5oZXJpdCk7XG4gICAgICAgICAgICAvLyBleHRlbmQgdG9QYXJhbVZhbHMgd2l0aCBhbnkgZnJvbVBhcmFtVmFscywgdGhlbiBvdmVycmlkZSBhbnkgb2YgdGhvc2UgdGhvc2Ugd2l0aCBpbmNvbWluZ1BhcmFtVmFsc1xuICAgICAgICAgICAgdmFyIG93blBhcmFtVmFscyA9IGNvbW1vbl8xLmV4dGVuZCh0b1BhcmFtVmFscywgZnJvbVBhcmFtVmFscywgaW5jb21pbmdQYXJhbVZhbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcGFyYW0ga2V5cyBzcGVjaWZpZWQgYnkgdGhlIGluY29taW5nIHRvUGFyYW1zXG4gICAgICAgIHJldHVybiB0b1BhdGgubWFwKG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB0cmVlIGNoYW5nZXMgKGVudGVyaW5nLCBleGl0aW5nKSBiZXR3ZWVuIGEgZnJvbVBhdGggYW5kIHRvUGF0aC5cbiAgICAgKi9cbiAgICBQYXRoVXRpbHMudHJlZUNoYW5nZXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgcmVsb2FkU3RhdGUpIHtcbiAgICAgICAgdmFyIGtlZXAgPSAwLCBtYXggPSBNYXRoLm1pbihmcm9tUGF0aC5sZW5ndGgsIHRvUGF0aC5sZW5ndGgpO1xuICAgICAgICB2YXIgbm9kZXNNYXRjaCA9IGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMS5lcXVhbHMobm9kZTIsIFBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXggJiYgZnJvbVBhdGhba2VlcF0uc3RhdGUgIT09IHJlbG9hZFN0YXRlICYmIG5vZGVzTWF0Y2goZnJvbVBhdGhba2VlcF0sIHRvUGF0aFtrZWVwXSkpIHtcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgfVxuICAgICAgICAvKiogR2l2ZW4gYSByZXRhaW5lZCBub2RlLCByZXR1cm4gYSBuZXcgbm9kZSB3aGljaCB1c2VzIHRoZSB0byBub2RlJ3MgcGFyYW0gdmFsdWVzICovXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VG9QYXJhbXMocmV0YWluZWROb2RlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSBwYXRoTm9kZV8xLlBhdGhOb2RlLmNsb25lKHJldGFpbmVkTm9kZSk7XG4gICAgICAgICAgICBjbG9uZWQucGFyYW1WYWx1ZXMgPSB0b1BhdGhbaWR4XS5wYXJhbVZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb20sIHJldGFpbmVkLCBleGl0aW5nLCBlbnRlcmluZywgdG87XG4gICAgICAgIGZyb20gPSBmcm9tUGF0aDtcbiAgICAgICAgcmV0YWluZWQgPSBmcm9tLnNsaWNlKDAsIGtlZXApO1xuICAgICAgICBleGl0aW5nID0gZnJvbS5zbGljZShrZWVwKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJldGFpbmVkIHBhdGggKHdpdGggc2hhbGxvdyBjb3BpZXMgb2Ygbm9kZXMpIHdoaWNoIGhhdmUgdGhlIHBhcmFtcyBvZiB0aGUgdG9QYXRoIG1hcHBlZFxuICAgICAgICB2YXIgcmV0YWluZWRXaXRoVG9QYXJhbXMgPSByZXRhaW5lZC5tYXAoYXBwbHlUb1BhcmFtcyk7XG4gICAgICAgIGVudGVyaW5nID0gdG9QYXRoLnNsaWNlKGtlZXApO1xuICAgICAgICB0byA9IChyZXRhaW5lZFdpdGhUb1BhcmFtcykuY29uY2F0KGVudGVyaW5nKTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvLCByZXRhaW5lZDogcmV0YWluZWQsIGV4aXRpbmc6IGV4aXRpbmcsIGVudGVyaW5nOiBlbnRlcmluZyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwYXRoIHdoaWNoIGlzOiB0aGUgc3VicGF0aCBvZiB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaGVzIHRoZSBzZWNvbmQgcGF0aC5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgcGF0aCBzdGFydHMgZnJvbSByb290IGFuZCBjb250YWlucyBhbnkgbm9kZXMgdGhhdCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoLlxuICAgICAqIEl0IHN0b3BzIGJlZm9yZSB0aGUgZmlyc3Qgbm9uLW1hdGNoaW5nIG5vZGUuXG4gICAgICpcbiAgICAgKiBOb2RlcyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlaXIgc3RhdGUgcHJvcGVydHkgYW5kIHRoZWlyIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICogSWYgYSBgcGFyYW1zRm5gIGlzIHByb3ZpZGVkLCBvbmx5IHRoZSBbW1BhcmFtXV0gcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZCB3aGVuIGNvbXBhcmluZyBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoQSB0aGUgZmlyc3QgcGF0aFxuICAgICAqIEBwYXJhbSBwYXRoQiB0aGUgc2Vjb25kIHBhdGhcbiAgICAgKiBAcGFyYW0gcGFyYW1zRm4gYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnNpZGVyIHdoZW4gY29tcGFyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBQYXRoTm9kZXMgZnJvbSB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoXG4gICAgICovXG4gICAgUGF0aFV0aWxzLm1hdGNoaW5nID0gZnVuY3Rpb24gKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR1cGxlcyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHBhdGhBLCBwYXRoQik7XG4gICAgICAgIHJldHVybiB0dXBsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGluZywgX2EpIHtcbiAgICAgICAgICAgIHZhciBub2RlQSA9IF9hWzBdLCBub2RlQiA9IF9hWzFdO1xuICAgICAgICAgICAgZG9uZSA9IGRvbmUgfHwgIW5vZGVBLmVxdWFscyhub2RlQiwgcGFyYW1zRm4pO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUgPyBtYXRjaGluZyA6IG1hdGNoaW5nLmNvbmNhdChub2RlQSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0d28gcGF0aHMgYXJlIGlkZW50aWNhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoQVxuICAgICAqIEBwYXJhbSBwYXRoQlxuICAgICAqIEBwYXJhbSBwYXJhbXNGbiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHBhcmFtZXRlcnMgdG8gY29uc2lkZXIgd2hlbiBjb21wYXJpbmdcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0aGUgc3RhdGVzIGFuZCBwYXJhbWV0ZXIgdmFsdWVzIGZvciBib3RoIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICAgKi9cbiAgICBQYXRoVXRpbHMuZXF1YWxzID0gZnVuY3Rpb24gKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gcGF0aEIubGVuZ3RoICYmXG4gICAgICAgICAgICBQYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikubGVuZ3RoID09PSBwYXRoQS5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdWJwYXRoIG9mIGEgcGF0aCwgd2hpY2ggc3RvcHMgYXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGVcbiAgICAgKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBhcnJheSBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBub2RlLFxuICAgICAqIHN0b3BwaW5nIHdoZW4gdGhlIGZpcnN0IG5vZGUgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggYSBwYXRoIG9mIFtbUGF0aE5vZGVdXXNcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGEgW1tQcmVkaWNhdGVdXSBmbiB0aGF0IG1hdGNoZXMgW1tQYXRoTm9kZV1dc1xuICAgICAqIEByZXR1cm5zIGEgc3VicGF0aCB1cCB0byB0aGUgbWF0Y2hpbmcgbm9kZSwgb3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAgICovXG4gICAgUGF0aFV0aWxzLnN1YlBhdGggPSBmdW5jdGlvbiAocGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBwcmVkaWNhdGUpO1xuICAgICAgICB2YXIgZWxlbWVudElkeCA9IHBhdGguaW5kZXhPZihub2RlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJZHggPT09IC0xID8gdW5kZWZpbmVkIDogcGF0aC5zbGljZSgwLCBlbGVtZW50SWR4ICsgMSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0aFV0aWxzO1xufSgpKTtcblBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5zdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5keW5hbWljOyB9KTtcbn07XG4vKiogR2V0cyB0aGUgcmF3IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSBhIHBhdGggKi9cblBhdGhVdGlscy5wYXJhbVZhbHVlcyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpOyB9LCB7fSk7XG59O1xuZXhwb3J0cy5QYXRoVXRpbHMgPSBQYXRoVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoRmFjdG9yeS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/path/pathFactory.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/pathNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/pathNode.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar param_1 = __webpack_require__(/*! ../params/param */ \"./node_modules/@uirouter/core/lib/params/param.js\");\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return param_1.Param.changed(params, this.paramValues, node.paramValues);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=pathNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aE5vZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aE5vZGUuanM/NmRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqXG4gKiBBIG5vZGUgaW4gYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aFxuICpcbiAqIEZvciBhIFtbVHJlZUNoYW5nZXNdXSBwYXRoLCB0aGlzIGNsYXNzIGhvbGRzIHRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBmb3IgYSBzaW5nbGUgbm9kZSBpbiB0aGUgcGF0aC5cbiAqIEVhY2ggUGF0aE5vZGUgY29ycmVzcG9uZHMgdG8gYSBzdGF0ZSBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIG9yIHJldGFpbmVkLlxuICogVGhlIHN0YXRlZnVsIGluZm9ybWF0aW9uIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHJlc29sdmUgZGF0YS5cbiAqL1xudmFyIFBhdGhOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoTm9kZShzdGF0ZU9yTm9kZSkge1xuICAgICAgICBpZiAoc3RhdGVPck5vZGUgaW5zdGFuY2VvZiBQYXRoTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZU9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IG5vZGUucGFyYW1TY2hlbWEuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3MgPSBub2RlLnZpZXdzICYmIG5vZGUudmlld3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsb25lKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5hcHBseVJhd1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGdldFBhcmFtVmFsID0gZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBbcGFyYW1EZWYuaWQsIHBhcmFtRGVmLnZhbHVlKHBhcmFtc1twYXJhbURlZi5pZF0pXTsgfTtcbiAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwRGVmKSB7IHJldHVybiBjb21tb25fMS5hcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKTsgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLnBhcmFtU2NoZW1hLCBob2ZfMS5wcm9wRXEoXCJpZFwiLCBuYW1lKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYW5vdGhlciBQYXRoTm9kZSBhcmVcbiAgICAgKiBlcXVhbCB0byB0aGUgc3RhdGUgYW5kIHBhcmFtIHZhbHVlcyBmb3IgdGhpcyBQYXRoTm9kZVxuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zRm4pIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYobm9kZSwgcGFyYW1zRm4pO1xuICAgICAgICByZXR1cm4gZGlmZiAmJiBkaWZmLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIFBhcmFtcyB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXIgdmFsdWVzIG9uIGFub3RoZXIgUGF0aE5vZGUuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgKG9mIHRoZSBzYW1lIHN0YXRlKSwgZmluZHMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggZGlmZmVyLlxuICAgICAqIFJldHVybnMgdGhlIFtbUGFyYW1dXSAoc2NoZW1hIG9iamVjdHMpIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyLlxuICAgICAqXG4gICAgICogR2l2ZW4gYW5vdGhlciBub2RlIGZvciBhIGRpZmZlcmVudCBzdGF0ZSwgcmV0dXJucyBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjb21wYXJlIHRvXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoaWNoIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGNvbXBhcmVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1BhcmFtXV1zIHdoaWNoIGRpZmZlciwgb3IgbnVsbCBpZiB0aGUgdHdvIG5vZGVzIGFyZSBmb3IgZGlmZmVyZW50IHN0YXRlc1xuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBub2RlLnN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGFyYW1zID0gcGFyYW1zRm4gPyBwYXJhbXNGbih0aGlzKSA6IHRoaXMucGFyYW1TY2hlbWE7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmNoYW5nZWQocGFyYW1zLCB0aGlzLnBhcmFtVmFsdWVzLCBub2RlLnBhcmFtVmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlICovXG4gICAgUGF0aE5vZGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhOb2RlKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhOb2RlO1xufSgpKTtcbmV4cG9ydHMuUGF0aE5vZGUgPSBQYXRoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhOb2RlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/path/pathNode.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */ /** for typedoc */\n__export(__webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/resolve/interface.js\"));\n__export(__webpack_require__(/*! ./resolvable */ \"./node_modules/@uirouter/core/lib/resolve/resolvable.js\"));\n__export(__webpack_require__(/*! ./resolveContext */ \"./node_modules/@uirouter/core/lib/resolve/resolveContext.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW5kZXguanM/NjY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSByZXNvbHZlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmFibGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZUNvbnRleHRcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/resolve/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/interface.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/interface.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW50ZXJmYWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2ludGVyZmFjZS5qcz9hZGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0cy5yZXNvbHZlUG9saWNpZXMgPSB7XG4gICAgd2hlbjoge1xuICAgICAgICBMQVpZOiBcIkxBWllcIixcbiAgICAgICAgRUFHRVI6IFwiRUFHRVJcIlxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgICAgV0FJVDogXCJXQUlUXCIsXG4gICAgICAgIE5PV0FJVDogXCJOT1dBSVRcIixcbiAgICAgICAgUlhXQUlUOiBcIlJYV0FJVFwiXG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/resolve/interface.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/resolvable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/resolvable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2YWJsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9yZXNvbHZhYmxlLmpzPzcyZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHJlc29sdmVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8vIFRPRE86IGV4cGxpY2l0bHkgbWFrZSB0aGlzIHVzZXIgY29uZmlndXJhYmxlXG5leHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5ID0ge1xuICAgIHdoZW46IFwiTEFaWVwiLFxuICAgIGFzeW5jOiBcIldBSVRcIlxufTtcbi8qKlxuICogVGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIGZvciB0aGUgcmVzb2x2ZSBzeXN0ZW0uXG4gKlxuICogUmVzb2x2YWJsZXMgZW5jYXBzdWxhdGUgYSBzdGF0ZSdzIHJlc29sdmUncyByZXNvbHZlRm4sIHRoZSByZXNvbHZlRm4ncyBkZWNsYXJlZCBkZXBlbmRlbmNpZXMsIHRoZSB3cmFwcGVkICgucHJvbWlzZSksXG4gKiBhbmQgdGhlIHVud3JhcHBlZC13aGVuLWNvbXBsZXRlICguZGF0YSkgcmVzdWx0IG9mIHRoZSByZXNvbHZlRm4uXG4gKlxuICogUmVzb2x2YWJsZS5nZXQoKSBlaXRoZXIgcmV0cmlldmVzIHRoZSBSZXNvbHZhYmxlJ3MgZXhpc3RpbmcgcHJvbWlzZSwgb3IgZWxzZSBpbnZva2VzIHJlc29sdmUoKSAod2hpY2ggaW52b2tlcyB0aGVcbiAqIHJlc29sdmVGbikgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBwcm9taXNlLlxuICpcbiAqIFJlc29sdmFibGUuZ2V0KCkgYW5kIFJlc29sdmFibGUucmVzb2x2ZSgpIGJvdGggZXhlY3V0ZSB3aXRoaW4gYSBjb250ZXh0IHBhdGgsIHdoaWNoIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3RcbiAqIHBhcmFtZXRlciB0byB0aG9zZSBmbnMuXG4gKi9cbnZhciBSZXNvbHZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZhYmxlKGFyZzEsIHJlc29sdmVGbiwgZGVwcywgcG9saWN5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFJlc29sdmFibGUpIHtcbiAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBhcmcxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSA9PSBudWxsIHx8IGFyZzEgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldyBSZXNvbHZhYmxlKCk6IHRva2VuIGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldyBSZXNvbHZhYmxlKCk6IHJlc29sdmVGbiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gYXJnMTtcbiAgICAgICAgICAgIHRoaXMucG9saWN5ID0gcG9saWN5O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRm4gPSByZXNvbHZlRm47XG4gICAgICAgICAgICB0aGlzLmRlcHMgPSBkZXBzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnJlc29sdmVkID8gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbih0aGlzLmRhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZXNfMS5pc09iamVjdChhcmcxKSAmJiBhcmcxLnRva2VuICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGFyZzEucmVzb2x2ZUZuKSkge1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBhcmcxO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKGxpdGVyYWwudG9rZW4sIGxpdGVyYWwucmVzb2x2ZUZuLCBsaXRlcmFsLmRlcHMsIGxpdGVyYWwucG9saWN5LCBsaXRlcmFsLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGhpc1BvbGljeSA9IHRoaXMucG9saWN5IHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGVQb2xpY3kgPSBzdGF0ZSAmJiBzdGF0ZS5yZXNvbHZlUG9saWN5IHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2hlbjogdGhpc1BvbGljeS53aGVuIHx8IHN0YXRlUG9saWN5LndoZW4gfHwgZXhwb3J0cy5kZWZhdWx0UmVzb2x2ZVBvbGljeS53aGVuLFxuICAgICAgICAgICAgYXN5bmM6IHRoaXNQb2xpY3kuYXN5bmMgfHwgc3RhdGVQb2xpY3kuYXN5bmMgfHwgZXhwb3J0cy5kZWZhdWx0UmVzb2x2ZVBvbGljeS5hc3luYyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBSZXNvbHZlQ29udGV4dCB0aGF0IHRoaXMgUmVzb2x2YWJsZSBpcyBmb3VuZCBpbjpcbiAgICAgKiBXYWl0IGZvciB0aGlzIFJlc29sdmFibGUncyBkZXBlbmRlbmNpZXMsIHRoZW4gaW52b2tlIHRoaXMgUmVzb2x2YWJsZSdzIGZ1bmN0aW9uXG4gICAgICogYW5kIHVwZGF0ZSB0aGUgUmVzb2x2YWJsZSdzIHN0YXRlXG4gICAgICovXG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgICAgIC8vIEdldHMgYWxsIGRlcGVuZGVuY2llcyBmcm9tIFJlc29sdmVDb250ZXh0IGFuZCB3YWl0IGZvciB0aGVtIHRvIGJlIHJlc29sdmVkXG4gICAgICAgIHZhciBnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChyZXNvbHZlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoX3RoaXMpLm1hcChmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgdHJhbnMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbnZva2VzIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyBhcyBhcmd1bWVudHNcbiAgICAgICAgdmFyIGludm9rZVJlc29sdmVGbiA9IGZ1bmN0aW9uIChyZXNvbHZlZERlcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlRm4uYXBwbHkobnVsbCwgcmVzb2x2ZWREZXBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBSWFdBSVQgcG9saWN5OlxuICAgICAgICAgKlxuICAgICAgICAgKiBHaXZlbiBhbiBvYnNlcnZhYmxlIHJldHVybmVkIGZyb20gYSByZXNvbHZlIGZ1bmN0aW9uOlxuICAgICAgICAgKiAtIGVuYWJsZXMgLmNhY2hlKCkgbW9kZSAodGhpcyBhbGxvd3MgbXVsdGljYXN0IHN1YnNjcmliZXJzKVxuICAgICAgICAgKiAtIHRoZW4gY2FsbHMgdG9Qcm9taXNlKCkgKHRoaXMgdHJpZ2dlcnMgc3Vic2NyaWJlKCkgYW5kIHRodXMgZmV0Y2hlcylcbiAgICAgICAgICogLSBXYWl0cyBmb3IgdGhlIHByb21pc2UsIHRoZW4gcmV0dXJuIHRoZSBjYWNoZWQgb2JzZXJ2YWJsZSAobm90IHRoZSBmaXJzdCBlbWl0dGVkIHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB3YWl0Rm9yUnggPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSQpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBvYnNlcnZhYmxlJC5jYWNoZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQudGFrZSgxKS50b1Byb21pc2UoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZDsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHRoZSByZXNvbHZlIHBvbGljeSBpcyBSWFdBSVQsIHdhaXQgZm9yIHRoZSBvYnNlcnZhYmxlIHRvIGVtaXQgc29tZXRoaW5nLiBvdGhlcndpc2UgcGFzcyB0aHJvdWdoLlxuICAgICAgICB2YXIgbm9kZSA9IHJlc29sdmVDb250ZXh0LmZpbmROb2RlKHRoaXMpO1xuICAgICAgICB2YXIgc3RhdGUgPSBub2RlICYmIG5vZGUuc3RhdGU7XG4gICAgICAgIHZhciBtYXliZVdhaXRGb3JSeCA9IHRoaXMuZ2V0UG9saWN5KHN0YXRlKS5hc3luYyA9PT0gXCJSWFdBSVRcIiA/IHdhaXRGb3JSeCA6IGNvbW1vbl8xLmlkZW50aXR5O1xuICAgICAgICAvLyBBZnRlciB0aGUgZmluYWwgdmFsdWUgaGFzIGJlZW4gcmVzb2x2ZWQsIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIFJlc29sdmFibGVcbiAgICAgICAgdmFyIGFwcGx5UmVzb2x2ZWRWYWx1ZSA9IGZ1bmN0aW9uIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQoX3RoaXMsIHRyYW5zKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTZXRzIHRoZSBwcm9taXNlIHByb3BlcnR5IGZpcnN0LCB0aGVuIGdldHNSZXNvbHZhYmxlRGVwZW5kZW5jaWVzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm9taXNlIGNoYWluLiBBbHdheXMgd2FpdHMgb25lIHRpY2suXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UgPSAkcS53aGVuKClcbiAgICAgICAgICAgIC50aGVuKGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICAudGhlbihpbnZva2VSZXNvbHZlRm4pXG4gICAgICAgICAgICAudGhlbihtYXliZVdhaXRGb3JSeClcbiAgICAgICAgICAgIC50aGVuKGFwcGx5UmVzb2x2ZWRWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcHJvbWlzZSBmb3IgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YS5cbiAgICAgKlxuICAgICAqIEZldGNoZXMgdGhlIGRhdGEgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICAgICAqIFJldHVybnMgdGhlIGV4aXN0aW5nIHByb21pc2UgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBmZXRjaGVkIG9uY2UuXG4gICAgICovXG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJlc29sdmVDb250ZXh0LCB0cmFucykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlIHx8IHRoaXMucmVzb2x2ZShyZXNvbHZlQ29udGV4dCwgdHJhbnMpO1xuICAgIH07XG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJlc29sdmFibGUodG9rZW46IFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0aGlzLnRva2VuKSArIFwiLCByZXF1aXJlczogW1wiICsgdGhpcy5kZXBzLm1hcChzdHJpbmdzXzEuc3RyaW5naWZ5KSArIFwiXSlcIjtcbiAgICB9O1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmFibGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzb2x2YWJsZTtcbn0oKSk7XG5SZXNvbHZhYmxlLmZyb21EYXRhID0gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRva2VuLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhOyB9LCBudWxsLCBudWxsLCBkYXRhKTtcbn07XG5leHBvcnRzLlJlc29sdmFibGUgPSBSZXNvbHZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2YWJsZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/resolve/resolvable.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/resolveContext.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/resolve/interface.js\");\nvar resolvable_1 = __webpack_require__(/*! ./resolvable */ \"./node_modules/@uirouter/core/lib/resolve/resolvable.js\");\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ \"./node_modules/@uirouter/core/lib/path/pathFactory.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQuanM/YTRjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHJlc29sdmUgKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmFibGVcIik7XG52YXIgcGF0aEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhGYWN0b3J5XCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciB3aGVuID0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW47XG52YXIgQUxMX1dIRU5TID0gW3doZW4uRUFHRVIsIHdoZW4uTEFaWV07XG52YXIgRUFHRVJfV0hFTlMgPSBbd2hlbi5FQUdFUl07XG5leHBvcnRzLk5BVElWRV9JTkpFQ1RPUl9UT0tFTiA9IFwiTmF0aXZlIEluamVjdG9yXCI7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBEZXBlbmRlbmN5IEluamVjdGlvbiBmb3IgYSBwYXRoIG9mIG5vZGVzXG4gKlxuICogVUktUm91dGVyIHN0YXRlcyBhcmUgb3JnYW5pemVkIGFzIGEgdHJlZS5cbiAqIEEgbmVzdGVkIHN0YXRlIGhhcyBhIHBhdGggb2YgYW5jZXN0b3JzIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICogV2hlbiBhIHN0YXRlIGlzIGJlaW5nIGFjdGl2YXRlZCwgZWFjaCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHdyYXBwZWQgYXMgYSBbW1BhdGhOb2RlXV0uXG4gKiBBIGBQYXRoTm9kZWAgaXMgYSBzdGF0ZWZ1bCBvYmplY3QgdGhhdCBob2xkcyB0aGluZ3MgbGlrZSBwYXJhbWV0ZXJzIGFuZCByZXNvbHZhYmxlcyBmb3IgdGhlIHN0YXRlIGJlaW5nIGFjdGl2YXRlZC5cbiAqXG4gKiBUaGUgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgdGhlIFtbUGF0aE5vZGVdXXMsIGFuZCBwcm92aWRlcyBESSBmb3IgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aC5cbiAqL1xudmFyIFJlc29sdmVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZlQ29udGV4dChfcGF0aCkge1xuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XG4gICAgfVxuICAgIC8qKiBHZXRzIGFsbCB0aGUgdG9rZW5zIGZvdW5kIGluIHRoZSByZXNvbHZlIGNvbnRleHQsIGRlLWR1cGxpY2F0ZWQgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0VG9rZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gYWNjLmNvbmNhdChub2RlLnJlc29sdmFibGVzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbjsgfSkpOyB9LCBbXSkucmVkdWNlKGNvbW1vbl8xLnVuaXFSLCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBSZXNvbHZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgdG9rZW5cbiAgICAgKlxuICAgICAqIEdldHMgdGhlIGxhc3QgUmVzb2x2YWJsZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuIGluIHRoaXMgY29udGV4dCwgb3IgdW5kZWZpbmVkLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBSZXNvbHZlQ29udGV4dFxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaGluZyA9IHRoaXMuX3BhdGgubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnJlc29sdmFibGVzOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW4gPT09IHRva2VuOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnRhaWwobWF0Y2hpbmcpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIFtbUmVzb2x2ZVBvbGljeV1dIGZvciB0aGUgZ2l2ZW4gW1tSZXNvbHZhYmxlXV0gKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UG9saWN5ID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZpbmROb2RlKHJlc29sdmFibGUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXRQb2xpY3kobm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCBpbmNsdWRlcyBhIHBvcnRpb24gb2YgdGhpcyBvbmVcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgc3RhdGUsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgUmVzb2x2ZUNvbnRleHQgZnJvbSB0aGlzIG9uZS5cbiAgICAgKiBUaGUgbmV3IGNvbnRleHQgc3RhcnRzIGF0IHRoZSBmaXJzdCBub2RlIChyb290KSBhbmQgc3RvcHMgYXQgdGhlIG5vZGUgZm9yIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqICMjIyMgV2h5XG4gICAgICpcbiAgICAgKiBXaGVuIGEgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLCB0aGUgbm9kZXMgaW4gdGhlIFwiVG8gUGF0aFwiIGFyZSBpbmplY3RlZCBmcm9tIGEgUmVzb2x2ZUNvbnRleHQuXG4gICAgICogQSBSZXNvbHZlQ29udGV4dCBjbG9zZXMgb3ZlciBhIHBhdGggb2YgW1tQYXRoTm9kZV1dcyBhbmQgcHJvY2Vzc2VzIHRoZSByZXNvbHZhYmxlcy5cbiAgICAgKiBUaGUgXCJUbyBTdGF0ZVwiIGNhbiBpbmplY3QgdmFsdWVzIGZyb20gaXRzIG93biByZXNvbHZhYmxlcywgYXMgd2VsbCBhcyB0aG9zZSBmcm9tIGFsbCBpdHMgYW5jZXN0b3Igc3RhdGUncyAobm9kZSdzKS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5hcnJvd2VyIGNvbnRleHQgd2hlbiBpbmplY3RpbmcgYW5jZXN0b3Igbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBsZXQgQUJDRCA9IG5ldyBSZXNvbHZlQ29udGV4dChbQSwgQiwgQywgRF0pO2BcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgcGF0aCBgW0EsIEIsIEMsIERdYCwgd2hlcmUgYEFgLCBgQmAsIGBDYCBhbmQgYERgIGFyZSBub2RlcyBmb3Igc3RhdGVzIGBhYCwgYGJgLCBgY2AsIGBkYDpcbiAgICAgKiBXaGVuIGluamVjdGluZyBgRGAsIGBEYCBzaG91bGQgaGF2ZSBhY2Nlc3MgdG8gYWxsIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAsIGBDYCwgYERgLlxuICAgICAqIEhvd2V2ZXIsIGBCYCBzaG91bGQgb25seSBiZSBhYmxlIHRvIGFjY2VzcyByZXNvbHZhYmxlcyBmcm9tIGBBYCwgYEJgLlxuICAgICAqXG4gICAgICogV2hlbiByZXNvbHZpbmcgZm9yIHRoZSBgQmAgbm9kZSwgZmlyc3QgdGFrZSB0aGUgZnVsbCBcIlRvIFBhdGhcIiBDb250ZXh0IGBbQSxCLEMsRF1gIGFuZCBsaW1pdCB0byB0aGUgc3VicGF0aCBgW0EsQl1gLlxuICAgICAqIGBsZXQgQUIgPSBBQkNELnN1YmNvbnRleHQoYSlgXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLnN1YkNvbnRleHQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlQ29udGV4dChwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5zdWJQYXRoKHRoaXMuX3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlID09PSBzdGF0ZTsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBSZXNvbHZhYmxlcyB0byB0aGUgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHN0YXRlXG4gICAgICpcbiAgICAgKiBUaGlzIGFkZHMgYSBbW1Jlc29sdmFibGVdXSAoZ2VuZXJhbGx5IG9uZSBjcmVhdGVkIG9uIHRoZSBmbHk7IG5vdCBkZWNsYXJlZCBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYmxvY2spLlxuICAgICAqIFRoZSByZXNvbHZhYmxlIGlzIGFkZGVkIHRvIHRoZSBub2RlIG1hdGNoaW5nIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFRoZXNlIG5ldyByZXNvbHZhYmxlcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgZmV0Y2hlZC5cbiAgICAgKiBUaGUgY2FsbGluZyBjb2RlIHNob3VsZCBlaXRoZXIgZmV0Y2ggdGhlbSwgZmV0Y2ggc29tZXRoaW5nIHRoYXQgZGVwZW5kcyBvbiB0aGVtLFxuICAgICAqIG9yIHJlbHkgb24gW1tyZXNvbHZlUGF0aF1dIGJlaW5nIGNhbGxlZCB3aGVuIHNvbWUgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGVhY2ggcmVzb2x2YWJsZSdzIFtbUmVzb2x2ZVBvbGljeV1dIGlzIG1lcmdlZCB3aXRoIHRoZSBzdGF0ZSdzIHBvbGljeSwgYW5kIHRoZSBnbG9iYWwgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdSZXNvbHZhYmxlcyB0aGUgbmV3IFJlc29sdmFibGVzXG4gICAgICogQHBhcmFtIHN0YXRlIFVzZWQgdG8gZmluZCB0aGUgbm9kZSB0byBwdXQgdGhlIHJlc29sdmFibGUgb25cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuYWRkUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAobmV3UmVzb2x2YWJsZXMsIHN0YXRlKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZCh0aGlzLl9wYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcbiAgICAgICAgdmFyIGtleXMgPSBuZXdSZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW47IH0pO1xuICAgICAgICBub2RlLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGtleXMuaW5kZXhPZihyLnRva2VuKSA9PT0gLTE7IH0pLmNvbmNhdChuZXdSZXNvbHZhYmxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcGF0aCBFbGVtZW50IHByb21pc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2hlblxuICAgICAqIEBwYXJhbSB0cmFuc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT58YW55fVxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh3aGVuLCB0cmFucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAod2hlbiA9PT0gdm9pZCAwKSB7IHdoZW4gPSBcIkxBWllcIjsgfVxuICAgICAgICAvLyBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIHdoaWNoICd3aGVuJyBwb2xpY3kgUmVzb2x2YWJsZXMgd2UgYXJlIGFib3V0IHRvIGZldGNoLlxuICAgICAgICB2YXIgd2hlbk9wdGlvbiA9IGNvbW1vbl8xLmluQXJyYXkoQUxMX1dIRU5TLCB3aGVuKSA/IHdoZW4gOiBcIkxBWllcIjtcbiAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBzcGVjaWZpZWQgRUFHRVIsIG9ubHkgdGhlIEVBR0VSIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLlxuICAgICAgICAvLyBpZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBMQVpZLCBib3RoIEVBR0VSIGFuZCBMQVpZIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLmBcbiAgICAgICAgdmFyIG1hdGNoZWRXaGVucyA9IHdoZW5PcHRpb24gPT09IGludGVyZmFjZV8xLnJlc29sdmVQb2xpY2llcy53aGVuLkVBR0VSID8gRUFHRVJfV0hFTlMgOiBBTExfV0hFTlM7XG4gICAgICAgIC8vIGdldCB0aGUgc3VicGF0aCB0byB0aGUgc3RhdGUgYXJndW1lbnQsIGlmIHByb3ZpZGVkXG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZlUGF0aCh0aGlzLl9wYXRoLCB3aGVuLCB0cmFucyk7XG4gICAgICAgIHZhciBtYXRjaGVzUG9saWN5ID0gZnVuY3Rpb24gKGFjY2VwdGVkVmFscywgd2hlbk9yQXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5pbkFycmF5KGFjY2VwdGVkVmFscywgX3RoaXMuZ2V0UG9saWN5KHJlc29sdmFibGUpW3doZW5PckFzeW5jXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VyIGFsbCB0aGUgKG1hdGNoaW5nKSBSZXNvbHZhYmxlcyBpbiB0aGUgcGF0aFxuICAgICAgICAvLyBSZWR1Y2UgYWxsIHRoZSBcIldBSVRcIiBSZXNvbHZhYmxlcyBpbnRvIGFuIGFycmF5XG4gICAgICAgIHZhciBwcm9taXNlcyA9IHRoaXMuX3BhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlUmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KG1hdGNoZWRXaGVucywgJ3doZW4nKSk7XG4gICAgICAgICAgICB2YXIgbm93YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKTtcbiAgICAgICAgICAgIHZhciB3YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihob2ZfMS5ub3QobWF0Y2hlc1BvbGljeShbJ05PV0FJVCddLCAnYXN5bmMnKSkpO1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBtYXRjaGluZyBSZXNvbHZhYmxlcywgc3RhcnQgdGhlaXIgYXN5bmMgZmV0Y2ggcHJvY2Vzcy5cbiAgICAgICAgICAgIHZhciBzdWJDb250ZXh0ID0gX3RoaXMuc3ViQ29udGV4dChub2RlLnN0YXRlKTtcbiAgICAgICAgICAgIHZhciBnZXRSZXN1bHQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gci5nZXQoc3ViQ29udGV4dCwgdHJhbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoeyB0b2tlbjogci50b2tlbiwgdmFsdWU6IHZhbHVlIH0pOyB9KTsgfTtcbiAgICAgICAgICAgIG5vd2FpdC5mb3JFYWNoKGdldFJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh3YWl0Lm1hcChnZXRSZXN1bHQpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICAvLyBXYWl0IGZvciBhbGwgdGhlIFwiV0FJVFwiIHJlc29sdmFibGVzXG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0b3IgfHwgKHRoaXMuX2luamVjdG9yID0gbmV3IFVJSW5qZWN0b3JJbXBsKHRoaXMpKTtcbiAgICB9O1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5maW5kKHRoaXMuX3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBjb21tb25fMS5pbkFycmF5KG5vZGUucmVzb2x2YWJsZXMsIHJlc29sdmFibGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFzeW5jIGRlcGVuZGVuY2llcyBvZiBhIFJlc29sdmFibGVcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgUmVzb2x2YWJsZSwgcmV0dXJucyBpdHMgZGVwZW5kZW5jaWVzIGFzIGEgUmVzb2x2YWJsZVtdXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5maW5kTm9kZShyZXNvbHZhYmxlKTtcbiAgICAgICAgLy8gRmluZCB3aGljaCBvdGhlciByZXNvbHZhYmxlcyBhcmUgXCJ2aXNpYmxlXCIgdG8gdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgICAgICAvLyBzdWJwYXRoIHN0b3BwaW5nIGF0IHJlc29sdmFibGUncyBub2RlLCBvciB0aGUgd2hvbGUgcGF0aCAoaWYgdGhlIHJlc29sdmFibGUgaXNuJ3QgaW4gdGhlIHBhdGgpXG4gICAgICAgIHZhciBzdWJQYXRoID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbm9kZTsgfSkgfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJlc29sdmFibGVzID0gc3ViUGF0aFxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBhY2MuY29uY2F0KG5vZGUucmVzb2x2YWJsZXMpOyB9LCBbXSkgLy9hbGwgb2Ygc3VicGF0aCdzIHJlc29sdmFibGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcyAhPT0gcmVzb2x2YWJsZTsgfSk7IC8vIGZpbHRlciBvdXQgdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgICAgICB2YXIgZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gYXZhaWxhYmxlUmVzb2x2YWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuID09PSB0b2tlbjsgfSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKG1hdGNoaW5nKTtcbiAgICAgICAgICAgIHZhciBmcm9tSW5qZWN0b3IgPSBfdGhpcy5pbmplY3RvcigpLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgICAgICAgICBpZiAoIWZyb21JbmplY3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIERlcGVuZGVuY3kgSW5qZWN0aW9uIHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21JbmplY3RvcjsgfSwgW10sIGZyb21JbmplY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmRlcHMubWFwKGdldERlcGVuZGVuY3kpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmVDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2ZUNvbnRleHQgPSBSZXNvbHZlQ29udGV4dDtcbnZhciBVSUluamVjdG9ySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlJbmplY3RvckltcGwoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IHRoaXMuZ2V0KGV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOKSB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XG4gICAgfVxuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYyA9PT0gJ05PV0FJVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzb2x2YWJsZS5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc29sdmFibGUgYXN5bmMgLmdldCgpIG5vdCBjb21wbGV0ZTpcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkocmVzb2x2YWJsZS50b2tlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmUgJiYgdGhpcy5uYXRpdmUuZ2V0KHRva2VuKTtcbiAgICB9O1xuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXRBc3luYyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IHRoaXMuY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTtcbiAgICAgICAgaWYgKHJlc29sdmFibGUpXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odGhpcy5uYXRpdmUuZ2V0KHRva2VuKSk7XG4gICAgfTtcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0TmF0aXZlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZSAmJiB0aGlzLm5hdGl2ZS5nZXQodG9rZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFVJSW5qZWN0b3JJbXBsO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDb250ZXh0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/resolve/resolveContext.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/router.js":
/*!***************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/router.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = __webpack_require__(/*! ./url/urlMatcherFactory */ \"./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js\");\nvar urlRouter_1 = __webpack_require__(/*! ./url/urlRouter */ \"./node_modules/@uirouter/core/lib/url/urlRouter.js\");\nvar transitionService_1 = __webpack_require__(/*! ./transition/transitionService */ \"./node_modules/@uirouter/core/lib/transition/transitionService.js\");\nvar view_1 = __webpack_require__(/*! ./view/view */ \"./node_modules/@uirouter/core/lib/view/view.js\");\nvar stateRegistry_1 = __webpack_require__(/*! ./state/stateRegistry */ \"./node_modules/@uirouter/core/lib/state/stateRegistry.js\");\nvar stateService_1 = __webpack_require__(/*! ./state/stateService */ \"./node_modules/@uirouter/core/lib/state/stateService.js\");\nvar globals_1 = __webpack_require__(/*! ./globals */ \"./node_modules/@uirouter/core/lib/globals.js\");\nvar common_1 = __webpack_require__(/*! ./common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ./common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar urlService_1 = __webpack_require__(/*! ./url/urlService */ \"./node_modules/@uirouter/core/lib/url/urlService.js\");\nvar trace_1 = __webpack_require__(/*! ./common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcm91dGVyLmpzPzJkZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIGNvcmVcbiAqLyAvKiogKi9cbnZhciB1cmxNYXRjaGVyRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vdXJsL3VybE1hdGNoZXJGYWN0b3J5XCIpO1xudmFyIHVybFJvdXRlcl8xID0gcmVxdWlyZShcIi4vdXJsL3VybFJvdXRlclwiKTtcbnZhciB0cmFuc2l0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZVwiKTtcbnZhciB2aWV3XzEgPSByZXF1aXJlKFwiLi92aWV3L3ZpZXdcIik7XG52YXIgc3RhdGVSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVSZWdpc3RyeVwiKTtcbnZhciBzdGF0ZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3N0YXRlL3N0YXRlU2VydmljZVwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB1cmxTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi91cmwvdXJsU2VydmljZVwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL3RyYWNlXCIpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBfcm91dGVySW5zdGFuY2UgPSAwO1xuLyoqXG4gKiBUaGUgbWFzdGVyIGNsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2YgVUktUm91dGVyLlxuICpcbiAqIFVJLVJvdXRlciAoZm9yIGVhY2ggc3BlY2lmaWMgZnJhbWV3b3JrKSB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGR1cmluZyBib290c3RyYXAuXG4gKiBUaGlzIGNsYXNzIGluc3RhbnRpYXRlcyBhbmQgd2lyZXMgdGhlIFVJLVJvdXRlciBzZXJ2aWNlcyB0b2dldGhlci5cbiAqXG4gKiBBZnRlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgVUlSb3V0ZXIgY2xhc3MgaXMgY3JlYXRlZCwgaXQgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgZm9yIHlvdXIgYXBwLlxuICogRm9yIGluc3RhbmNlLCBhcHAgc3RhdGVzIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIFtbVUlSb3V0ZXIuc3RhdGVSZWdpc3RyeV1dLlxuICpcbiAqIC0tLVxuICpcbiAqIE5vcm1hbGx5IHRoZSBmcmFtZXdvcmsgY29kZSB3aWxsIGJvb3RzdHJhcCBVSS1Sb3V0ZXIuXG4gKiBJZiB5b3UgYXJlIGJvb3RzdHJhcHBpbmcgVUlSb3V0ZXIgbWFudWFsbHksIHRlbGwgaXQgdG8gbW9uaXRvciB0aGUgVVJMIGJ5IGNhbGxpbmdcbiAqIFtbVXJsU2VydmljZS5saXN0ZW5dXSB0aGVuIFtbVXJsU2VydmljZS5zeW5jXV0uXG4gKi9cbnZhciBVSVJvdXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVUlSb3V0ZXJgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2F0aW9uU2VydmljZSBhIFtbTG9jYXRpb25TZXJ2aWNlc11dIGltcGxlbWVudGF0aW9uXG4gICAgICogQHBhcmFtIGxvY2F0aW9uQ29uZmlnIGEgW1tMb2NhdGlvbkNvbmZpZ11dIGltcGxlbWVudGF0aW9uXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gVUlSb3V0ZXIobG9jYXRpb25TZXJ2aWNlLCBsb2NhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAobG9jYXRpb25TZXJ2aWNlID09PSB2b2lkIDApIHsgbG9jYXRpb25TZXJ2aWNlID0gdXJsU2VydmljZV8xLlVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YjsgfVxuICAgICAgICBpZiAobG9jYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBsb2NhdGlvbkNvbmZpZyA9IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlLmxvY2F0aW9uQ29uZmlnU3R1YjsgfVxuICAgICAgICB0aGlzLmxvY2F0aW9uU2VydmljZSA9IGxvY2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkNvbmZpZyA9IGxvY2F0aW9uQ29uZmlnO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLiRpZCA9IF9yb3V0ZXJJbnN0YW5jZSsrO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICAvKiogUHJvdmlkZXMgdHJhY2UgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy50cmFjZSA9IHRyYWNlXzEudHJhY2U7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXZpZXcgc3luY2hyb25pemF0aW9uICovXG4gICAgICAgIHRoaXMudmlld1NlcnZpY2UgPSBuZXcgdmlld18xLlZpZXdTZXJ2aWNlKCk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIFRyYW5zaXRpb25zICovXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblNlcnZpY2UgPSBuZXcgdHJhbnNpdGlvblNlcnZpY2VfMS5UcmFuc2l0aW9uU2VydmljZSh0aGlzKTtcbiAgICAgICAgLyoqIEdsb2JhbCByb3V0ZXIgc3RhdGUgKi9cbiAgICAgICAgdGhpcy5nbG9iYWxzID0gbmV3IGdsb2JhbHNfMS5VSVJvdXRlckdsb2JhbHMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcHJlY2F0ZWQgZm9yIHB1YmxpYyB1c2UuIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cmxNYXRjaGVyRmFjdG9yeSA9IG5ldyB1cmxNYXRjaGVyRmFjdG9yeV8xLlVybE1hdGNoZXJGYWN0b3J5KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsUm91dGVyID0gbmV3IHVybFJvdXRlcl8xLlVybFJvdXRlcih0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIGEgcmVnaXN0cnkgZm9yIHN0YXRlcywgYW5kIHJlbGF0ZWQgcmVnaXN0cmF0aW9uIHNlcnZpY2VzICovXG4gICAgICAgIHRoaXMuc3RhdGVSZWdpc3RyeSA9IG5ldyBzdGF0ZVJlZ2lzdHJ5XzEuU3RhdGVSZWdpc3RyeSh0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gc3RhdGVzICovXG4gICAgICAgIHRoaXMuc3RhdGVTZXJ2aWNlID0gbmV3IHN0YXRlU2VydmljZV8xLlN0YXRlU2VydmljZSh0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdGhlIFVSTCAqL1xuICAgICAgICB0aGlzLnVybFNlcnZpY2UgPSBuZXcgdXJsU2VydmljZV8xLlVybFNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3U2VydmljZS5fcGx1Z2luYXBpLl9yb290Vmlld0NvbnRleHQodGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSk7XG4gICAgICAgIHRoaXMuZ2xvYmFscy4kY3VycmVudCA9IHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCk7XG4gICAgICAgIHRoaXMuZ2xvYmFscy5jdXJyZW50ID0gdGhpcy5nbG9iYWxzLiRjdXJyZW50LnNlbGY7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLmdsb2JhbHMpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5zdGF0ZVNlcnZpY2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5zdGF0ZVJlZ2lzdHJ5KTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudHJhbnNpdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy51cmxSb3V0ZXIpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUobG9jYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVycyBhbiBvYmplY3QgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgcm91dGVyIGlzIGRpc3Bvc2VkICovXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhpcyByb3V0ZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGVkLCBjbGVhcnMgcmVzb3VyY2VzIHJldGFpbmVkIGJ5IHRoZSByb3V0ZXIgYnkgY2FsbGluZyBgZGlzcG9zZSh0aGlzKWAgb24gYWxsXG4gICAgICogcmVnaXN0ZXJlZCBbW2Rpc3Bvc2FibGVdXSBvYmplY3RzLlxuICAgICAqXG4gICAgICogT3IsIGlmIGEgYGRpc3Bvc2FibGVgIG9iamVjdCBpcyBwcm92aWRlZCwgY2FsbHMgYGRpc3Bvc2UodGhpcylgIG9uIHRoYXQgb2JqZWN0IG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSAob3B0aW9uYWwpIHRoZSBkaXNwb3NhYmxlIHRvIGRpc3Bvc2VcbiAgICAgKi9cbiAgICBVSVJvdXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChkaXNwb3NhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaXNwb3NhYmxlICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGRpc3Bvc2FibGUuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHlwZW9mIGQuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkLmRpc3Bvc2UoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20oX3RoaXMuX2Rpc3Bvc2FibGVzLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7IH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcGx1Z2luIHRvIFVJLVJvdXRlclxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyBhIFVJLVJvdXRlciBQbHVnaW4uXG4gICAgICogQSBwbHVnaW4gY2FuIGVuaGFuY2Ugb3IgY2hhbmdlIFVJLVJvdXRlciBiZWhhdmlvciB1c2luZyBhbnkgcHVibGljIEFQSS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCB7IE15Q29vbFBsdWdpbiB9IGZyb20gXCJ1aS1yb3V0ZXItY29vbC1wbHVnaW5cIjtcbiAgICAgKlxuICAgICAqIHZhciBwbHVnaW4gPSByb3V0ZXIuYWRkUGx1Z2luKE15Q29vbFBsdWdpbik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUGx1Z2luIGF1dGhvcmluZ1xuICAgICAqXG4gICAgICogQSBwbHVnaW4gaXMgc2ltcGx5IGEgY2xhc3MgKG9yIGNvbnN0cnVjdG9yIGZ1bmN0aW9uKSB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlIGFuZCAob3B0aW9uYWxseSkgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgcGx1Z2luIGNhbiBpbXBsZW1lbnQgaXRzIGZ1bmN0aW9uYWxpdHkgdXNpbmcgYW55IG9mIHRoZSBwdWJsaWMgQVBJcyBvZiBbW1VJUm91dGVyXV0uXG4gICAgICogRm9yIGV4YW1wbGUsIGl0IG1heSBjb25maWd1cmUgcm91dGVyIG9wdGlvbnMgb3IgYWRkIGEgVHJhbnNpdGlvbiBIb29rLlxuICAgICAqXG4gICAgICogVGhlIHBsdWdpbiBjYW4gdGhlbiBiZSBwdWJsaXNoZWQgYXMgYSBzZXBhcmF0ZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBleHBvcnQgY2xhc3MgTXlBdXRoUGx1Z2luIGltcGxlbWVudHMgVUlSb3V0ZXJQbHVnaW4ge1xuICAgICAqICAgY29uc3RydWN0b3Iocm91dGVyOiBVSVJvdXRlciwgb3B0aW9uczogYW55KSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IFwiTXlBdXRoUGx1Z2luXCI7XG4gICAgICogICAgIGxldCAkdHJhbnNpdGlvbnMgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgICogICAgIGxldCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAqXG4gICAgICogICAgIGxldCBhdXRoQ3JpdGVyaWEgPSB7XG4gICAgICogICAgICAgdG86IChzdGF0ZSkgPT4gc3RhdGUuZGF0YSAmJiBzdGF0ZS5kYXRhLnJlcXVpcmVzQXV0aFxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogICAgIGZ1bmN0aW9uIGF1dGhIb29rKHRyYW5zaXRpb246IFRyYW5zaXRpb24pIHtcbiAgICAgKiAgICAgICBsZXQgYXV0aFNlcnZpY2UgPSB0cmFuc2l0aW9uLmluamVjdG9yKCkuZ2V0KCdBdXRoU2VydmljZScpO1xuICAgICAqICAgICAgIGlmICghYXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgKiAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KCdsb2dpbicpO1xuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgICR0cmFuc2l0aW9ucy5vblN0YXJ0KGF1dGhDcml0ZXJpYSwgYXV0aEhvb2spO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbHVnaW4gb25lIG9mOlxuICAgICAqICAgICAgICAtIGEgcGx1Z2luIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgW1tVSVJvdXRlclBsdWdpbl1dXG4gICAgICogICAgICAgIC0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgYSBbW1VJUm91dGVyUGx1Z2luXV0gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZVxuICAgICAqICAgICAgICAtIGEgZmFjdG9yeSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlIGFuZCByZXR1cm5zIGEgW1tVSVJvdXRlclBsdWdpbl1dIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBwbHVnaW4gY2xhc3MvZmFjdG9yeVxuICAgICAqIEByZXR1cm5zIHRoZSByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5wbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwbHVnaW5JbnN0YW5jZSA9IG5ldyBwbHVnaW4odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcGx1Z2luSW5zdGFuY2UubmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIHByb3BlcnR5IGBuYW1lYCBtaXNzaW5nIG9uIHBsdWdpbjogXCIgKyBwbHVnaW5JbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2gocGx1Z2luSW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2luc1twbHVnaW5JbnN0YW5jZS5uYW1lXSA9IHBsdWdpbkluc3RhbmNlO1xuICAgIH07XG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmdldFBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW5OYW1lID8gdGhpcy5fcGx1Z2luc1twbHVnaW5OYW1lXSA6IGNvbW1vbl8xLnZhbHVlcyh0aGlzLl9wbHVnaW5zKTtcbiAgICB9O1xuICAgIHJldHVybiBVSVJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlVJUm91dGVyID0gVUlSb3V0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/router.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./stateBuilder */ \"./node_modules/@uirouter/core/lib/state/stateBuilder.js\"));\n__export(__webpack_require__(/*! ./stateObject */ \"./node_modules/@uirouter/core/lib/state/stateObject.js\"));\n__export(__webpack_require__(/*! ./stateMatcher */ \"./node_modules/@uirouter/core/lib/state/stateMatcher.js\"));\n__export(__webpack_require__(/*! ./stateQueueManager */ \"./node_modules/@uirouter/core/lib/state/stateQueueManager.js\"));\n__export(__webpack_require__(/*! ./stateRegistry */ \"./node_modules/@uirouter/core/lib/state/stateRegistry.js\"));\n__export(__webpack_require__(/*! ./stateService */ \"./node_modules/@uirouter/core/lib/state/stateService.js\"));\n__export(__webpack_require__(/*! ./targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9pbmRleC5qcz8yMmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU9iamVjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU1hdGNoZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVSZWdpc3RyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateBuilder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateBuilder.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ \"./node_modules/@uirouter/core/lib/resolve/resolvable.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlQnVpbGRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVCdWlsZGVyLmpzPzRmODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGFyc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcodXJsKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciByb290ID0gdXJsLmNoYXJBdCgwKSA9PT0gJ14nO1xuICAgIHJldHVybiB7IHZhbDogcm9vdCA/IHVybC5zdWJzdHJpbmcoMSkgOiB1cmwsIHJvb3Q6IHJvb3QgfTtcbn07XG5mdW5jdGlvbiBuYW1lQnVpbGRlcihzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5uYW1lO1xufVxuZnVuY3Rpb24gc2VsZkJ1aWxkZXIoc3RhdGUpIHtcbiAgICBzdGF0ZS5zZWxmLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgICByZXR1cm4gc3RhdGUuc2VsZjtcbn1cbmZ1bmN0aW9uIGRhdGFCdWlsZGVyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnBhcmVudCAmJiBzdGF0ZS5wYXJlbnQuZGF0YSkge1xuICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuc2VsZi5kYXRhID0gY29tbW9uXzEuaW5oZXJpdChzdGF0ZS5wYXJlbnQuZGF0YSwgc3RhdGUuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5kYXRhO1xufVxudmFyIGdldFVybEJ1aWxkZXIgPSBmdW5jdGlvbiAoJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXIsIHJvb3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXJsQnVpbGRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgc3RhdGVEZWMgPSBzdGF0ZTtcbiAgICAgICAgLy8gRm9yIGZ1dHVyZSBzdGF0ZXMsIGkuZS4sIHN0YXRlcyB3aG9zZSBuYW1lIGVuZHMgd2l0aCBgLioqYCxcbiAgICAgICAgLy8gbWF0Y2ggYW55dGhpbmcgdGhhdCBzdGFydHMgd2l0aCB0aGUgdXJsIHByZWZpeFxuICAgICAgICBpZiAoc3RhdGVEZWMgJiYgc3RhdGVEZWMudXJsICYmIHN0YXRlRGVjLm5hbWUgJiYgc3RhdGVEZWMubmFtZS5tYXRjaCgvXFwuXFwqXFwqJC8pKSB7XG4gICAgICAgICAgICBzdGF0ZURlYy51cmwgKz0gXCJ7cmVtYWluZGVyOmFueX1cIjsgLy8gbWF0Y2ggYW55IHBhdGggKC4qKVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVVybChzdGF0ZURlYy51cmwpLCBwYXJlbnQgPSBzdGF0ZS5wYXJlbnQ7XG4gICAgICAgIHZhciB1cmwgPSAhcGFyc2VkID8gc3RhdGVEZWMudXJsIDogJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXIuY29tcGlsZShwYXJzZWQudmFsLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHN0YXRlLnBhcmFtcyB8fCB7fSxcbiAgICAgICAgICAgIHBhcmFtTWFwOiBmdW5jdGlvbiAocGFyYW1Db25maWcsIGlzU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVjLnJlbG9hZE9uU2VhcmNoID09PSBmYWxzZSAmJiBpc1NlYXJjaClcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Db25maWcgPSBjb21tb25fMS5leHRlbmQocGFyYW1Db25maWcgfHwge30sIHsgZHluYW1pYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1Db25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmlzTWF0Y2hlcih1cmwpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xuICAgICAgICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucm9vdCkgPyB1cmwgOiAoKHBhcmVudCAmJiBwYXJlbnQubmF2aWdhYmxlKSB8fCByb290KCkpLnVybC5hcHBlbmQodXJsKTtcbiAgICB9O1xufTtcbnZhciBnZXROYXZpZ2FibGVCdWlsZGVyID0gZnVuY3Rpb24gKGlzUm9vdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBuYXZpZ2FibGVCdWlsZGVyKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiAhaXNSb290KHN0YXRlKSAmJiBzdGF0ZS51cmwgPyBzdGF0ZSA6IChzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbCk7XG4gICAgfTtcbn07XG52YXIgZ2V0UGFyYW1zQnVpbGRlciA9IGZ1bmN0aW9uIChwYXJhbUZhY3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGFyYW1zQnVpbGRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgbWFrZUNvbmZpZ1BhcmFtID0gZnVuY3Rpb24gKGNvbmZpZywgaWQpIHsgcmV0dXJuIHBhcmFtRmFjdG9yeS5mcm9tQ29uZmlnKGlkLCBudWxsLCBjb25maWcpOyB9O1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0gKHN0YXRlLnVybCAmJiBzdGF0ZS51cmwucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pKSB8fCBbXTtcbiAgICAgICAgdmFyIG5vblVybFBhcmFtcyA9IGNvbW1vbl8xLnZhbHVlcyhjb21tb25fMS5tYXBPYmooY29tbW9uXzEub21pdChzdGF0ZS5wYXJhbXMgfHwge30sIHVybFBhcmFtcy5tYXAoaG9mXzEucHJvcCgnaWQnKSkpLCBtYWtlQ29uZmlnUGFyYW0pKTtcbiAgICAgICAgcmV0dXJuIHVybFBhcmFtcy5jb25jYXQobm9uVXJsUGFyYW1zKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIFtwLmlkLCBwXTsgfSkucmVkdWNlKGNvbW1vbl8xLmFwcGx5UGFpcnMsIHt9KTtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIHBhdGhCdWlsZGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiBbc3RhdGVdO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNCdWlsZGVyKHN0YXRlKSB7XG4gICAgdmFyIGluY2x1ZGVzID0gc3RhdGUucGFyZW50ID8gY29tbW9uXzEuZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuaW5jbHVkZXMpIDoge307XG4gICAgaW5jbHVkZXNbc3RhdGUubmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBpbmNsdWRlcztcbn1cbi8qKlxuICogVGhpcyBpcyBhIFtbU3RhdGVCdWlsZGVyLmJ1aWxkZXJdXSBmdW5jdGlvbiBmb3IgdGhlIGByZXNvbHZlOmAgYmxvY2sgb24gYSBbW1N0YXRlRGVjbGFyYXRpb25dXS5cbiAqXG4gKiBXaGVuIHRoZSBbW1N0YXRlQnVpbGRlcl1dIGJ1aWxkcyBhIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgZnJvbSBhIHJhdyBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhpcyBidWlsZGVyXG4gKiB2YWxpZGF0ZXMgdGhlIGByZXNvbHZlYCBwcm9wZXJ0eSBhbmQgY29udmVydHMgaXQgdG8gYSBbW1Jlc29sdmFibGVdXSBhcnJheS5cbiAqXG4gKiByZXNvbHZlOiBpbnB1dCB2YWx1ZSBjYW4gYmU6XG4gKlxuICoge1xuICogICAvLyBhbmFseXplZCBidXQgbm90IGluamVjdGVkXG4gKiAgIG15Rm9vUmVzb2x2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBcIm15Rm9vRGF0YVwiOyB9LFxuICpcbiAqICAgLy8gZnVuY3Rpb24udG9TdHJpbmcoKSBwYXJzZWQsIFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nIChub3QgbWluLXNhZmUpXG4gKiAgIG15QmFyUmVzb2x2ZTogZnVuY3Rpb24oRGVwZW5kZW5jeU5hbWUpIHsgcmV0dXJuIERlcGVuZGVuY3lOYW1lLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZ1xuICogICBteUJhelJlc29sdmU6IFsgXCJEZXBlbmRlbmN5TmFtZVwiLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyBBcnJheSBzcGxpdDsgRGVwZW5kZW5jeVR5cGUgZGVwIGFzIHRva2VuIChjb21wYXJlZCB1c2luZyA9PT0pXG4gKiAgIG15UXV4UmVzb2x2ZTogWyBEZXBlbmRlbmN5VHlwZSwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyB2YWwuJGluamVjdCB1c2VkIGFzIGRlcHNcbiAqICAgLy8gd2hlcmU6XG4gKiAgIC8vICAgICBjb3JnZVJlc29sdmUuJGluamVjdCA9IFtcIkRlcGVuZGVuY3lOYW1lXCJdO1xuICogICAvLyAgICAgZnVuY3Rpb24gY29yZ2VSZXNvbHZlKGRlcCkgeyBkZXAuZmV0Y2hTb21ldGluZ0FzUHJvbWlzZSgpIH1cbiAqICAgLy8gdGhlbiBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZ1xuICogICBteUNvcmdlUmVzb2x2ZTogY29yZ2VSZXNvbHZlLFxuICpcbiAqICAvLyBpbmplY3Qgc2VydmljZSBieSBuYW1lXG4gKiAgLy8gV2hlbiBhIHN0cmluZyBpcyBmb3VuZCwgZGVzdWdhciBjcmVhdGluZyBhIHJlc29sdmUgdGhhdCBpbmplY3RzIHRoZSBuYW1lZCBzZXJ2aWNlXG4gKiAgIG15R3JhdWx0UmVzb2x2ZTogXCJTb21lU2VydmljZVwiXG4gKiB9XG4gKlxuICogb3I6XG4gKlxuICogW1xuICogICBuZXcgUmVzb2x2YWJsZShcIm15Rm9vUmVzb2x2ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFwibXlGb29EYXRhXCIgfSksXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlCYXJSZXNvbHZlXCIsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSwgWyBcIkRlcGVuZGVuY3lOYW1lXCIgXSksXG4gKiAgIHsgcHJvdmlkZTogXCJteUJhelJlc29sdmVcIiwgdXNlRmFjdG9yeTogZnVuY3Rpb24oZGVwKSB7IGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIGRlcHM6IFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0gfVxuICogXVxuICovXG5mdW5jdGlvbiByZXNvbHZhYmxlc0J1aWxkZXIoc3RhdGUpIHtcbiAgICAvKiogY29udmVydCByZXNvbHZlOiB7fSBhbmQgcmVzb2x2ZVBvbGljeToge30gb2JqZWN0cyB0byBhbiBhcnJheSBvZiB0dXBsZXMgKi9cbiAgICB2YXIgb2JqZWN0czJUdXBsZXMgPSBmdW5jdGlvbiAocmVzb2x2ZU9iaiwgcmVzb2x2ZVBvbGljaWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXNvbHZlT2JqIHx8IHt9KS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiAoeyB0b2tlbjogdG9rZW4sIHZhbDogcmVzb2x2ZU9ialt0b2tlbl0sIGRlcHM6IHVuZGVmaW5lZCwgcG9saWN5OiByZXNvbHZlUG9saWNpZXNbdG9rZW5dIH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKiBmZXRjaCBESSBhbm5vdGF0aW9ucyBmcm9tIGEgZnVuY3Rpb24gb3IgbmcxLXN0eWxlIGFycmF5ICovXG4gICAgdmFyIGFubm90YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciAkaW5qZWN0b3IgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XG4gICAgICAgIC8vIG5nMSBkb2Vzbid0IGhhdmUgYW4gJGluamVjdG9yIHVudGlsIHJ1bnRpbWUuXG4gICAgICAgIC8vIElmIHRoZSAkaW5qZWN0b3IgZG9lc24ndCBleGlzdCwgdXNlIFwiZGVmZXJyZWRcIiBsaXRlcmFsIGFzIGFcbiAgICAgICAgLy8gbWFya2VyIGluZGljYXRpbmcgdGhleSBzaG91bGQgYmUgYW5ub3RhdGVkIHdoZW4gcnVudGltZSBzdGFydHNcbiAgICAgICAgcmV0dXJuIGZuWyckaW5qZWN0J10gfHwgKCRpbmplY3RvciAmJiAkaW5qZWN0b3IuYW5ub3RhdGUoZm4sICRpbmplY3Rvci5zdHJpY3REaSkpIHx8IFwiZGVmZXJyZWRcIjtcbiAgICB9O1xuICAgIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgaGFzIGJvdGggYHRva2VuYCBhbmQgYHJlc29sdmVGbmAsIGFuZCBpcyBwcm9iYWJseSBhIFtbUmVzb2x2ZUxpdGVyYWxdXSAqL1xuICAgIHZhciBpc1Jlc29sdmVMaXRlcmFsID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gISEob2JqLnRva2VuICYmIG9iai5yZXNvbHZlRm4pOyB9O1xuICAgIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIHByb3ZpZGUgbGl0ZXJhbCwgb3IgYSBuZzIgUHJvdmlkZXIgKi9cbiAgICB2YXIgaXNMaWtlTmcyUHJvdmlkZXIgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAhISgob2JqLnByb3ZpZGUgfHwgb2JqLnRva2VuKSAmJiAob2JqLnVzZVZhbHVlIHx8IG9iai51c2VGYWN0b3J5IHx8IG9iai51c2VFeGlzdGluZyB8fCBvYmoudXNlQ2xhc3MpKTsgfTtcbiAgICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSB0dXBsZSBmcm9tIG9iajJUdXBsZXMgKi9cbiAgICB2YXIgaXNUdXBsZUZyb21PYmogPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAhIShvYmogJiYgb2JqLnZhbCAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai52YWwpIHx8IHByZWRpY2F0ZXNfMS5pc0FycmF5KG9iai52YWwpIHx8IHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKG9iai52YWwpKSk7IH07XG4gICAgLyoqIGV4dHJhY3RzIHRoZSB0b2tlbiBmcm9tIGEgUHJvdmlkZXIgb3IgcHJvdmlkZSBsaXRlcmFsICovXG4gICAgdmFyIHRva2VuID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAucHJvdmlkZSB8fCBwLnRva2VuOyB9O1xuICAgIC8qKiBHaXZlbiBhIGxpdGVyYWwgcmVzb2x2ZSBvciBwcm92aWRlciBvYmplY3QsIHJldHVybnMgYSBSZXNvbHZhYmxlICovXG4gICAgdmFyIGxpdGVyYWwyUmVzb2x2YWJsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEucHJvcCgncmVzb2x2ZUZuJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIHAucmVzb2x2ZUZuLCBwLmRlcHMsIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VGYWN0b3J5JyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIHAudXNlRmFjdG9yeSwgKHAuZGVwcyB8fCBwLmRlcGVuZGVuY2llcyksIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VDbGFzcycpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgcC51c2VDbGFzcygpOyB9LCBbXSwgcC5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZVZhbHVlJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAudXNlVmFsdWU7IH0sIFtdLCBwLnBvbGljeSwgcC51c2VWYWx1ZSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlRXhpc3RpbmcnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgY29tbW9uXzEuaWRlbnRpdHksIFtwLnVzZUV4aXN0aW5nXSwgcC5wb2xpY3kpOyB9XSxcbiAgICBdKTtcbiAgICB2YXIgdHVwbGUyUmVzb2x2YWJsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidmFsXCIpLCBwcmVkaWNhdGVzXzEuaXNTdHJpbmcpLCBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgY29tbW9uXzEuaWRlbnRpdHksIFt0dXBsZS52YWxdLCB0dXBsZS5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcChcInZhbFwiKSwgcHJlZGljYXRlc18xLmlzQXJyYXkpLCBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgY29tbW9uXzEudGFpbCh0dXBsZS52YWwpLCB0dXBsZS52YWwuc2xpY2UoMCwgLTEpLCB0dXBsZS5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcChcInZhbFwiKSwgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24pLCBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgdHVwbGUudmFsLCBhbm5vdGF0ZSh0dXBsZS52YWwpLCB0dXBsZS5wb2xpY3kpOyB9XSxcbiAgICBdKTtcbiAgICB2YXIgaXRlbTJSZXNvbHZhYmxlID0gaG9mXzEucGF0dGVybihbXG4gICAgICAgIFtob2ZfMS5pcyhyZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSksIGZ1bmN0aW9uIChyKSB7IHJldHVybiByOyB9XSxcbiAgICAgICAgW2lzUmVzb2x2ZUxpdGVyYWwsIGxpdGVyYWwyUmVzb2x2YWJsZV0sXG4gICAgICAgIFtpc0xpa2VOZzJQcm92aWRlciwgbGl0ZXJhbDJSZXNvbHZhYmxlXSxcbiAgICAgICAgW2lzVHVwbGVGcm9tT2JqLCB0dXBsZTJSZXNvbHZhYmxlXSxcbiAgICAgICAgW2hvZl8xLnZhbCh0cnVlKSwgZnVuY3Rpb24gKG9iaikgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc29sdmUgdmFsdWU6IFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeShvYmopKTsgfV1cbiAgICBdKTtcbiAgICAvLyBJZiByZXNvbHZlQmxvY2sgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0IGFzLWlzLlxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl0J3MgYW4gb2JqZWN0IGFuZCBjb252ZXJ0IHRvIGFuIEFycmF5IG9mIHR1cGxlc1xuICAgIHZhciBkZWNsID0gc3RhdGUucmVzb2x2ZTtcbiAgICB2YXIgaXRlbXMgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShkZWNsKSA/IGRlY2wgOiBvYmplY3RzMlR1cGxlcyhkZWNsLCBzdGF0ZS5yZXNvbHZlUG9saWN5IHx8IHt9KTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGl0ZW0yUmVzb2x2YWJsZSk7XG59XG5leHBvcnRzLnJlc29sdmFibGVzQnVpbGRlciA9IHJlc29sdmFibGVzQnVpbGRlcjtcbi8qKlxuICogQGludGVybmFsYXBpIEEgaW50ZXJuYWwgZ2xvYmFsIHNlcnZpY2VcbiAqXG4gKiBTdGF0ZUJ1aWxkZXIgaXMgYSBmYWN0b3J5IGZvciB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gKlxuICogV2hlbiB5b3UgcmVnaXN0ZXIgYSBzdGF0ZSB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXSwgeW91IHJlZ2lzdGVyIGEgcGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0IHdoaWNoXG4gKiBjb25mb3JtcyB0byB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaW50ZXJmYWNlLiAgVGhpcyBmYWN0b3J5IHRha2VzIHRoYXQgb2JqZWN0IGFuZCBidWlsZHMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIFtbU3RhdGVPYmplY3RdXSBvYmplY3QsIHdoaWNoIGhhcyBhbiBBUEkgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBDdXN0b20gcHJvcGVydGllcyBvciBBUEkgbWF5IGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGJ5IHJlZ2lzdGVyaW5nIGEgZGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiB1c2luZyB0aGUgW1tidWlsZGVyXV0gbWV0aG9kLlxuICovXG52YXIgU3RhdGVCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZUJ1aWxkZXIobWF0Y2hlciwgdXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXIuZmluZChcIlwiKTsgfTtcbiAgICAgICAgdmFyIGlzUm9vdCA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUubmFtZSA9PT0gXCJcIjsgfTtcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50QnVpbGRlcihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGlzUm9vdChzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlci5maW5kKHNlbGYucGFyZW50TmFtZShzdGF0ZSkpIHx8IHJvb3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWxkZXJzID0ge1xuICAgICAgICAgICAgbmFtZTogW25hbWVCdWlsZGVyXSxcbiAgICAgICAgICAgIHNlbGY6IFtzZWxmQnVpbGRlcl0sXG4gICAgICAgICAgICBwYXJlbnQ6IFtwYXJlbnRCdWlsZGVyXSxcbiAgICAgICAgICAgIGRhdGE6IFtkYXRhQnVpbGRlcl0sXG4gICAgICAgICAgICAvLyBCdWlsZCBhIFVSTE1hdGNoZXIgaWYgbmVjZXNzYXJ5LCBlaXRoZXIgdmlhIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMXG4gICAgICAgICAgICB1cmw6IFtnZXRVcmxCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LCByb290KV0sXG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChpLmUuIGlzIG5hdmlnYWJsZSlcbiAgICAgICAgICAgIG5hdmlnYWJsZTogW2dldE5hdmlnYWJsZUJ1aWxkZXIoaXNSb290KV0sXG4gICAgICAgICAgICBwYXJhbXM6IFtnZXRQYXJhbXNCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LnBhcmFtRmFjdG9yeSldLFxuICAgICAgICAgICAgLy8gRWFjaCBmcmFtZXdvcmstc3BlY2lmaWMgdWktcm91dGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCBkZWZpbmUgaXRzIG93biBgdmlld3NgIGJ1aWxkZXJcbiAgICAgICAgICAgIC8vIGUuZy4sIHNyYy9uZzEvc3RhdGVidWlsZGVycy92aWV3cy50c1xuICAgICAgICAgICAgdmlld3M6IFtdLFxuICAgICAgICAgICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICAgICAgICAgIHBhdGg6IFtwYXRoQnVpbGRlcl0sXG4gICAgICAgICAgICAvLyBTcGVlZCB1cCAkc3RhdGUuaW5jbHVkZXMoKSBhcyBpdCdzIHVzZWQgYSBsb3RcbiAgICAgICAgICAgIGluY2x1ZGVzOiBbaW5jbHVkZXNCdWlsZGVyXSxcbiAgICAgICAgICAgIHJlc29sdmFibGVzOiBbcmVzb2x2YWJsZXNCdWlsZGVyXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBbW0J1aWxkZXJGdW5jdGlvbl1dIGZvciBhIHNwZWNpZmljIFtbU3RhdGVPYmplY3RdXSBwcm9wZXJ0eSAoZS5nLiwgYHBhcmVudGAsIGB1cmxgLCBvciBgcGF0aGApLlxuICAgICAqIE1vcmUgdGhhbiBvbmUgQnVpbGRlckZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIEJ1aWxkZXJGdW5jdGlvbihzKSB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eSBvbiBhbnkgc3Vic2VxdWVudGx5IGJ1aWx0IFtbU3RhdGVPYmplY3RdXSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFN0YXRlIHByb3BlcnR5IGJlaW5nIHJlZ2lzdGVyZWQgZm9yLlxuICAgICAqIEBwYXJhbSBmbiBUaGUgQnVpbGRlckZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBidWlsZCB0aGUgU3RhdGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBCdWlsZGVyRnVuY3Rpb25cbiAgICAgKi9cbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkZXIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIGJ1aWxkZXJzID0gdGhpcy5idWlsZGVycztcbiAgICAgICAgdmFyIGFycmF5ID0gYnVpbGRlcnNbbmFtZV0gfHwgW107XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQ6IGlmIG9ubHkgb25lIGJ1aWxkZXIgZXhpc3RzLCByZXR1cm4gaXQsIGVsc2UgcmV0dXJuIHdob2xlIGFyYXJ5LlxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpICYmICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGZuKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5sZW5ndGggPiAxID8gYXJyYXkgOiBhcnJheVswXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcobmFtZSkgfHwgIXByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGZuKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYnVpbGRlcnNbbmFtZV0gPSBhcnJheTtcbiAgICAgICAgYnVpbGRlcnNbbmFtZV0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZGVyc1tuYW1lXS5zcGxpY2UoYnVpbGRlcnNbbmFtZV0uaW5kZXhPZihmbiwgMSkpICYmIG51bGw7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9uIGFuIGVzc2VudGlhbGx5IGJsYW5rIFN0YXRlIG9iamVjdCwgcmV0dXJuaW5nIGEgU3RhdGUgb2JqZWN0IHdoaWNoIGhhcyBhbGwgaXRzXG4gICAgICogcHJvcGVydGllcyBhbmQgQVBJIGJ1aWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIGFuIHVuaW5pdGlhbGl6ZWQgU3RhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMgdGhlIGJ1aWx0IFN0YXRlIG9iamVjdFxuICAgICAqL1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbWF0Y2hlciA9IF9hLm1hdGNoZXIsIGJ1aWxkZXJzID0gX2EuYnVpbGRlcnM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5hbWUoc3RhdGUpO1xuICAgICAgICBpZiAocGFyZW50ICYmICFtYXRjaGVyLmZpbmQocGFyZW50LCB1bmRlZmluZWQsIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJ1aWxkZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWJ1aWxkZXJzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBidWlsZGVyc1trZXldLnJlZHVjZShmdW5jdGlvbiAocGFyZW50Rm4sIHN0ZXApIHsgcmV0dXJuIGZ1bmN0aW9uIChfc3RhdGUpIHsgcmV0dXJuIHN0ZXAoX3N0YXRlLCBwYXJlbnRGbik7IH07IH0sIGNvbW1vbl8xLm5vb3ApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGNoYWluKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnBhcmVudE5hbWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZXMgdGhhdCBzcGVjaWZ5IHRoZSAncGFyZW50OicgcHJvcGVydHkgc2hvdWxkIG5vdCBoYXZlIGEgJy4nIGluIHRoZWlyIG5hbWUgKFwiICsgbmFtZSArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGxhc3RTZWdtZW50ID09PSAnKionKVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICAgIH07XG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZTtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpICE9PSAtMSB8fCAhc3RhdGUucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5hbWUgPyBwYXJlbnROYW1lICsgXCIuXCIgKyBuYW1lIDogbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZUJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZUJ1aWxkZXIgPSBTdGF0ZUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZUJ1aWxkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateBuilder.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateMatcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateMatcher.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = common_1.values(this._states);\n            var matches = _states.filter(function (state) {\n                return state.__stateObjectCache.nameGlob &&\n                    state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlTWF0Y2hlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVNYXRjaGVyLmpzP2ZlMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBTdGF0ZU1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWF0Y2hlcihfc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XG4gICAgfVxuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcbiAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBzdGF0ZU5hbWUuaW5kZXhPZihcIi5cIikgPT09IDAgfHwgc3RhdGVOYW1lLmluZGV4T2YoXCJeXCIpID09PSAwO1xuICAgIH07XG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlLCBtYXRjaEdsb2IpIHtcbiAgICAgICAgaWYgKG1hdGNoR2xvYiA9PT0gdm9pZCAwKSB7IG1hdGNoR2xvYiA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFzdGF0ZU9yTmFtZSAmJiBzdGF0ZU9yTmFtZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc1N0ciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSk7XG4gICAgICAgIHZhciBuYW1lID0gaXNTdHIgPyBzdGF0ZU9yTmFtZSA6IHN0YXRlT3JOYW1lLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmUobmFtZSkpXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yZXNvbHZlUGF0aChuYW1lLCBiYXNlKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuICAgICAgICBpZiAoc3RhdGUgJiYgKGlzU3RyIHx8ICghaXNTdHIgJiYgKHN0YXRlID09PSBzdGF0ZU9yTmFtZSB8fCBzdGF0ZS5zZWxmID09PSBzdGF0ZU9yTmFtZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyICYmIG1hdGNoR2xvYikge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZXMgPSBjb21tb25fMS52YWx1ZXModGhpcy5fc3RhdGVzKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gX3N0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYiAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUubmFtZUdsb2IubWF0Y2hlcyhuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdGVNYXRjaGVyLmZpbmQ6IEZvdW5kIG11bHRpcGxlIG1hdGNoZXMgZm9yIFwiICsgbmFtZSArIFwiIHVzaW5nIGdsb2I6IFwiLCBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIG1hdGNoLm5hbWU7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgIHZhciBiYXNlU3RhdGUgPSB0aGlzLmZpbmQoYmFzZSk7XG4gICAgICAgIHZhciBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KFwiLlwiKSwgaSA9IDAsIHBhdGhMZW5ndGggPSBzcGxpdE5hbWUubGVuZ3RoLCBjdXJyZW50ID0gYmFzZVN0YXRlO1xuICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gXCJcIiAmJiBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGJhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdE5hbWVbaV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCAnXCIgKyBuYW1lICsgXCInIG5vdCB2YWxpZCBmb3Igc3RhdGUgJ1wiICsgYmFzZVN0YXRlLm5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbE5hbWUgPSBzcGxpdE5hbWUuc2xpY2UoaSkuam9pbihcIi5cIik7XG4gICAgICAgIHJldHVybiBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbE5hbWUgPyBcIi5cIiA6IFwiXCIpICsgcmVsTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hdGNoZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZU1hdGNoZXIgPSBTdGF0ZU1hdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZU1hdGNoZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateMatcher.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateObject.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateObject.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar glob_1 = __webpack_require__(/*! ../common/glob */ \"./node_modules/@uirouter/core/lib/common/glob.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: glob_1.Glob.fromString(state.name) // might return null\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    return StateObject;\n}());\n/** Predicate which returns true if the object is an class with @State() decorator */\nStateObject.isStateClass = function (stateDecl) {\n    return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n};\n/** Predicate which returns true if the object is an internal [[StateObject]] object */\nStateObject.isState = function (obj) {\n    return predicates_1.isObject(obj['__stateObjectCache']);\n};\nexports.StateObject = StateObject;\n//# sourceMappingURL=stateObject.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU9iamVjdC5qcz85ZDllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBnbG9iXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsb2JcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIFVJLVJvdXRlciBzdGF0ZS5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgY3JlYXRlZCB3aGVuIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXS5cbiAqXG4gKiBBIHJlZ2lzdGVyZWQgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaXMgYXVnbWVudGVkIHdpdGggYSBnZXR0ZXIgKFtbU3RhdGVEZWNsYXJhdGlvbi4kJHN0YXRlXV0pIHdoaWNoIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgW1tTdGF0ZU9iamVjdF1dIG9iamVjdC5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICogRWFjaCBvZiBpdHMgb3duIHByb3BlcnRpZXMgKGkuZS4sIGBoYXNPd25Qcm9wZXJ0eWApIGFyZSBidWlsdCB1c2luZyBidWlsZGVycyBmcm9tIHRoZSBbW1N0YXRlQnVpbGRlcl1dLlxuICovXG52YXIgU3RhdGVPYmplY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgU3RhdGUuY3JlYXRlKCkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZU9iamVjdChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRlT2JqZWN0LmNyZWF0ZShjb25maWcgfHwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdGF0ZSBvYmplY3QgdG8gcHV0IHRoZSBwcml2YXRlL2ludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb250by5cbiAgICAgKiBUaGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIGxvb2tzIGxpa2U6XG4gICAgICogKEludGVybmFsIFN0YXRlIE9iamVjdCkgLT4gKENvcHkgb2YgU3RhdGUucHJvdG90eXBlKSAtPiAoU3RhdGUgRGVjbGFyYXRpb24gb2JqZWN0KSAtPiAoU3RhdGUgRGVjbGFyYXRpb24ncyBwcm90b3R5cGUuLi4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWNsIHRoZSB1c2VyLXN1cHBsaWVkIFN0YXRlIERlY2xhcmF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0fSBhbiBpbnRlcm5hbCBTdGF0ZSBvYmplY3RcbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc3RhdGVEZWNsKSB7XG4gICAgICAgIHN0YXRlRGVjbCA9IFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyhzdGF0ZURlY2wpID8gbmV3IHN0YXRlRGVjbCgpIDogc3RhdGVEZWNsO1xuICAgICAgICB2YXIgc3RhdGUgPSBjb21tb25fMS5pbmhlcml0KGNvbW1vbl8xLmluaGVyaXQoc3RhdGVEZWNsLCBTdGF0ZU9iamVjdC5wcm90b3R5cGUpKTtcbiAgICAgICAgc3RhdGVEZWNsLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgICAgICAgc3RhdGUuc2VsZiA9IHN0YXRlRGVjbDtcbiAgICAgICAgc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlID0ge1xuICAgICAgICAgICAgbmFtZUdsb2I6IGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGUubmFtZSkgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdGhlIHNhbWUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBDb21wYXJlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHN0YXRlIGFnYWluc3QgdGhlIHBhc3NlZCB2YWx1ZSwgd2hpY2ggaXMgZWl0aGVyIGFuIG9iamVjdFxuICAgICAqIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHRoZSBvcmlnaW5hbCBkZWZpbml0aW9uIG9iamVjdCBwYXNzZWQgdG9cbiAgICAgKiBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIG9yIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWYgQ2FuIGJlIG9uZSBvZiAoYSkgYSBgU3RhdGVgIGluc3RhbmNlLCAoYikgYW4gb2JqZWN0IHRoYXQgd2FzIHBhc3NlZFxuICAgICAqICAgICAgICBpbnRvIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgKGMpIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZSBvZiBhIHN0YXRlIGFzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGByZWZgIG1hdGNoZXMgdGhlIGN1cnJlbnQgYFN0YXRlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09PSByZWYgfHwgdGhpcy5zZWxmID09PSByZWYgfHwgdGhpcy5mcW4oKSA9PT0gcmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBkb2VzIG5vdCBwcm9wZXJseSBoYW5kbGUgZG90IG5vdGF0aW9uXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIGRvdC1zZXBhcmF0ZWQgbmFtZSBvZiB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLmZxbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCB8fCAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyZW50LmZxbigpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IG5hbWUgKyBcIi5cIiArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIHN0YXRlJ3MgdHJlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucm9vdCgpIHx8IHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZSdzIGBQYXJhbWAgb2JqZWN0c1xuICAgICAqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyBvd25lZCBieSB0aGUgc3RhdGUuXG4gICAgICogSWYgYG9wdHMuaW5oZXJpdGAgaXMgdHJ1ZSwgaXQgYWxzbyBpbmNsdWRlcyB0aGUgYW5jZXN0b3Igc3RhdGVzJyBbW1BhcmFtXV0gb2JqZWN0cy5cbiAgICAgKiBJZiBgb3B0cy5tYXRjaGluZ0tleXNgIGV4aXN0cywgcmV0dXJucyBvbmx5IGBQYXJhbWBzIHdob3NlIGBpZGAgaXMgYSBrZXkgb24gdGhlIGBtYXRjaGluZ0tleXNgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdHMsIHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBudWxsIH0pO1xuICAgICAgICB2YXIgaW5oZXJpdGVkID0gb3B0cy5pbmhlcml0ICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBhcmFtZXRlcnMoKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRlZC5jb25jYXQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhb3B0cy5tYXRjaGluZ0tleXMgfHwgb3B0cy5tYXRjaGluZ0tleXMuaGFzT3duUHJvcGVydHkocGFyYW0uaWQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGUgW1tQYXJhbV1dIHRoYXQgaXMgb3duZWQgYnkgdGhlIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIHNlYXJjaGVzIHRoZSBhbmNlc3RvciBzdGF0ZXNgIFtbUGFyYW1dXXMuXG4gICAgICogQHBhcmFtIGlkIHRoZSBuYW1lIG9mIHRoZSBbW1BhcmFtXV0gdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAoaWQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnVybCAmJiB0aGlzLnVybC5wYXJhbWV0ZXIoaWQsIG9wdHMpIHx8XG4gICAgICAgICAgICBjb21tb25fMS5maW5kKGNvbW1vbl8xLnZhbHVlcyh0aGlzLnBhcmFtcyksIGhvZl8xLnByb3BFcSgnaWQnLCBpZCkpIHx8XG4gICAgICAgICAgICBvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVyKGlkKSk7XG4gICAgfTtcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZxbigpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlT2JqZWN0O1xufSgpKTtcbi8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gY2xhc3Mgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3IgKi9cblN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oc3RhdGVEZWNsKSAmJiBzdGF0ZURlY2xbJ19fdWlSb3V0ZXJTdGF0ZSddID09PSB0cnVlO1xufTtcbi8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCAqL1xuU3RhdGVPYmplY3QuaXNTdGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzT2JqZWN0KG9ialsnX19zdGF0ZU9iamVjdENhY2hlJ10pO1xufTtcbmV4cG9ydHMuU3RhdGVPYmplY3QgPSBTdGF0ZU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlT2JqZWN0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateObject.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateQueueManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateQueueManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar stateObject_1 = __webpack_require__(/*! ./stateObject */ \"./node_modules/@uirouter/core/lib/state/stateObject.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = stateObject_1.StateObject.create(stateDecl);\n        var name = state.name;\n        if (!predicates_1.isString(name))\n            throw new Error(\"State must have a valid name\");\n        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))\n            throw new Error(\"State '\" + name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n                }\n                var existingFutureState = getState(name_1 + \".**\");\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVF1ZXVlTWFuYWdlci5qcz82NWI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RhdGVPYmplY3RfMSA9IHJlcXVpcmUoXCIuL3N0YXRlT2JqZWN0XCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgU3RhdGVRdWV1ZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlUXVldWVNYW5hZ2VyKCRyZWdpc3RyeSwgJHVybFJvdXRlciwgc3RhdGVzLCBidWlsZGVyLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy4kcmVnaXN0cnkgPSAkcmVnaXN0cnk7XG4gICAgICAgIHRoaXMuJHVybFJvdXRlciA9ICR1cmxSb3V0ZXI7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSAkcmVnaXN0cnkubWF0Y2hlcjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfTtcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVEZWNsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT2JqZWN0XzEuU3RhdGVPYmplY3QuY3JlYXRlKHN0YXRlRGVjbCk7XG4gICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgY29tbW9uXzEuaW5BcnJheShxdWV1ZS5tYXAoaG9mXzEucHJvcCgnbmFtZScpKSwgbmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBxdWV1ZSA9IF9hLnF1ZXVlLCBzdGF0ZXMgPSBfYS5zdGF0ZXMsIGJ1aWxkZXIgPSBfYS5idWlsZGVyO1xuICAgICAgICB2YXIgcmVnaXN0ZXJlZCA9IFtdLCAvLyBzdGF0ZXMgdGhhdCBnb3QgcmVnaXN0ZXJlZFxuICAgICAgICBvcnBoYW5zID0gW10sIC8vIHN0YXRlcyB0aGF0IGRvbid0IHlldCBoYXZlIGEgcGFyZW50IHJlZ2lzdGVyZWRcbiAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aCA9IHt9OyAvLyBrZWVwIHRyYWNrIG9mIGhvdyBsb25nIHRoZSBxdWV1ZSB3aGVuIGFuIG9ycGhhbiB3YXMgZmlyc3QgZW5jb3VudGVyZWRcbiAgICAgICAgdmFyIGdldFN0YXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgX3RoaXMuc3RhdGVzW25hbWVdO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdGF0ZS5uYW1lO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJ1aWxkZXIuYnVpbGQoc3RhdGUpO1xuICAgICAgICAgICAgdmFyIG9ycGhhbklkeCA9IG9ycGhhbnMuaW5kZXhPZihzdGF0ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nU3RhdGUgPSBnZXRTdGF0ZShuYW1lXzEpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1N0YXRlICYmIGV4aXN0aW5nU3RhdGUubmFtZSA9PT0gbmFtZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIG5hbWVfMSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0Z1dHVyZVN0YXRlID0gZ2V0U3RhdGUobmFtZV8xICsgXCIuKipcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRnV0dXJlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZ1dHVyZSBzdGF0ZSBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlZ2lzdHJ5LmRlcmVnaXN0ZXIoZXhpc3RpbmdGdXR1cmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlc1tuYW1lXzFdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hSb3V0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBvcnBoYW5zLnNwbGljZShvcnBoYW5JZHgsIDEpO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV8xXTtcbiAgICAgICAgICAgIHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV8xXSA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvcnBoYW5JZHggPj0gMCAmJiBwcmV2ID09PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIHR3byBjb25zZWN1dGl2ZSBpdGVyYXRpb25zIHdoZXJlIG5vIGFkZGl0aW9uYWwgc3RhdGVzIHdlcmUgZGVxdWV1ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG9ycGhhbmVkIHN0YXRlICcke25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcnBoYW5JZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgb3JwaGFucy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpc3RlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKFwicmVnaXN0ZXJlZFwiLCByZWdpc3RlcmVkLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zZWxmOyB9KSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgfTtcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuYXR0YWNoUm91dGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLmFic3RyYWN0IHx8ICFzdGF0ZS51cmwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHVybFJvdXRlci5ydWxlKHRoaXMuJHVybFJvdXRlci51cmxSdWxlRmFjdG9yeS5jcmVhdGUoc3RhdGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVF1ZXVlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRlUXVldWVNYW5hZ2VyID0gU3RhdGVRdWV1ZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVF1ZXVlTWFuYWdlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateQueueManager.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateRegistry.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateRegistry.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stateMatcher_1 = __webpack_require__(/*! ./stateMatcher */ \"./node_modules/@uirouter/core/lib/state/stateMatcher.js\");\nvar stateBuilder_1 = __webpack_require__(/*! ./stateBuilder */ \"./node_modules/@uirouter/core/lib/state/stateBuilder.js\");\nvar stateQueueManager_1 = __webpack_require__(/*! ./stateQueueManager */ \"./node_modules/@uirouter/core/lib/state/stateQueueManager.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUmVnaXN0cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUmVnaXN0cnkuanM/NGQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdGF0ZU1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlTWF0Y2hlclwiKTtcbnZhciBzdGF0ZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKTtcbnZhciBzdGF0ZVF1ZXVlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFN0YXRlUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZVJlZ2lzdHJ5KF9yb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbmV3IHN0YXRlTWF0Y2hlcl8xLlN0YXRlTWF0Y2hlcih0aGlzLnN0YXRlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBzdGF0ZUJ1aWxkZXJfMS5TdGF0ZUJ1aWxkZXIodGhpcy5tYXRjaGVyLCBfcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5KTtcbiAgICAgICAgdGhpcy5zdGF0ZVF1ZXVlID0gbmV3IHN0YXRlUXVldWVNYW5hZ2VyXzEuU3RhdGVRdWV1ZU1hbmFnZXIodGhpcywgX3JvdXRlci51cmxSb3V0ZXIsIHRoaXMuc3RhdGVzLCB0aGlzLmJ1aWxkZXIsIHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJSb290KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fcmVnaXN0ZXJSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdFN0YXRlRGVmID0ge1xuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICB1cmw6ICdeJyxcbiAgICAgICAgICAgIHZpZXdzOiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgJyMnOiB7IHZhbHVlOiBudWxsLCB0eXBlOiAnaGFzaCcsIGR5bmFtaWM6IHRydWUgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfcm9vdCA9IHRoaXMuX3Jvb3QgPSB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIocm9vdFN0YXRlRGVmKTtcbiAgICAgICAgX3Jvb3QubmF2aWdhYmxlID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBfdGhpcy5nZXQoc3RhdGUpICYmIF90aGlzLmRlcmVnaXN0ZXIoc3RhdGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYSBTdGF0ZSBSZWdpc3RyeSBldmVudHNcbiAgICAgKlxuICAgICAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiBzdGF0ZXMgYXJlIHJlZ2lzdGVyZWQgb3IgZGVyZWdpc3RlcmVkIHdpdGggdGhlIFN0YXRlUmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgYWxsU3RhdGVzID0gcmVnaXN0cnkuZ2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBMYXRlciwgaW52b2tlIGRlcmVnaXN0ZXJGbigpIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiBsZXQgZGVyZWdpc3RlckZuID0gcmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKChldmVudCwgc3RhdGVzKSA9PiB7XG4gICAgICogICBzd2l0Y2goZXZlbnQpIHtcbiAgICAgKiAgICAgY2FzZTogJ3JlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IGFsbFN0YXRlcy5wdXNoKHN0YXRlKSk7XG4gICAgICogICAgICAgYnJlYWs7XG4gICAgICogICAgIGNhc2U6ICdkZXJlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgKiAgICAgICAgIGxldCBpZHggPSBhbGxTdGF0ZXMuaW5kZXhPZihzdGF0ZSk7XG4gICAgICogICAgICAgICBpZiAoaWR4ICE9PSAtMSkgYWxsU3RhdGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSByZWdpc3RlcmVkIHN0YXRlcyBjaGFuZ2VzLlxuICAgICAqICAgICAgICBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnMsIGBldmVudGAgYW5kIGBzdGF0ZWAuXG4gICAgICogICAgICAgIFNlZSBbW1N0YXRlUmVnaXN0cnlMaXN0ZW5lcl1dXG4gICAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUub25TdGF0ZXNDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLmxpc3RlbmVycykobGlzdGVuZXIpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbXBsaWNpdCByb290IHN0YXRlXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSByb290IG9mIHRoZSBzdGF0ZSB0cmVlLlxuICAgICAqIFRoZSByb290IHN0YXRlIGlzIGltcGxpY2l0bHkgY3JlYXRlZCBieSBVSS1Sb3V0ZXIuXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gcmVwcmVzZW50YXRpb24sIG5vdCBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSByb290IFtbU3RhdGVPYmplY3RdXVxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXRlIHRvIHRoZSByZWdpc3RyeVxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgcXVldWVzIGl0IGZvciByZWdpc3RyYXRpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBhIHN0YXRlIHdpbGwgYmUgcXVldWVkIGlmIHRoZSBzdGF0ZSdzIHBhcmVudCBpc24ndCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZURlZmluaXRpb24gdGhlIGRlZmluaXRpb24gb2YgdGhlIHN0YXRlIHRvIHJlZ2lzdGVyLlxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICAgICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBmdWxseSBidWlsdCAoU2VlOiBbW1N0YXRlQnVpbGRlcl1dKS5cbiAgICAgKiAgICAgICAgICBJZiB0aGUgc3RhdGUgd2FzIG9ubHkgcXVldWVkLCB0aGVuIHRoZSBvYmplY3QgaXMgbm90IGZ1bGx5IGJ1aWx0LlxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVF1ZXVlLnJlZ2lzdGVyKHN0YXRlRGVmaW5pdGlvbik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9kZXJlZ2lzdGVyVHJlZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsID0gdGhpcy5nZXQoKS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuJCRzdGF0ZSgpOyB9KTtcbiAgICAgICAgdmFyIGdldENoaWxkcmVuID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gYWxsLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gc3RhdGVzLmluZGV4T2Yocy5wYXJlbnQpICE9PSAtMTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gY2hpbGRyZW4gOiBjaGlsZHJlbi5jb25jYXQoZ2V0Q2hpbGRyZW4oY2hpbGRyZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oW3N0YXRlXSk7XG4gICAgICAgIHZhciBkZXJlZ2lzdGVyZWQgPSBbc3RhdGVdLmNvbmNhdChjaGlsZHJlbikucmV2ZXJzZSgpO1xuICAgICAgICBkZXJlZ2lzdGVyZWQuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciAkdXIgPSBfdGhpcy5fcm91dGVyLnVybFJvdXRlcjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBVUkwgcnVsZVxuICAgICAgICAgICAgJHVyLnJ1bGVzKCkuZmlsdGVyKGhvZl8xLnByb3BFcShcInN0YXRlXCIsIHN0YXRlKSkuZm9yRWFjaCgkdXIucmVtb3ZlUnVsZS5iaW5kKCR1cikpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0YXRlIGZyb20gcmVnaXN0cnlcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zdGF0ZXNbc3RhdGUubmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN0YXRlIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBUaGlzIHJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKiBJZiB0aGUgc3RhdGUgaGFzIGNoaWxkcmVuLCB0aGV5IGFyZSBhcmUgYWxzbyByZW1vdmVkIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSdzIG5hbWUgb3Igb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0W119IGEgbGlzdCBvZiByZW1vdmVkIHN0YXRlc1xuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlcmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcbiAgICAgICAgaWYgKCFfc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBkZXJlZ2lzdGVyIHN0YXRlOyBub3QgZm91bmQ6IFwiICsgc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgZGVyZWdpc3RlcmVkU3RhdGVzID0gdGhpcy5fZGVyZWdpc3RlclRyZWUoX3N0YXRlLiQkc3RhdGUoKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihcImRlcmVnaXN0ZXJlZFwiLCBkZXJlZ2lzdGVyZWRTdGF0ZXMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNlbGY7IH0pKTsgfSk7XG4gICAgICAgIHJldHVybiBkZXJlZ2lzdGVyZWRTdGF0ZXM7XG4gICAgfTtcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuc3RhdGVzW25hbWVdLnNlbGY7IH0pO1xuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgYmFzZSk7XG4gICAgICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5zZWxmIHx8IG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kZWNvcmF0b3IgPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLmJ1aWxkZXIobmFtZSwgZnVuYyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlUmVnaXN0cnkgPSBTdGF0ZVJlZ2lzdHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVSZWdpc3RyeS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateRegistry.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateService.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateService.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module state\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar queue_1 = __webpack_require__(/*! ../common/queue */ \"./node_modules/@uirouter/core/lib/common/queue.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ \"./node_modules/@uirouter/core/lib/path/pathFactory.js\");\nvar pathNode_1 = __webpack_require__(/*! ../path/pathNode */ \"./node_modules/@uirouter/core/lib/path/pathNode.js\");\nvar transitionService_1 = __webpack_require__(/*! ../transition/transitionService */ \"./node_modules/@uirouter/core/lib/transition/transitionService.js\");\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ \"./node_modules/@uirouter/core/lib/transition/rejectFactory.js\");\nvar targetState_1 = __webpack_require__(/*! ./targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\nvar param_1 = __webpack_require__(/*! ../params/param */ \"./node_modules/@uirouter/core/lib/params/param.js\");\nvar glob_1 = __webpack_require__(/*! ../common/glob */ \"./node_modules/@uirouter/core/lib/common/glob.js\");\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ \"./node_modules/@uirouter/core/lib/resolve/resolveContext.js\");\nvar lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ \"./node_modules/@uirouter/core/lib/hooks/lazyLoad.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathUtils.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    ;\n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = common_1.extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return coreservices_1.services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathUtils.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlU2VydmljZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVTZXJ2aWNlLmpzP2Y1ODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHN0YXRlXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHF1ZXVlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3F1ZXVlXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGF0aEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhGYWN0b3J5XCIpO1xudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoTm9kZVwiKTtcbnZhciB0cmFuc2l0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2VcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcbnZhciBsYXp5TG9hZF8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2xhenlMb2FkXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKipcbiAqIFByb3ZpZGVzIHN0YXRlIHJlbGF0ZWQgc2VydmljZSBmdW5jdGlvbnNcbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdWktcm91dGVyIHN0YXRlcy5cbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgbG9jYXRlZCBvbiB0aGUgZ2xvYmFsIFtbVUlSb3V0ZXJdXSBvYmplY3QuXG4gKi9cbnZhciBTdGF0ZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZVNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gJGRlZmF1bHRFcnJvckhhbmRsZXIoJGVycm9yJCkge1xuICAgICAgICAgICAgaWYgKCRlcnJvciQgaW5zdGFuY2VvZiBFcnJvciAmJiAkZXJyb3IkLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCRlcnJvciQuZGV0YWlsICYmICRlcnJvciQuZGV0YWlsLnN0YWNrKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuZGV0YWlsLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXR0ZXJzID0gWydjdXJyZW50JywgJyRjdXJyZW50JywgJ3BhcmFtcycsICd0cmFuc2l0aW9uJ107XG4gICAgICAgIHZhciBib3VuZEZucyA9IE9iamVjdC5rZXlzKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLmZpbHRlcihob2ZfMS5ub3QoY29tbW9uXzEuaW5BcnJheShnZXR0ZXJzKSkpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSwgYm91bmRGbnMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJ0cmFuc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBbW1RyYW5zaXRpb25dXSBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgKG9yIG51bGwpXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLnRyYW5zaXRpb25dXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb247IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgc3RhdGUgcGFyYW1ldGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy5wYXJhbXNdXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLnBhcmFtczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwiY3VycmVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBbW1N0YXRlRGVjbGFyYXRpb25dXVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy5jdXJyZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5jdXJyZW50OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCIkY3VycmVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBbW1N0YXRlT2JqZWN0XV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuJGN1cnJlbnRdXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLiRjdXJyZW50OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoY29tbW9uXzEubm9vcCk7XG4gICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcyA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3Igd2hlbiBbW3RyYW5zaXRpb25Ub11dIGlzIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBJbnZva2VzIHRoZSBbW29uSW52YWxpZF1dIGNhbGxiYWNrcywgaW4gbmF0dXJhbCBvcmRlci5cbiAgICAgKiBFYWNoIGNhbGxiYWNrJ3MgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQgaW4gc2VxdWVuY2UgdW50aWwgb25lIG9mIHRoZW0gcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBUYXJnZXRTdGF0ZS5cbiAgICAgKiBUaGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2tzIGFyZSB3cmFwcGVkIGluICRxLndoZW4oKSwgc28gdGhlIGNhbGxiYWNrcyBtYXkgcmV0dXJuIHByb21pc2VzLlxuICAgICAqXG4gICAgICogSWYgYSBjYWxsYmFjayByZXR1cm5zIGFuIFRhcmdldFN0YXRlLCB0aGVuIGl0IGlzIHVzZWQgYXMgYXJndW1lbnRzIHRvICRzdGF0ZS50cmFuc2l0aW9uVG8oKSBhbmQgdGhlIHJlc3VsdCByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9TdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVN0YXRlID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlKGZyb21QYXRoKTtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICB2YXIgbGF0ZXN0VGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5LnBlZWtUYWlsKCk7IH07XG4gICAgICAgIHZhciBsYXRlc3QgPSBsYXRlc3RUaGluZygpO1xuICAgICAgICB2YXIgY2FsbGJhY2tRdWV1ZSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKHRoaXMuaW52YWxpZENhbGxiYWNrcy5zbGljZSgpKTtcbiAgICAgICAgdmFyIGluamVjdG9yID0gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQoZnJvbVBhdGgpLmluamVjdG9yKCk7XG4gICAgICAgIHZhciBjaGVja0ZvclJlZGlyZWN0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmVzdWx0O1xuICAgICAgICAgICAgLy8gUmVjcmVhdGUgdGhlIFRhcmdldFN0YXRlLCBpbiBjYXNlIHRoZSBzdGF0ZSBpcyBub3cgZGVmaW5lZC5cbiAgICAgICAgICAgIHRhcmdldCA9IF90aGlzLnRhcmdldCh0YXJnZXQuaWRlbnRpZmllcigpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQudmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmludmFsaWQodGFyZ2V0LmVycm9yKCkpLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhdGVzdFRoaW5nKCkgIT09IGxhdGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnN1cGVyc2VkZWQoKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2l0aW9uVG8odGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlTmV4dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgdmFyIG5leHRDYWxsYmFjayA9IGNhbGxiYWNrUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgaWYgKG5leHRDYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmludmFsaWQodG9TdGF0ZS5lcnJvcigpKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4obmV4dENhbGxiYWNrKHRvU3RhdGUsIGZyb21TdGF0ZSwgaW5qZWN0b3IpKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1Jlc3VsdC50aGVuKGNoZWNrRm9yUmVkaXJlY3QpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IHx8IGludm9rZU5leHRDYWxsYmFjaygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52b2tlTmV4dENhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gSW52YWxpZCBTdGF0ZSBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBSZWdpc3RlcnMgYSBbW09uSW52YWxpZENhbGxiYWNrXV0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAgICogaGFzIGJlZW4gY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZSByZWZlcmVuY2UgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogc3RhdGVTZXJ2aWNlLm9uSW52YWxpZChmdW5jdGlvbih0bywgZnJvbSwgaW5qZWN0b3IpIHtcbiAgICAgKiAgIGlmICh0by5uYW1lKCkgPT09ICdmb28nKSB7XG4gICAgICogICAgIGxldCBsYXp5TG9hZGVyID0gaW5qZWN0b3IuZ2V0KCdMYXp5TG9hZFNlcnZpY2UnKTtcbiAgICAgKiAgICAgcmV0dXJuIGxhenlMb2FkZXIubG9hZCgnZm9vJylcbiAgICAgKiAgICAgICAgIC50aGVuKCgpID0+IHN0YXRlU2VydmljZS50YXJnZXQoJ2ZvbycpKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgdG9TdGF0ZSBpcyBpbnZhbGlkXG4gICAgICogICBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSAoaW52YWxpZCkgdG9TdGF0ZSwgdGhlIGZyb21TdGF0ZSwgYW5kIGFuIGluamVjdG9yLlxuICAgICAqICAgVGhlIGZ1bmN0aW9uIG1heSBvcHRpb25hbGx5IHJldHVybiBhIFtbVGFyZ2V0U3RhdGVdXSBvciBhIFByb21pc2UgZm9yIGEgVGFyZ2V0U3RhdGUuXG4gICAgICogICBJZiBvbmUgaXMgcmV0dXJuZWQsIGl0IGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5vbkludmFsaWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLmludmFsaWRDYWxsYmFja3MpKGNhbGxiYWNrKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQSBtZXRob2QgdGhhdCBmb3JjZSByZWxvYWRzIHRoZSBjdXJyZW50IHN0YXRlLCBvciBhIHBhcnRpYWwgc3RhdGUgaGllcmFyY2h5LlxuICAgICAqIEFsbCByZXNvbHZlcyBhcmUgcmUtcmVzb2x2ZWQsIGFuZCBjb21wb25lbnRzIHJlaW5zdGFudGlhdGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGU6IGByZWxvYWQoKWAgaXMganVzdCBhbiBhbGlhcyBmb3I6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZS50cmFuc2l0aW9uVG8oJHN0YXRlLmN1cnJlbnQsICRzdGF0ZS5wYXJhbXMsIHtcbiAgICAgKiAgIHJlbG9hZDogdHJ1ZSwgaW5oZXJpdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxvYWRTdGF0ZSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QuXG4gICAgICogICAgSWYgcHJlc2VudCwgdGhpcyBzdGF0ZSBhbmQgYWxsIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHJlbG9hZGVkLCBidXQgYW5jZXN0b3JzIHdpbGwgbm90IHJlbG9hZC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vYXNzdW1pbmcgYXBwIGFwcGxpY2F0aW9uIGNvbnNpc3RzIG9mIDMgc3RhdGVzOiAnY29udGFjdHMnLCAnY29udGFjdHMuZGV0YWlsJywgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgICAqIC8vYW5kIGN1cnJlbnQgc3RhdGUgaXMgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAvL3dpbGwgcmVsb2FkICdjb250YWN0LmRldGFpbCcgYW5kIG5lc3RlZCAnY29udGFjdC5kZXRhaWwuaXRlbScgc3RhdGVzXG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZSBbW1N0YXRlU2VydmljZS5nb11dXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAocmVsb2FkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRoaXMuY3VycmVudCwgdGhpcy5wYXJhbXMsIHtcbiAgICAgICAgICAgIHJlbG9hZDogcHJlZGljYXRlc18xLmlzRGVmaW5lZChyZWxvYWRTdGF0ZSkgPyByZWxvYWRTdGF0ZSA6IHRydWUsXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIG5vdGlmeTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gdG8gYSBkaWZmZXJlbnQgc3RhdGUgYW5kL29yIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGAkc3RhdGUuZ29gIGNhbGxzIGAkc3RhdGUudHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5IGJ1dCBhdXRvbWF0aWNhbGx5IHNldHMgb3B0aW9ucyB0b1xuICAgICAqIGB7IGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogcm91dGVyLmdsb2JhbHMuJGN1cnJlbnQsIG5vdGlmeTogdHJ1ZSB9YC5cbiAgICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gdXNlIGVpdGhlciBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSBgdG9gIGFyZ3VtZW50IChiZWNhdXNlIG9mIGByZWxhdGl2ZTogcm91dGVyLmdsb2JhbHMuJGN1cnJlbnRgKS5cbiAgICAgKiBJdCBhbHNvIGFsbG93cyB5b3UgdG8gc3BlY2lmeSAqIG9ubHkgdGhlIHBhcmFtZXRlcnMgeW91J2QgbGlrZSB0byB1cGRhdGUsIHdoaWxlIGxldHRpbmcgdW5zcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzIChiZWNhdXNlIG9mIGBpbmhlcml0OiB0cnVlYCkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byBBYnNvbHV0ZSBzdGF0ZSBuYW1lLCBzdGF0ZSBvYmplY3QsIG9yIHJlbGF0aXZlIHN0YXRlIHBhdGggKHJlbGF0aXZlIHRvIGN1cnJlbnQgc3RhdGUpLlxuICAgICAqXG4gICAgICogU29tZSBleGFtcGxlczpcbiAgICAgKlxuICAgICAqIC0gYCRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKWAgLSB3aWxsIGdvIHRvIHRoZSBgY29udGFjdC5kZXRhaWxgIHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCdeJylgIC0gd2lsbCBnbyB0byB0aGUgcGFyZW50IHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCdeLnNpYmxpbmcnKWAgLSBpZiBjdXJyZW50IHN0YXRlIGlzIGBob21lLmNoaWxkYCwgd2lsbCBnbyB0byB0aGUgYGhvbWUuc2libGluZ2Agc3RhdGVcbiAgICAgKiAtIGAkc3RhdGUuZ28oJy5jaGlsZC5ncmFuZGNoaWxkJylgIC0gaWYgY3VycmVudCBzdGF0ZSBpcyBob21lLCB3aWxsIGdvIHRvIHRoZSBgaG9tZS5jaGlsZC5ncmFuZGNoaWxkYCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsIHdpbGwgcG9wdWxhdGUgJHN0YXRlUGFyYW1zLlxuICAgICAqXG4gICAgICogICAgQW55IHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNwZWNpZmllZCB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxuICAgICAqICAgIFRoaXMgYWxsb3dzLCBmb3IgZXhhbXBsZSwgZ29pbmcgdG8gYSBzaWJsaW5nIHN0YXRlIHRoYXQgc2hhcmVzIHBhcmFtZXRlcnMgZGVmaW5lZCBieSBhIHBhcmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge3Byb21pc2V9IEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKHRvLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1dEdvT3B0cyA9IHsgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQsIGluaGVyaXQ6IHRydWUgfTtcbiAgICAgICAgdmFyIHRyYW5zT3B0cyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1dEdvT3B0cywgdHJhbnNpdGlvblNlcnZpY2VfMS5kZWZhdWx0VHJhbnNPcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRvLCBwYXJhbXMsIHRyYW5zT3B0cyk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFtbVGFyZ2V0U3RhdGVdXVxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhIFRhcmdldFN0YXRlXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZXR1cm5lZCBmcm9tIGEgVHJhbnNpdGlvbiBIb29rIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiwgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS50YXJnZXQgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIElmIHdlJ3JlIHJlbG9hZGluZywgZmluZCB0aGUgc3RhdGUgb2JqZWN0IHRvIHJlbG9hZCBmcm9tXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3Qob3B0aW9ucy5yZWxvYWQpICYmICFvcHRpb25zLnJlbG9hZC5uYW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbG9hZCBzdGF0ZSBvYmplY3QnKTtcbiAgICAgICAgdmFyIHJlZyA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnk7XG4gICAgICAgIG9wdGlvbnMucmVsb2FkU3RhdGUgPSBvcHRpb25zLnJlbG9hZCA9PT0gdHJ1ZSA/IHJlZy5yb290KCkgOiByZWcubWF0Y2hlci5maW5kKG9wdGlvbnMucmVsb2FkLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsb2FkICYmICFvcHRpb25zLnJlbG9hZFN0YXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCByZWxvYWQgc3RhdGUgJ1wiICsgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvcHRpb25zLnJlbG9hZCkgPyBvcHRpb25zLnJlbG9hZCA6IG9wdGlvbnMucmVsb2FkLm5hbWUpICsgXCInXCIpO1xuICAgICAgICB2YXIgc3RhdGVEZWZpbml0aW9uID0gcmVnLm1hdGNoZXIuZmluZChpZGVudGlmaWVyLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKGlkZW50aWZpZXIsIHN0YXRlRGVmaW5pdGlvbiwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIDtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2xvYmFscyA9IHRoaXMucm91dGVyLmdsb2JhbHM7XG4gICAgICAgIHZhciBsYXRlc3RTdWNjZXNzID0gZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMucGVla1RhaWwoKTtcbiAgICAgICAgdmFyIHJvb3RQYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW25ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKF90aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSldOyB9O1xuICAgICAgICByZXR1cm4gbGF0ZXN0U3VjY2VzcyA/IGxhdGVzdFN1Y2Nlc3MudHJlZUNoYW5nZXMoKS50byA6IHJvb3RQYXRoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgICAqXG4gICAgICogVGhlIFtbZ29dXSBtZXRob2QgKHdoaWNoIHVzZXMgYHRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSkgaXMgcmVjb21tZW5kZWQgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIFN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0b1BhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXG4gICAgICogICAgICB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbZ29dXVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodG9QYXJhbXMgPT09IHZvaWQgMCkgeyB0b1BhcmFtcyA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHZhciBnZXRDdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZChvcHRpb25zLCB7IGN1cnJlbnQ6IGdldEN1cnJlbnQgfSk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnRhcmdldCh0bywgdG9QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XG4gICAgICAgIGlmICghcmVmLmV4aXN0cygpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZShjdXJyZW50UGF0aCwgcmVmKTtcbiAgICAgICAgaWYgKCFyZWYudmFsaWQoKSlcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5zaWxlbnRSZWplY3Rpb24ocmVmLmVycm9yKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lhbCBoYW5kbGluZyBmb3IgSWdub3JlZCwgQWJvcnRlZCwgYW5kIFJlZGlyZWN0ZWQgdHJhbnNpdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNlbWFudGljcyBmb3IgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBhbmQgdGhlIFN0YXRlU2VydmljZS50cmFuc2l0aW9uVG8oKVxuICAgICAgICAgKiBwcm9taXNlIGRpZmZlci4gRm9yIGluc3RhbmNlLCB0aGUgcnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBpdCB3YXNcbiAgICAgICAgICogSUdOT1JFRCwgYnV0IHRoZSB0cmFuc2l0aW9uVG8oKSBwcm9taXNlIGlzIHJlc29sdmVkIGJlY2F1c2UgZnJvbSB0aGUgdXNlciBwZXJzcGVjdGl2ZVxuICAgICAgICAgKiBubyBlcnJvciBvY2N1cnJlZC4gIExpa2V3aXNlLCB0aGUgdHJhbnNpdGlvbi5ydW4oKSBwcm9taXNlIG1heSBiZSByZWplY3RlZCBiZWNhdXNlIG9mXG4gICAgICAgICAqIGEgUmVkaXJlY3QsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyBjaGFpbmVkIHRvIHRoZSBuZXcgVHJhbnNpdGlvbidzIHByb21pc2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNMYXRlc3QgPSByb3V0ZXIuZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9PT0gdHJhbnNpdGlvbi4kaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IHJlamVjdEZhY3RvcnlfMS5SZWplY3RUeXBlLklHTk9SRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgaWdub3JlZCBgVHJhbnNpdGlvbi5ydW4oKWAgYXMgYSBzdWNjZXNzZnVsIGB0cmFuc2l0aW9uVG9gXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKGdsb2JhbHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZXRhaWwgPSBlcnJvci5kZXRhaWw7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IHJlamVjdEZhY3RvcnlfMS5SZWplY3RUeXBlLlNVUEVSU0VERUQgJiYgZXJyb3IucmVkaXJlY3RlZCAmJiBkZXRhaWwgaW5zdGFuY2VvZiB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGBUcmFuc2l0aW9uLnJ1bigpYCB3YXMgcmVkaXJlY3RlZCwgYWxsb3cgdGhlIGB0cmFuc2l0aW9uVG8oKWAgcHJvbWlzZSB0byByZXNvbHZlIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBieSByZXR1cm5pbmcgdGhlIHByb21pc2UgZm9yIHRoZSBuZXcgKHJlZGlyZWN0KSBgVHJhbnNpdGlvbi5ydW4oKWAuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWRpcmVjdCA9IHRyYW5zaXRpb24ucmVkaXJlY3QoZGV0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0LnJ1bigpLmNhdGNoKHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIocmVkaXJlY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IHJlamVjdEZhY3RvcnlfMS5SZWplY3RUeXBlLkFCT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHJlZik7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uVG9Qcm9taXNlID0gdHJhbnNpdGlvbi5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHRyYW5zaXRpb24pKTtcbiAgICAgICAgY29tbW9uXzEuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKHRyYW5zaXRpb25Ub1Byb21pc2UpOyAvLyBpc3N1ZSAjMjY3NlxuICAgICAgICAvLyBSZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgdHJhbnNpdGlvbiwgd2hpY2ggYWxzbyBoYXMgdGhlIHRyYW5zaXRpb24gb2JqZWN0IG9uIGl0LlxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRyYW5zaXRpb25Ub1Byb21pc2UsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiB9KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgc3RhdGUgKmlzKiB0aGUgcHJvdmlkZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIFNpbWlsYXIgdG8gW1tpbmNsdWRlc11dIGJ1dCBvbmx5IGNoZWNrcyBmb3IgdGhlIGZ1bGwgc3RhdGUgbmFtZS5cbiAgICAgKiBJZiBwYXJhbXMgaXMgc3VwcGxpZWQgdGhlbiBpdCB3aWxsIGJlIHRlc3RlZCBmb3Igc3RyaWN0IGVxdWFsaXR5IGFnYWluc3QgdGhlIGN1cnJlbnRcbiAgICAgKiBhY3RpdmUgcGFyYW1zIG9iamVjdCwgc28gYWxsIHBhcmFtcyBtdXN0IG1hdGNoIHdpdGggbm9uZSBtaXNzaW5nIGFuZCBubyBleHRyYXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nO1xuICAgICAqXG4gICAgICogLy8gYWJzb2x1dGUgbmFtZVxuICAgICAqICRzdGF0ZS5pcygnY29udGFjdC5kZXRhaWxzLml0ZW0nKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmlzKGNvbnRhY3REZXRhaWxJdGVtU3RhdGVPYmplY3QpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIC8vIHJlbGF0aXZlIG5hbWUgKC4gYW5kIF4pLCB0eXBpY2FsbHkgZnJvbSBhIHRlbXBsYXRlXG4gICAgICogLy8gRS5nLiBmcm9tIHRoZSAnY29udGFjdHMuZGV0YWlscycgdGVtcGxhdGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBuZy1jbGFzcz1cIntoaWdobGlnaHRlZDogJHN0YXRlLmlzKCcuaXRlbScpfVwiPkl0ZW08L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBUaGUgc3RhdGUgbmFtZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpIG9yIHN0YXRlIG9iamVjdCB5b3UnZCBsaWtlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCwgdGhhdCB5b3UnZCBsaWtlXG4gICAgICogdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqICAgLSBgcmVsYXRpdmVgOiBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcbiAgICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGl0IGlzIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHsgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQgfSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLiRjdXJyZW50ICE9PSBzdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJhbXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IHBhcmFtcyB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uZXF1YWxzKHNjaGVtYSwgcGFyYW1fMS5QYXJhbS52YWx1ZXMoc2NoZW1hLCBwYXJhbXMpLCB0aGlzLnBhcmFtcyk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppbmNsdWRlcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBBIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlIGlzIGVxdWFsIHRvIG9yIGlzIHRoZSBjaGlsZCBvZiB0aGVcbiAgICAgKiBzdGF0ZSBzdGF0ZU5hbWUuIElmIGFueSBwYXJhbXMgYXJlIHBhc3NlZCB0aGVuIHRoZXkgd2lsbCBiZSB0ZXN0ZWQgZm9yIGEgbWF0Y2ggYXMgd2VsbC5cbiAgICAgKiBOb3QgYWxsIHRoZSBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgcGFzc2VkLCBqdXN0IHRoZSBvbmVzIHlvdSdkIGxpa2UgdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGUgd2hlbiBgJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nYFxuICAgICAqIGBgYGpzXG4gICAgICogLy8gVXNpbmcgcGFydGlhbCBuYW1lc1xuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5kZXRhaWxzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5kZXRhaWxzLml0ZW1cIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmxpc3RcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJhYm91dFwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBHbG9iIEV4YW1wbGVzIHdoZW4gYCogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0udXJsJ2A6XG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi4qXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIioqLml0ZW0uKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy5pdGVtLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioudXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKlwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIml0ZW0uKipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBBIHBhcnRpYWwgbmFtZSwgcmVsYXRpdmUgbmFtZSwgZ2xvYiBwYXR0ZXJuLFxuICAgICAqICAgb3Igc3RhdGUgb2JqZWN0IHRvIGJlIHNlYXJjaGVkIGZvciB3aXRoaW4gdGhlIGN1cnJlbnQgc3RhdGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsXG4gICAgICogICB0aGF0IHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqICAgLSBgcmVsYXRpdmVgOiBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcbiAgICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBpdCBkb2VzIGluY2x1ZGUgdGhlIHN0YXRlXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgICAgICB2YXIgZ2xvYiA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSkgJiYgZ2xvYl8xLkdsb2IuZnJvbVN0cmluZyhzdGF0ZU9yTmFtZSk7XG4gICAgICAgIGlmIChnbG9iKSB7XG4gICAgICAgICAgICBpZiAoIWdsb2IubWF0Y2hlcyh0aGlzLiRjdXJyZW50Lm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlT3JOYW1lID0gdGhpcy4kY3VycmVudC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKSwgaW5jbHVkZSA9IHRoaXMuJGN1cnJlbnQuaW5jbHVkZXM7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoaW5jbHVkZVtzdGF0ZS5uYW1lXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYSBzdGF0ZSBhbmQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgdXJsIGZvciB0aGUgZ2l2ZW4gc3RhdGUgcG9wdWxhdGVkIHdpdGggdGhlIGdpdmVuIHBhcmFtcy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4cGVjdCgkc3RhdGUuaHJlZihcImFib3V0LnBlcnNvblwiLCB7IHBlcnNvbjogXCJib2JcIiB9KSkudG9FcXVhbChcIi9hYm91dC9ib2JcIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIHN0YXRlJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29tcGlsZWQgc3RhdGUgdXJsXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRIcmVmT3B0cyA9IHtcbiAgICAgICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdEhyZWZPcHRzKTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdClcbiAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zLiRpbmhlcml0KHBhcmFtcywgdGhpcy4kY3VycmVudCwgc3RhdGUpO1xuICAgICAgICB2YXIgbmF2ID0gKHN0YXRlICYmIG9wdGlvbnMubG9zc3kpID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XG4gICAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsUm91dGVyLmhyZWYobmF2LnVybCwgcGFyYW1zLCB7XG4gICAgICAgICAgICBhYnNvbHV0ZTogb3B0aW9ucy5hYnNvbHV0ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBkZWZhdWx0IFtbdHJhbnNpdGlvblRvXV0gZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoZSBlcnJvciBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuIGEgW1tUcmFuc2l0aW9uXV0gaXMgcmVqZWN0ZWQgb3Igd2hlbiBhbnkgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgZXJyb3JzIGNhdXNlZCBieSByZXNvbHZlcyBhbmQgdHJhbnNpdGlvbiBob29rcy5cbiAgICAgKlxuICAgICAqIE5vdGU6XG4gICAgICogVGhpcyBoYW5kbGVyIGRvZXMgbm90IHJlY2VpdmUgY2VydGFpbiBUcmFuc2l0aW9uIHJlamVjdGlvbnMuXG4gICAgICogUmVkaXJlY3RlZCBhbmQgSWdub3JlZCBUcmFuc2l0aW9ucyBhcmUgbm90IGNvbnNpZGVyZWQgdG8gYmUgZXJyb3JzIGJ5IFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dLlxuICAgICAqXG4gICAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBsb2dzIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBjdXN0b20gaGFuZGxlci5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKGZ1bmN0aW9uKCkge1xuICAgICAqICAgLy8gRG8gbm90IGxvZyB0cmFuc2l0aW9uVG8gZXJyb3JzXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlciBhIGdsb2JhbCBlcnJvciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgZ2xvYmFsIGVycm9yIGhhbmRsZXJcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGhhbmRsZXIgfHwgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlcjtcbiAgICB9O1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlKSB7XG4gICAgICAgIHZhciByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByZWcuZ2V0KCk7XG4gICAgICAgIHJldHVybiByZWcuZ2V0KHN0YXRlT3JOYW1lLCBiYXNlIHx8IHRoaXMuJGN1cnJlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGF6eSBsb2FkcyBhIHN0YXRlXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdGx5IHJ1bnMgYSBzdGF0ZSdzIFtbU3RhdGVEZWNsYXJhdGlvbi5sYXp5TG9hZF1dIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSB0aGF0IHNob3VsZCBiZSBsYXp5IGxvYWRlZFxuICAgICAqIEBwYXJhbSB0cmFuc2l0aW9uIHRoZSBvcHRpb25hbCBUcmFuc2l0aW9uIGNvbnRleHQgdG8gdXNlIChpZiB0aGUgbGF6eUxvYWQgZnVuY3Rpb24gcmVxdWlyZXMgYW4gaW5qZWN0b3IsIGV0YylcbiAgICAgKiBOb3RlOiBJZiBubyB0cmFuc2l0aW9uIGlzIHByb3ZpZGVkLCBhIG5vb3AgdHJhbnNpdGlvbiBpcyBjcmVhdGVkIHVzaW5nIHRoZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIFRoaXMgbm9vcCB0cmFuc2l0aW9uIGlzIG5vdCBhY3R1YWxseSBydW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdG8gbGF6eSBsb2FkXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5sYXp5TG9hZCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgdHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldChzdGF0ZU9yTmFtZSk7XG4gICAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmxhenlMb2FkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBsYXp5IGxvYWQgXCIgKyBzdGF0ZU9yTmFtZSk7XG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuZ2V0Q3VycmVudFBhdGgoKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZShjdXJyZW50UGF0aCk7XG4gICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHx8IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZShjdXJyZW50UGF0aCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGxhenlMb2FkXzEubGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVTZXJ2aWNlID0gU3RhdGVTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVTZXJ2aWNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/stateService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/targetState.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/targetState.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS90YXJnZXRTdGF0ZS5qcz9hMDUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBzdGF0ZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBFbmNhcHN1bGF0ZSB0aGUgdGFyZ2V0IChkZXN0aW5hdGlvbikgc3RhdGUvcGFyYW1zL29wdGlvbnMgb2YgYSBbW1RyYW5zaXRpb25dXS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGZyZXF1ZW50bHkgdXNlZCB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgZGVzdGluYXRpb24uXG4gKlxuICogU2VlOlxuICpcbiAqIC0gW1tIb29rUmVzdWx0XV1cbiAqIC0gW1tUcmFuc2l0aW9uSG9va0ZuXV1cbiAqIC0gW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cbiAqXG4gKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0uXG4gKlxuICogLS0tXG4gKlxuICogVGhpcyBjbGFzcyB3cmFwczpcbiAqXG4gKiAxKSBhbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlXG4gKiAyKSBhIHNldCBvZiBwYXJhbWV0ZXJzXG4gKiAzKSBhbmQgdHJhbnNpdGlvbiBvcHRpb25zXG4gKiA0KSB0aGUgcmVnaXN0ZXJlZCBzdGF0ZSBvYmplY3QgKHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSlcbiAqXG4gKiBNYW55IFVJLVJvdXRlciBBUElzIHN1Y2ggYXMgW1tTdGF0ZVNlcnZpY2UuZ29dXSB0YWtlIGEgW1tTdGF0ZU9yTmFtZV1dIGFyZ3VtZW50IHdoaWNoIGNhblxuICogZWl0aGVyIGJlIGEgKnN0YXRlIG9iamVjdCogKGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgW1tTdGF0ZU9iamVjdF1dKSBvciBhICpzdGF0ZSBuYW1lKiAoYSBzdHJpbmcpLlxuICogVGhlIGBUYXJnZXRTdGF0ZWAgY2xhc3Mgbm9ybWFsaXplcyB0aG9zZSBvcHRpb25zLlxuICpcbiAqIEEgYFRhcmdldFN0YXRlYCBtYXkgYmUgdmFsaWQgKHRoZSBzdGF0ZSBiZWluZyB0YXJnZXRlZCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5KVxuICogb3IgaW52YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGlzIG5vdCByZWdpc3RlcmVkKS5cbiAqL1xudmFyIFRhcmdldFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgVGFyZ2V0U3RhdGUgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIE5vdGU6IERvIG5vdCBjb25zdHJ1Y3QgYSBgVGFyZ2V0U3RhdGVgIG1hbnVhbGx5LlxuICAgICAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSB0aGUgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0gZmFjdG9yeSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2lkZW50aWZpZXIgQW4gaWRlbnRpZmllciBmb3IgYSBzdGF0ZS5cbiAgICAgKiAgICBFaXRoZXIgYSBmdWxseS1xdWFsaWZpZWQgc3RhdGUgbmFtZSwgb3IgdGhlIG9iamVjdCB1c2VkIHRvIGRlZmluZSB0aGUgc3RhdGUuXG4gICAgICogQHBhcmFtIF9kZWZpbml0aW9uIFRoZSBpbnRlcm5hbCBzdGF0ZSByZXByZXNlbnRhdGlvbiwgaWYgZXhpc3RzLlxuICAgICAqIEBwYXJhbSBfcGFyYW1zIFBhcmFtZXRlcnMgZm9yIHRoZSB0YXJnZXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gX29wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFyZ2V0U3RhdGUoX2lkZW50aWZpZXIsIF9kZWZpbml0aW9uLCBfcGFyYW1zLCBfb3B0aW9ucykge1xuICAgICAgICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkgeyBfb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IF9kZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IF9wYXJhbXMgfHwge307XG4gICAgfVxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdGhpcyBvYmplY3QgdGFyZ2V0cyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbiAmJiB0aGlzLl9kZWZpbml0aW9uLm5hbWUgfHwgdGhpcy5faWRlbnRpZmllcjtcbiAgICB9O1xuICAgIC8qKiBUaGUgaWRlbnRpZmllciB1c2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBUYXJnZXRTdGF0ZSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5pZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRlbnRpZmllcjtcbiAgICB9O1xuICAgIC8qKiBUaGUgdGFyZ2V0IHBhcmFtZXRlciB2YWx1ZXMgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgIH07XG4gICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvYmplY3QgKGlmIGl0IHdhcyBmb3VuZCkgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuJHN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICB9O1xuICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgZGVjbGFyYXRpb24gKGlmIGl0IHdhcyBmb3VuZCkgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24uc2VsZjtcbiAgICB9O1xuICAgIC8qKiBUaGUgdGFyZ2V0IG9wdGlvbnMgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfTtcbiAgICAvKiogVHJ1ZSBpZiB0aGUgdGFyZ2V0IHN0YXRlIHdhcyBmb3VuZCAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24uc2VsZik7XG4gICAgfTtcbiAgICAvKiogVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHZhbGlkICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXJyb3IoKTtcbiAgICB9O1xuICAgIC8qKiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHJldHVybnMgdGhlIHJlYXNvbiB3aHkgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXNlID0gdGhpcy5vcHRpb25zKCkucmVsYXRpdmU7XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbiAmJiAhIWJhc2UpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZU5hbWUgPSBiYXNlLm5hbWUgPyBiYXNlLm5hbWUgOiBiYXNlO1xuICAgICAgICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHJlc29sdmUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIicgZnJvbSBzdGF0ZSAnXCIgKyBzdGF0ZU5hbWUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RlZmluaXRpb24pXG4gICAgICAgICAgICByZXR1cm4gXCJObyBzdWNoIHN0YXRlICdcIiArIHRoaXMubmFtZSgpICsgXCInXCI7XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbi5zZWxmKVxuICAgICAgICAgICAgcmV0dXJuIFwiU3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIicgaGFzIGFuIGludmFsaWQgZGVmaW5pdGlvblwiO1xuICAgIH07XG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCInXCIgKyB0aGlzLm5hbWUoKSArIFwiJ1wiICsgY29tbW9uXzEudG9Kc29uKHRoaXMucGFyYW1zKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhcmdldFN0YXRlO1xufSgpKTtcbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xuVGFyZ2V0U3RhdGUuaXNEZWYgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvYmouc3RhdGUpIHx8IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvYmouc3RhdGUubmFtZSkpO1xufTtcbmV4cG9ydHMuVGFyZ2V0U3RhdGUgPSBUYXJnZXRTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcmdldFN0YXRlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/state/targetState.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/hookBuilder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/hookBuilder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\");\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ \"./node_modules/@uirouter/core/lib/transition/transitionHook.js\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanM/NWM0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXR1cm5zIGFwcGxpY2FibGUgVHJhbnNpdGlvbkhvb2tzIGZvciBhIHNwZWNpZmljIFRyYW5zaXRpb24gaW5zdGFuY2UuXG4gKlxuICogSG9va3MgKFtbUmVnaXN0ZXJlZEhvb2tdXSkgbWF5IGJlIHJlZ2lzdGVyZWQgZ2xvYmFsbHksIGUuZy4sICR0cmFuc2l0aW9ucy5vbkVudGVyKC4uLiksIG9yIGxvY2FsbHksIGUuZy5cbiAqIG15VHJhbnNpdGlvbi5vbkVudGVyKC4uLikuICBUaGUgSG9va0J1aWxkZXIgZmluZHMgbWF0Y2hpbmcgUmVnaXN0ZXJlZEhvb2tzICh3aGVyZSB0aGUgbWF0Y2ggY3JpdGVyaWEgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIHR5cGUgb2YgaG9vaylcbiAqXG4gKiBUaGUgSG9va0J1aWxkZXIgYWxzbyBjb252ZXJ0cyBSZWdpc3RlcmVkSG9va3Mgb2JqZWN0cyB0byBUcmFuc2l0aW9uSG9vayBvYmplY3RzLCB3aGljaCBhcmUgdXNlZCB0byBydW4gYSBUcmFuc2l0aW9uLlxuICpcbiAqIFRoZSBIb29rQnVpbGRlciBjb25zdHJ1Y3RvciBpcyBnaXZlbiB0aGUgJHRyYW5zaXRpb25zIHNlcnZpY2UgYW5kIGEgVHJhbnNpdGlvbiBpbnN0YW5jZS4gIFRodXMsIGEgSG9va0J1aWxkZXJcbiAqIGluc3RhbmNlIG1heSBvbmx5IGJlIHVzZWQgZm9yIG9uZSBzcGVjaWZpYyBUcmFuc2l0aW9uIG9iamVjdC4gKHNpZGUgbm90ZTogdGhlIF90cmVlQ2hhbmdlcyBhY2Nlc3NvciBpcyBwcml2YXRlXG4gKiBpbiB0aGUgVHJhbnNpdGlvbiBjbGFzcywgc28gd2UgbXVzdCBhbHNvIHByb3ZpZGUgdGhlIFRyYW5zaXRpb24ncyBfdHJlZUNoYW5nZXMpXG4gKlxuICovXG52YXIgSG9va0J1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvb2tCdWlsZGVyKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9XG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3NGb3JQaGFzZSA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcbiAgICAgICAgcmV0dXJuICR0cmFuc2l0aW9ucy5fcGx1Z2luYXBpLl9nZXRFdmVudHMocGhhc2UpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5idWlsZEhvb2tzKHR5cGUpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXdseSBidWlsdCBUcmFuc2l0aW9uSG9vayBvYmplY3RzLlxuICAgICAqXG4gICAgICogLSBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiBgaG9va1R5cGVgIHdoaWNoIG1hdGNoZWQgdGhlIHRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzXV0uXG4gICAgICogLSBGaW5kcyBbW1BhdGhOb2RlXV0gKG9yIGBQYXRoTm9kZVtdYCkgdG8gdXNlIGFzIHRoZSBUcmFuc2l0aW9uSG9vayBjb250ZXh0KHMpXG4gICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tQYXRoTm9kZV1dcywgY3JlYXRlcyBhIFRyYW5zaXRpb25Ib29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIHR5cGUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XG4gICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIG1hdGNoaW5nIHJlZ2lzdGVyZWQgaG9va3MgZm9yIGEgZ2l2ZW4gaG9vayB0eXBlXG4gICAgICAgIHZhciBtYXRjaGluZ0hvb2tzID0gdGhpcy5nZXRNYXRjaGluZ0hvb2tzKGhvb2tUeXBlLCB0cmVlQ2hhbmdlcyk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGJhc2VIb29rT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB0cmFuc2l0aW9uLm9wdGlvbnMoKS5jdXJyZW50XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBOb2RlcyB0aGF0IGNhdXNlZCB0aGlzIGhvb2sgdG8gbWF0Y2guXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdOb2RlcyA9IG1hdGNoZXNbaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGgubmFtZV07XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgSG9va1R1cGxlc1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogaG9vay5iaW5kLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZURhdGE6IHsgaG9va1R5cGU6IGhvb2tUeXBlLm5hbWUsIGNvbnRleHQ6IG5vZGUgfVxuICAgICAgICAgICAgICAgIH0sIGJhc2VIb29rT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGguc2NvcGUgPT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEUgPyBub2RlLnN0YXRlLnNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSG9vayA9IG5ldyB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlLCBob29rLCBfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaG9vazogaG9vaywgbm9kZTogbm9kZSwgdHJhbnNpdGlvbkhvb2s6IHRyYW5zaXRpb25Ib29rIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nSG9va3MubWFwKG1ha2VUcmFuc2l0aW9uSG9va3MpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLnNvcnQodHVwbGVTb3J0KGhvb2tUeXBlLnJldmVyc2VTb3J0KSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZS50cmFuc2l0aW9uSG9vazsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIGZyb206XG4gICAgICogLSBUaGUgVHJhbnNpdGlvbiBvYmplY3QgaW5zdGFuY2UgaG9vayByZWdpc3RyeVxuICAgICAqIC0gVGhlIFRyYW5zaXRpb25TZXJ2aWNlICgkdHJhbnNpdGlvbnMpIGdsb2JhbCBob29rIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiB3aGljaCBtYXRjaGVkOlxuICAgICAqIC0gdGhlIGV2ZW50VHlwZVxuICAgICAqIC0gdGhlIG1hdGNoQ3JpdGVyaWEgKHRvLCBmcm9tLCBleGl0aW5nLCByZXRhaW5lZCwgZW50ZXJpbmcpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVkIFtbUmVnaXN0ZXJlZEhvb2tdXXNcbiAgICAgKi9cbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdIb29rcyA9IGZ1bmN0aW9uIChob29rVHlwZSwgdHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIGlzQ3JlYXRlID0gaG9va1R5cGUuaG9va1BoYXNlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURTtcbiAgICAgICAgLy8gSW5zdGFuY2UgYW5kIEdsb2JhbCBob29rIHJlZ2lzdHJpZXNcbiAgICAgICAgdmFyICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgICAgIHZhciByZWdpc3RyaWVzID0gaXNDcmVhdGUgPyBbJHRyYW5zaXRpb25zXSA6IFt0aGlzLnRyYW5zaXRpb24sICR0cmFuc2l0aW9uc107XG4gICAgICAgIHJldHVybiByZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocmVnKSB7IHJldHVybiByZWcuZ2V0SG9va3MoaG9va1R5cGUubmFtZSk7IH0pIC8vIEdldCBuYW1lZCBob29rcyBmcm9tIHJlZ2lzdHJpZXNcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZXNfMS5pc0FycmF5LCBcImJyb2tlbiBldmVudCBuYW1lZDogXCIgKyBob29rVHlwZS5uYW1lKSkgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSAvLyBVbi1uZXN0IFJlZ2lzdGVyZWRIb29rW11bXSB0byBSZWdpc3RlcmVkSG9va1tdIGFycmF5XG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpOyB9KTsgLy8gT25seSB0aG9zZSBzYXRpc2Z5aW5nIG1hdGNoQ3JpdGVyaWFcbiAgICB9O1xuICAgIHJldHVybiBIb29rQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkhvb2tCdWlsZGVyID0gSG9va0J1aWxkZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgYSBzb3J0IGZ1bmN0aW9uIGZvciBIb29rVHVwbGVzLlxuICpcbiAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBQYXRoTm9kZSBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIHN0YXRlIHRyZWUgYSBub2RlIGlzKSwgdGhlbiBjb21wYXJlc1xuICogdGhlIEV2ZW50SG9vayBwcmlvcml0eS5cbiAqXG4gKiBAcGFyYW0gcmV2ZXJzZURlcHRoU29ydCBhIGJvb2xlYW4sIHdoZW4gdHJ1ZSwgcmV2ZXJzZXMgdGhlIHNvcnQgb3JkZXIgZm9yIHRoZSBub2RlIGRlcHRoXG4gKiBAcmV0dXJucyBhIHR1cGxlIHNvcnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdHVwbGVTb3J0KHJldmVyc2VEZXB0aFNvcnQpIHtcbiAgICBpZiAocmV2ZXJzZURlcHRoU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VEZXB0aFNvcnQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobCwgcikge1xuICAgICAgICB2YXIgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcbiAgICAgICAgdmFyIGRlcHRoRGVsdGEgPSAobC5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoIC0gci5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoKSAqIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rQnVpbGRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/hookBuilder.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/hookRegistry.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/hookRegistry.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\"); // has or is using\nvar glob_1 = __webpack_require__(/*! ../common/glob */ \"./node_modules/@uirouter/core/lib/common/glob.js\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va1JlZ2lzdHJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2hvb2tSZWdpc3RyeS5qcz82NzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gc3RhdGUgbWF0Y2hlcyB0aGUgbWF0Y2hDcml0ZXJpYVxuICpcbiAqIEBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgYSBTdGF0ZSBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0gY3JpdGVyaW9uXG4gKiAtIElmIGEgc3RyaW5nLCBtYXRjaFN0YXRlIHVzZXMgdGhlIHN0cmluZyBhcyBhIGdsb2ItbWF0Y2hlciBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAtIElmIGFuIGFycmF5IChvZiBzdHJpbmdzKSwgbWF0Y2hTdGF0ZSB1c2VzIGVhY2ggc3RyaW5nIGluIHRoZSBhcnJheSBhcyBhIGdsb2ItbWF0Y2hlcnMgYWdhaW5zdCB0aGUgc3RhdGUgbmFtZVxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG4gKiAtIElmIGEgZnVuY3Rpb24sIG1hdGNoU3RhdGUgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN0YXRlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IGlzIHRydXRoeS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaFN0YXRlKHN0YXRlLCBjcml0ZXJpb24pIHtcbiAgICB2YXIgdG9NYXRjaCA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhjcml0ZXJpb24pID8gW2NyaXRlcmlvbl0gOiBjcml0ZXJpb247XG4gICAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGUpIHtcbiAgICAgICAgdmFyIGdsb2JTdHJpbmdzID0gdG9NYXRjaDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iU3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdsb2IgPSBuZXcgZ2xvYl8xLkdsb2IoZ2xvYlN0cmluZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKChnbG9iICYmIGdsb2IubWF0Y2hlcyhfc3RhdGUubmFtZSkpIHx8ICghZ2xvYiAmJiBnbG9iU3RyaW5nc1tpXSA9PT0gX3N0YXRlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hGbiA9IChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih0b01hdGNoKSA/IHRvTWF0Y2ggOiBtYXRjaEdsb2JzKTtcbiAgICByZXR1cm4gISFtYXRjaEZuKHN0YXRlKTtcbn1cbmV4cG9ydHMubWF0Y2hTdGF0ZSA9IG1hdGNoU3RhdGU7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogVGhlIHJlZ2lzdHJhdGlvbiBkYXRhIGZvciBhIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rXG4gKi9cbnZhciBSZWdpc3RlcmVkSG9vayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnaXN0ZXJlZEhvb2sodHJhblN2YywgZXZlbnRUeXBlLCBjYWxsYmFjaywgbWF0Y2hDcml0ZXJpYSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnRyYW5TdmMgPSB0cmFuU3ZjO1xuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm1hdGNoQ3JpdGVyaWEgPSBtYXRjaENyaXRlcmlhO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eSB8fCAwO1xuICAgICAgICB0aGlzLmJpbmQgPSBvcHRpb25zLmJpbmQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fZGVyZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXNcbiAgICAgKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIFtbUGF0aE5vZGVdXXMsIGFuZCBhIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0sIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZ1xuICAgICAqIHRoZSBbW1BhdGhOb2RlXV1zIHRoYXQgdGhlIGNyaXRlcmlhIG1hdGNoZXMsIG9yIGBudWxsYCBpZiB0aGVyZSB3ZXJlIG5vIG1hdGNoaW5nIG5vZGVzLlxuICAgICAqXG4gICAgICogUmV0dXJuaW5nIGBudWxsYCBpcyBzaWduaWZpY2FudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBkZWZhdWx0XG4gICAgICogXCJtYXRjaC1hbGwgY3JpdGVyaW9uIHZhbHVlXCIgb2YgYHRydWVgIGNvbXBhcmVkIHRvIGEgYCgpID0+IHRydWVgIGZ1bmN0aW9uLFxuICAgICAqIHdoZW4gdGhlIG5vZGVzIGlzIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gYWxsb3cgYSB0cmFuc2l0aW9uIG1hdGNoIGNyaXRlcmlhIG9mIGBlbnRlcmluZzogdHJ1ZWBcbiAgICAgKiB0byBzdGlsbCBtYXRjaCBhIHRyYW5zaXRpb24sIGV2ZW4gd2hlbiBgZW50ZXJpbmcgPT09IFtdYC4gIENvbnRyYXN0IHRoYXRcbiAgICAgKiB3aXRoIGBlbnRlcmluZzogKHN0YXRlKSA9PiB0cnVlYCB3aGljaCBvbmx5IG1hdGNoZXMgd2hlbiBhIHN0YXRlIGlzIGFjdHVhbGx5XG4gICAgICogYmVpbmcgZW50ZXJlZC5cbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX21hdGNoaW5nTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNyaXRlcmlvbikge1xuICAgICAgICBpZiAoY3JpdGVyaW9uID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB2YXIgbWF0Y2hpbmcgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG1hdGNoU3RhdGUobm9kZS5zdGF0ZSwgY3JpdGVyaW9uKTsgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaGluZy5sZW5ndGggPyBtYXRjaGluZyA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1hdGNoIGNyaXRlcmlhIChhbGwgYHRydWVgKVxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggaGFzIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2ggcGF0aHMgYXMga2V5cyBhbmQgYHRydWVgIGFzIHZhbHVlcywgaS5lLjpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICoge1xuICAgICAqICAgdG86IHRydWUsXG4gICAgICogICBmcm9tOiB0cnVlLFxuICAgICAqICAgZW50ZXJpbmc6IHRydWUsXG4gICAgICogICBleGl0aW5nOiB0cnVlLFxuICAgICAqICAgcmV0YWluZWQ6IHRydWUsXG4gICAgICogfVxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5tYXAodGhpcy50cmFuU3ZjLl9wbHVnaW5hcGkuX2dldFBhdGhUeXBlcygpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgbWF0Y2hpbmcgbm9kZXMgYXMgW1tJTWF0Y2hpbmdOb2Rlc11dXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgZnJvbSB0aGUgVHJhbnNpdGlvbkhvb2tUeXBlcyB0aGF0IGlzIHJvdWdobHkgZXF1aXZhbGVudCB0bzpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IG1hdGNoZXM6IElNYXRjaGluZ05vZGVzID0ge1xuICAgICAqICAgdG86ICAgICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLnRvKV0sICAgbWMudG8pLFxuICAgICAqICAgZnJvbTogICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLmZyb20pXSwgbWMuZnJvbSksXG4gICAgICogICBleGl0aW5nOiAgX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZXhpdGluZywgICAgICBtYy5leGl0aW5nKSxcbiAgICAgKiAgIHJldGFpbmVkOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5yZXRhaW5lZCwgICAgIG1jLnJldGFpbmVkKSxcbiAgICAgKiAgIGVudGVyaW5nOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5lbnRlcmluZywgICAgIG1jLmVudGVyaW5nKSxcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5fZ2V0TWF0Y2hpbmdOb2RlcyA9IGZ1bmN0aW9uICh0cmVlQ2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBjb21tb25fMS5leHRlbmQodGhpcy5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEoKSwgdGhpcy5tYXRjaENyaXRlcmlhKTtcbiAgICAgICAgdmFyIHBhdGhzID0gY29tbW9uXzEudmFsdWVzKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSk7XG4gICAgICAgIHJldHVybiBwYXRocy5yZWR1Y2UoZnVuY3Rpb24gKG1uLCBwYXRodHlwZSkge1xuICAgICAgICAgICAgLy8gU1RBVEUgc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IGV2ZXJ5IG5vZGUgaW4gdGhlIHBhdGguXG4gICAgICAgICAgICAvLyBUUkFOU0lUSU9OIHNjb3BlIGNyaXRlcmlhIG1hdGNoZXMgYWdhaW5zdCBvbmx5IHRoZSBsYXN0IG5vZGUgaW4gdGhlIHBhdGhcbiAgICAgICAgICAgIHZhciBpc1N0YXRlSG9vayA9IHBhdGh0eXBlLnNjb3BlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlQ2hhbmdlc1twYXRodHlwZS5uYW1lXSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IGlzU3RhdGVIb29rID8gcGF0aCA6IFtjb21tb25fMS50YWlsKHBhdGgpXTtcbiAgICAgICAgICAgIG1uW3BhdGh0eXBlLm5hbWVdID0gX3RoaXMuX21hdGNoaW5nTm9kZXMobm9kZXMsIGNyaXRlcmlhW3BhdGh0eXBlLm5hbWVdKTtcbiAgICAgICAgICAgIHJldHVybiBtbjtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGhvb2sncyBbW21hdGNoQ3JpdGVyaWFdXSBtYXRjaCB0aGUgZ2l2ZW4gW1tUcmVlQ2hhbmdlc11dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QsIG9yIG51bGwuIElmIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIHZhbHVlc1xuICAgICAqIGFyZSB0aGUgbWF0Y2hpbmcgW1tQYXRoTm9kZV1dcyBmb3IgZWFjaCBbW0hvb2tNYXRjaENyaXRlcmlvbl1dICh0bywgZnJvbSwgZXhpdGluZywgcmV0YWluZWQsIGVudGVyaW5nKVxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5fZ2V0TWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgIC8vIENoZWNrIGlmIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2hlZCB0aGUgVHJlZUNoYW5nZXMgb2JqZWN0XG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gY29tbW9uXzEudmFsdWVzKG1hdGNoZXMpLmV2ZXJ5KGNvbW1vbl8xLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoZWQgPyBtYXRjaGVzIDogbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBSZWdpc3RlcmVkSG9vaztcbn0oKSk7XG5leHBvcnRzLlJlZ2lzdGVyZWRIb29rID0gUmVnaXN0ZXJlZEhvb2s7XG4vKiogQGhpZGRlbiBSZXR1cm4gYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gb2YgdGhlIHJlcXVlc3RlZCB0eXBlLiAqL1xuZnVuY3Rpb24gbWFrZUV2ZW50KHJlZ2lzdHJ5LCB0cmFuc2l0aW9uU2VydmljZSwgZXZlbnRUeXBlKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rcy5cbiAgICB2YXIgX3JlZ2lzdGVyZWRIb29rcyA9IHJlZ2lzdHJ5Ll9yZWdpc3RlcmVkSG9va3MgPSAocmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyB8fCB7fSk7XG4gICAgdmFyIGhvb2tzID0gX3JlZ2lzdGVyZWRIb29rc1tldmVudFR5cGUubmFtZV0gPSBbXTtcbiAgICAvLyBDcmVhdGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb24gb24gdGhlIElIb29rUmVnaXN0cnkgZm9yIHRoZSBldmVudFxuICAgIHJlZ2lzdHJ5W2V2ZW50VHlwZS5uYW1lXSA9IGhvb2tSZWdpc3RyYXRpb25GbjtcbiAgICBmdW5jdGlvbiBob29rUmVnaXN0cmF0aW9uRm4obWF0Y2hPYmplY3QsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByZWdpc3RlcmVkSG9vayA9IG5ldyBSZWdpc3RlcmVkSG9vayh0cmFuc2l0aW9uU2VydmljZSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgbWF0Y2hPYmplY3QsIG9wdGlvbnMpO1xuICAgICAgICBob29rcy5wdXNoKHJlZ2lzdGVyZWRIb29rKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJFdmVudEhvb2soKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkSG9vay5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20oaG9va3MpKHJlZ2lzdGVyZWRIb29rKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2tSZWdpc3RyYXRpb25Gbjtcbn1cbmV4cG9ydHMubWFrZUV2ZW50ID0gbWFrZUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va1JlZ2lzdHJ5LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/hookRegistry.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(__webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\"));\n__export(__webpack_require__(/*! ./hookBuilder */ \"./node_modules/@uirouter/core/lib/transition/hookBuilder.js\"));\n__export(__webpack_require__(/*! ./hookRegistry */ \"./node_modules/@uirouter/core/lib/transition/hookRegistry.js\"));\n__export(__webpack_require__(/*! ./rejectFactory */ \"./node_modules/@uirouter/core/lib/transition/rejectFactory.js\"));\n__export(__webpack_require__(/*! ./transition */ \"./node_modules/@uirouter/core/lib/transition/transition.js\"));\n__export(__webpack_require__(/*! ./transitionHook */ \"./node_modules/@uirouter/core/lib/transition/transitionHook.js\"));\n__export(__webpack_require__(/*! ./transitionEventType */ \"./node_modules/@uirouter/core/lib/transition/transitionEventType.js\"));\n__export(__webpack_require__(/*! ./transitionService */ \"./node_modules/@uirouter/core/lib/transition/transitionService.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW5kZXguanM/MmI2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqICMgVHJhbnNpdGlvbiBzdWJzeXN0ZW1cbiAqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBBUElzIHJlbGF0ZWQgdG8gYSBUcmFuc2l0aW9uLlxuICpcbiAqIFNlZTpcbiAqIC0gW1tUcmFuc2l0aW9uU2VydmljZV1dXG4gKiAtIFtbVHJhbnNpdGlvbl1dXG4gKiAtIFtbSG9va0ZuXV0sIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dLCBbW0hvb2tNYXRjaENyaXRlcmlhXV0sIFtbSG9va1Jlc3VsdF1dXG4gKlxuICogQGNvcmVhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvb2tCdWlsZGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvb2tSZWdpc3RyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZWplY3RGYWN0b3J5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uU2VydmljZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/interface.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/interface.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"RUN\"] = 2] = \"RUN\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW50ZXJmYWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qcz9kYTJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRyYW5zaXRpb25Ib29rUGhhc2U7XG4oZnVuY3Rpb24gKFRyYW5zaXRpb25Ib29rUGhhc2UpIHtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJDUkVBVEVcIl0gPSAwXSA9IFwiQ1JFQVRFXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiQkVGT1JFXCJdID0gMV0gPSBcIkJFRk9SRVwiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIlJVTlwiXSA9IDJdID0gXCJSVU5cIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJTVUNDRVNTXCJdID0gM10gPSBcIlNVQ0NFU1NcIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xufSkoVHJhbnNpdGlvbkhvb2tQaGFzZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tQaGFzZSB8fCAoZXhwb3J0cy5UcmFuc2l0aW9uSG9va1BoYXNlID0ge30pKTtcbnZhciBUcmFuc2l0aW9uSG9va1Njb3BlO1xuKGZ1bmN0aW9uIChUcmFuc2l0aW9uSG9va1Njb3BlKSB7XG4gICAgVHJhbnNpdGlvbkhvb2tTY29wZVtUcmFuc2l0aW9uSG9va1Njb3BlW1wiVFJBTlNJVElPTlwiXSA9IDBdID0gXCJUUkFOU0lUSU9OXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tTY29wZVtUcmFuc2l0aW9uSG9va1Njb3BlW1wiU1RBVEVcIl0gPSAxXSA9IFwiU1RBVEVcIjtcbn0pKFRyYW5zaXRpb25Ib29rU2NvcGUgPSBleHBvcnRzLlRyYW5zaXRpb25Ib29rU2NvcGUgfHwgKGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tTY29wZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/interface.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/rejectFactory.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\n/** @hidden */ var id = 0;\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return \"Transition Rejection($id: \" + $id + \" type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && hof_1.is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5LmpzPzBhYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFJlamVjdFR5cGU7XG4oZnVuY3Rpb24gKFJlamVjdFR5cGUpIHtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJTVVBFUlNFREVEXCJdID0gMl0gPSBcIlNVUEVSU0VERURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJBQk9SVEVEXCJdID0gM10gPSBcIkFCT1JURURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJJTlZBTElEXCJdID0gNF0gPSBcIklOVkFMSURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJJR05PUkVEXCJdID0gNV0gPSBcIklHTk9SRURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJFUlJPUlwiXSA9IDZdID0gXCJFUlJPUlwiO1xufSkoUmVqZWN0VHlwZSA9IGV4cG9ydHMuUmVqZWN0VHlwZSB8fCAoZXhwb3J0cy5SZWplY3RUeXBlID0ge30pKTtcbi8qKiBAaGlkZGVuICovIHZhciBpZCA9IDA7XG52YXIgUmVqZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWplY3Rpb24odHlwZSwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIHRoaXMuJGlkID0gaWQrKztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5kZXRhaWwgPSBkZXRhaWw7XG4gICAgfVxuICAgIFJlamVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXRhaWxTdHJpbmcgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQgJiYgZC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA/IGQudG9TdHJpbmcoKSA6IHN0cmluZ3NfMS5zdHJpbmdpZnkoZCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXRhaWwgPSBkZXRhaWxTdHJpbmcodGhpcy5kZXRhaWwpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCAkaWQgPSBfYS4kaWQsIHR5cGUgPSBfYS50eXBlLCBtZXNzYWdlID0gX2EubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIFwiVHJhbnNpdGlvbiBSZWplY3Rpb24oJGlkOiBcIiArICRpZCArIFwiIHR5cGU6IFwiICsgdHlwZSArIFwiLCBtZXNzYWdlOiBcIiArIG1lc3NhZ2UgKyBcIiwgZGV0YWlsOiBcIiArIGRldGFpbCArIFwiKVwiO1xuICAgIH07XG4gICAgUmVqZWN0aW9uLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKHRoaXMpLCB7IF90cmFuc2l0aW9uUmVqZWN0aW9uOiB0aGlzIH0pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqIGlzIGEgcmVqZWN0ZWQgcHJvbWlzZSBjcmVhdGVkIGZyb20gdGhlIGBhc1Byb21pc2VgIGZhY3RvcnkgKi9cbiAgICBSZWplY3Rpb24uaXNSZWplY3Rpb25Qcm9taXNlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmICh0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicpICYmIGhvZl8xLmlzKFJlamVjdGlvbikob2JqLl90cmFuc2l0aW9uUmVqZWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byB0cmFuc2l0aW9uIHN1cGVyc2VkZWQgKi9cbiAgICBSZWplY3Rpb24uc3VwZXJzZWRlZCA9IGZ1bmN0aW9uIChkZXRhaWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIGhhcyBiZWVuIHN1cGVyc2VkZWQgYnkgYSBkaWZmZXJlbnQgdHJhbnNpdGlvblwiO1xuICAgICAgICB2YXIgcmVqZWN0aW9uID0gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLlNVUEVSU0VERUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RlZCkge1xuICAgICAgICAgICAgcmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb247XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gcmVkaXJlY3RlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiBSZWplY3Rpb24uc3VwZXJzZWRlZChkZXRhaWwsIHsgcmVkaXJlY3RlZDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBpbnZhbGlkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uaW52YWxpZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoaXMgdHJhbnNpdGlvbiBpcyBpbnZhbGlkXCI7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuSU5WQUxJRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBpZ25vcmVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uaWdub3JlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkXCI7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuSUdOT1JFRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uYWJvcnRlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIGhhcyBiZWVuIGFib3J0ZWRcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5BQk9SVEVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5lcnJvcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHRyYW5zaXRpb24gZXJyb3JlZFwiO1xuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLkVSUk9SLCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFJlamVjdGlvblxuICAgICAqXG4gICAgICogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgUmVqZWN0aW9uLlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGEgUmVqZWN0aW9uLCByZXR1cm5zIGl0LlxuICAgICAqIE90aGVyd2lzZSwgd3JhcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIGFzIGEgUmVqZWN0aW9uIChSZWplY3Rpb24gdHlwZTogRVJST1IpLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYGRldGFpbGAgaWYgaXQgaXMgYWxyZWFkeSBhIGBSZWplY3Rpb25gLCBlbHNlIHJldHVybnMgYW4gRVJST1IgUmVqZWN0aW9uLlxuICAgICAqL1xuICAgIFJlamVjdGlvbi5ub3JtYWxpemUgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiBob2ZfMS5pcyhSZWplY3Rpb24pKGRldGFpbCkgPyBkZXRhaWwgOiBSZWplY3Rpb24uZXJyb3JlZChkZXRhaWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlamVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLlJlamVjdGlvbiA9IFJlamVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlamVjdEZhY3RvcnkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/rejectFactory.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transition.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transition.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\"); // has or is using\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ \"./node_modules/@uirouter/core/lib/transition/transitionHook.js\");\nvar hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ \"./node_modules/@uirouter/core/lib/transition/hookRegistry.js\");\nvar hookBuilder_1 = __webpack_require__(/*! ./hookBuilder */ \"./node_modules/@uirouter/core/lib/transition/hookBuilder.js\");\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ \"./node_modules/@uirouter/core/lib/path/pathFactory.js\");\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\nvar param_1 = __webpack_require__(/*! ../params/param */ \"./node_modules/@uirouter/core/lib/params/param.js\");\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ \"./node_modules/@uirouter/core/lib/resolve/resolvable.js\");\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ \"./node_modules/@uirouter/core/lib/resolve/resolveContext.js\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new hookBuilder_1.HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return \"SameAsPending\";\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return \"SameAsCurrent\";\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);\n            var done = function () { return coreservices_1.services.$q.when(undefined); };\n            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace_1.trace.traceTransitionStart(_this);\n            return coreservices_1.services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);\n        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (predicates_1.isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, [\"#\"]);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzPzIzNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpOyAvLyBoYXMgb3IgaXMgdXNpbmdcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgaG9va1JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIik7XG52YXIgaG9va0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2hvb2tCdWlsZGVyXCIpO1xudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBzdGF0ZVNlbGYgPSBob2ZfMS5wcm9wKFwic2VsZlwiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gc3RhdGVzLlxuICpcbiAqIFdoZW4gbmF2aWdhdGluZyB0byBhIHN0YXRlLCB3ZSBhcmUgdHJhbnNpdGlvbmluZyAqKmZyb20qKiB0aGUgY3VycmVudCBzdGF0ZSAqKnRvKiogdGhlIG5ldyBzdGF0ZS5cbiAqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdG8vZnJvbSBzdGF0ZXMsIHBhcmFtZXRlcnMsIHJlc29sdmVzLlxuICogSXQgaGFzIGluZm9ybWF0aW9uIGFib3V0IGFsbCBzdGF0ZXMgYmVpbmcgZW50ZXJlZCBhbmQgZXhpdGVkIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uLlxuICovXG52YXIgVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUcmFuc2l0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXJnZXQgc3RhdGUgaXMgbm90IHZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gaXMgbGVhdmluZy4gIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGBmcm9tUGF0aGBcbiAgICAgKiAgICAgICAgZW5jYXBzdWxhdGVzIHRoZSBcImZyb20gc3RhdGVcIi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgVGhlIHRhcmdldCBzdGF0ZSBhbmQgcGFyYW1ldGVycyBiZWluZyB0cmFuc2l0aW9uZWQgdG8gKGFsc28sIHRoZSB0cmFuc2l0aW9uIG9wdGlvbnMpXG4gICAgICogQHBhcmFtIHJvdXRlciBUaGUgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYmFzZWQgb24gdGhlIG91dGNvbWUgb2YgdGhlIFRyYW5zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyB1bnN1Y2Nlc3NmdWwsIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggdGhlIFtbUmVqZWN0aW9uXV0gb3IgamF2YXNjcmlwdCBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gSG9sZHMgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBzdWNoIGFzIHRob3NlIHBhc3NlZCB0byBUcmFuc2l0aW9uLm9uU3RhcnQoKSAqL1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5faG9va0J1aWxkZXIgPSBuZXcgaG9va0J1aWxkZXJfMS5Ib29rQnVpbGRlcih0aGlzKTtcbiAgICAgICAgLyoqIENoZWNrcyBpZiB0aGlzIHRyYW5zaXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZS9ydW5uaW5nLiAqL1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24gPT09IF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLl9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHsgY3VycmVudDogaG9mXzEudmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMuJGlkID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl90cmFuc2l0aW9uQ291bnQrKztcbiAgICAgICAgdmFyIHRvUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX3RyZWVDaGFuZ2VzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMudHJlZUNoYW5nZXMoZnJvbVBhdGgsIHRvUGF0aCwgdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMoKTtcbiAgICAgICAgdmFyIG9uQ3JlYXRlSG9va3MgPSB0aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKG9uQ3JlYXRlSG9va3MsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICB0aGlzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyKTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkJlZm9yZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblJldGFpbiA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRW50ZXIgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGhpZGRlblxuICAgICAqIENyZWF0ZXMgdGhlIHRyYW5zaXRpb24tbGV2ZWwgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zXG4gICAgICogKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3MpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl9wbHVnaW5hcGkuX2dldEV2ZW50cygpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSAhPT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KF90aGlzLCBfdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UsIHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRIb29rcyA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZEhvb2tzW2hvb2tOYW1lXTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBlbnRlcmluZ1N0YXRlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZTsgfSk7XG4gICAgICAgIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgZnJvbSBbU3RhdGVdIG9iamVjdFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiRmcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKS5zdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIHRvIFtTdGF0ZV0gb2JqZWN0XG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJHRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykuc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyAoXCJmcm9tIHN0YXRlXCIpLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tKCkuc2VsZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBnb2luZyAqdG8qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIEEgdHJhbnNpdGlvbidzIFtbVGFyZ2V0U3RhdGVdXSBlbmNhcHN1bGF0ZXMgdGhlIFtbdG9dXSBzdGF0ZSwgdGhlIFtbcGFyYW1zXV0sIGFuZCB0aGUgW1tvcHRpb25zXV0gYXMgYSBzaW5nbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFtbVGFyZ2V0U3RhdGVdXSBvZiB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50YXJnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB0cmFuc2l0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNvbXBhcmUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXMoeyB0bzogY29tcGFyZS4kdG8oKS5uYW1lLCBmcm9tOiBjb21wYXJlLiRmcm9tKCkubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISgoY29tcGFyZS50byAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiR0bygpLCBjb21wYXJlLnRvKSkgfHxcbiAgICAgICAgICAgIChjb21wYXJlLmZyb20gJiYgIWhvb2tSZWdpc3RyeV8xLm1hdGNoU3RhdGUodGhpcy4kZnJvbSgpLCBjb21wYXJlLmZyb20pKSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgW1tVSUluamVjdG9yXV0gRGVwZW5kZW5jeSBJbmplY3RvclxuICAgICAqXG4gICAgICogUmV0dXJucyBhIERlcGVuZGVuY3kgSW5qZWN0b3IgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgdGFyZ2V0IHN0YXRlICh0byBzdGF0ZSkuXG4gICAgICogVGhlIGluamVjdG9yIHByb3ZpZGVzIHJlc29sdmUgdmFsdWVzIHdoaWNoIHRoZSB0YXJnZXQgc3RhdGUgaGFzIGFjY2VzcyB0by5cbiAgICAgKlxuICAgICAqIFRoZSBgVUlJbmplY3RvcmAgY2FuIGFsc28gcHJvdmlkZSB2YWx1ZXMgZnJvbSB0aGUgbmF0aXZlIHJvb3QvZ2xvYmFsIGluamVjdG9yIChuZzEvbmcyKS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkVudGVyKHsgZW50ZXJpbmc6ICdteVN0YXRlJyB9LCB0cmFucyA9PiB7XG4gICAgICogICB2YXIgbXlSZXNvbHZlVmFsdWUgPSB0cmFucy5pbmplY3RvcigpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAgICogICAvLyBJbmplY3QgYSBnbG9iYWwgc2VydmljZSBmcm9tIHRoZSBnbG9iYWwvbmF0aXZlIGluamVjdG9yIChpZiBpdCBleGlzdHMpXG4gICAgICogICB2YXIgTXlTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015U2VydmljZScpO1xuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiBzb21lIGNhc2VzIChzdWNoIGFzIGBvbkJlZm9yZWApLCB5b3UgbWF5IG5lZWQgYWNjZXNzIHRvIHNvbWUgcmVzb2x2ZSBkYXRhIGJ1dCBpdCBoYXMgbm90IHlldCBiZWVuIGZldGNoZWQuXG4gICAgICogWW91IGNhbiB1c2UgW1tVSUluamVjdG9yLmdldEFzeW5jXV0gdG8gZ2V0IGEgcHJvbWlzZSBmb3IgdGhlIGRhdGEuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uQmVmb3JlKHt9LCB0cmFucyA9PiB7XG4gICAgICogICByZXR1cm4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYygnbXlSZXNvbHZlJykudGhlbihteVJlc29sdmVWYWx1ZSA9PlxuICAgICAqICAgICByZXR1cm4gbXlSZXNvbHZlVmFsdWUgIT09ICdBQk9SVCc7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRlYCBpcyBwcm92aWRlZCwgdGhlIGluamVjdG9yIHRoYXQgaXMgcmV0dXJuZWQgd2lsbCBiZSBsaW1pdGVkIHRvIHJlc29sdmUgdmFsdWVzIHRoYXQgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIGJvdGggYSBwYXJlbnQgc3RhdGUgYGZvb2AgYW5kIGEgY2hpbGQgc3RhdGUgYGZvby5iYXJgIGhhdmUgYm90aCBkZWZpbmVkIGEgcmVzb2x2ZSBzdWNoIGFzIGBkYXRhYC5cbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25FbnRlcih7IHRvOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gcmV0dXJucyByZXN1bHQgb2YgYGZvb2Agc3RhdGUncyBgZGF0YWAgcmVzb2x2ZVxuICAgICAqICAgLy8gZXZlbiB0aG91Z2ggYGZvby5iYXJgIGFsc28gaGFzIGEgYGRhdGFgIHJlc29sdmVcbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnZGF0YScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgcmVzb2x2ZSBkYXRhIGZyb20gdGhlIGV4aXRpbmcgc3RhdGVzLCBwYXNzIGAnZnJvbSdgIGFzIGBwYXRoTmFtZWAuXG4gICAgICogVGhlIHJlc29sdmUgZGF0YSBmcm9tIHRoZSBgZnJvbWAgcGF0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkV4aXQoeyBleGl0aW5nOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gR2V0cyB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBgZGF0YWAgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZS5cbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IobnVsbCwgJ2Zvby5iYXInKS5nZXQoJ2RhdGEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogQHBhcmFtIHBhdGhOYW1lIERlZmF1bHQ6IGAndG8nYDogQ2hvb3NlcyB0aGUgcGF0aCBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSBpbmplY3Rvci4gVXNlIHRoaXMgdG8gYWNjZXNzIHJlc29sdmVzIGZvciBgZXhpdGluZ2Agc3RhdGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoTmFtZSkge1xuICAgICAgICBpZiAocGF0aE5hbWUgPT09IHZvaWQgMCkgeyBwYXRoTmFtZSA9IFwidG9cIjsgfVxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhOYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgICAgcGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlIHx8IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGU7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQocGF0aCkuaW5qZWN0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGF2YWlsYWJsZSByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1tpbmplY3Rvcl1dIHRvIGluc3BlY3QgdGhlIHJlc29sdmUgdmFsdWVzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGFsbCB0aGUgdG9rZW5zIGRlZmluZWQgb24gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9ja3MsIGZvciB0aGUgc3RhdGVzXG4gICAgICogaW4gdGhlIFRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzLnRvXV0gcGF0aC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgbG9ncyBhbGwgcmVzb2x2ZSB2YWx1ZXNcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4gY29uc29sZS5sb2codG9rZW4gKyBcIiA9IFwiICsgdHJhbnMuaW5qZWN0b3IoKS5nZXQodG9rZW4pKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgcHJvbWlzZXMgZm9yIGVhY2ggcmVzb2x2ZSB2YWx1ZS5cbiAgICAgKiBUaGlzIHRyaWdnZXJzIGZldGNoZXMgb2YgcmVzb2x2ZXMgKGlmIGFueSBoYXZlIG5vdCB5ZXQgYmVlbiBmZXRjaGVkKS5cbiAgICAgKiBXaGVuIGFsbCBwcm9taXNlcyBoYXZlIGFsbCBzZXR0bGVkLCBpdCBsb2dzIHRoZSByZXNvbHZlIHZhbHVlcy5cbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogbGV0IHByb21pc2UgPSB0b2tlbnMubWFwKHRva2VuID0+IHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmModG9rZW4pKTtcbiAgICAgKiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gY29uc29sZS5sb2coXCJSZXNvbHZlZCB2YWx1ZXM6IFwiICsgdmFsdWVzKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbmd1bGFyIDEgdXNlcnMgd2hvdWxkIHVzZSBgJHEuYWxsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgcmVzb2x2ZSBjb250ZXh0J3MgcGF0aCBuYW1lIChlLmcuLCBgdG9gIG9yIGBmcm9tYClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldFJlc29sdmVUb2tlbnMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSkuZ2V0VG9rZW5zKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSBhZGRzIGEgbmV3IFtbUmVzb2x2YWJsZV1dIChpLmUuLCBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dKSB0byB0aGlzIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdHJhbnNpdGlvbiA9PiB7XG4gICAgICogICB0cmFuc2l0aW9uLmFkZFJlc29sdmFibGUoe1xuICAgICAqICAgICB0b2tlbjogJ215UmVzb2x2ZScsXG4gICAgICogICAgIGRlcHM6IFsnTXlTZXJ2aWNlJ10sXG4gICAgICogICAgIHJlc29sdmVGbjogbXlTZXJ2aWNlID0+IG15U2VydmljZS5nZXREYXRhKClcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc29sdmFibGUgYSBbW1Jlc29sdmFibGVMaXRlcmFsXV0gb2JqZWN0IChvciBhIFtbUmVzb2x2YWJsZV1dKVxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZSAob3RoZXJ3aXNlLCB0aGUgcm9vdCBzdGF0ZSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hZGRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gXCJcIjsgfVxuICAgICAgICByZXNvbHZhYmxlID0gaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpKHJlc29sdmFibGUpID8gcmVzb2x2YWJsZSA6IG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShyZXNvbHZhYmxlKTtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSA9ICh0eXBlb2Ygc3RhdGUgPT09IFwic3RyaW5nXCIpID8gc3RhdGUgOiBzdGF0ZS5uYW1lO1xuICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gY29tbW9uXzEuZmluZCh0b3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZTsgfSk7XG4gICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRvcGF0aCk7XG4gICAgICAgIHJlc29sdmVDb250ZXh0LmFkZFJlc29sdmFibGVzKFtyZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyBhIHJlZGlyZWN0LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2l0aW9uIHRoYXQgd2FzIHJlZGlyZWN0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgdHJhbnNpdGlvbkEgPSAkc3RhdGUuZ28oJ0EnKS50cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbkEub25TdGFydCh7fSwgKCkgPT4gJHN0YXRlLnRhcmdldCgnQicpKTtcbiAgICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdCJyB9LCAodHJhbnMpID0+IHtcbiAgICAgKiAgIHRyYW5zLnRvKCkubmFtZSA9PT0gJ0InOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRyYW5zaXRpb24sIG9yIG51bGwgaWYgdGhpcyBUcmFuc2l0aW9uIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdGVkRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucmVkaXJlY3RlZEZyb20gfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gaW4gYSByZWRpcmVjdCBjaGFpblxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIG1pZ2h0IGJlbG9uZyB0byBhIGxvbmcgY2hhaW4gb2YgbXVsdGlwbGUgcmVkaXJlY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIHdhbGtzIHRoZSBbW3JlZGlyZWN0ZWRGcm9tXV0gY2hhaW4gYmFjayB0byB0aGUgb3JpZ2luYWwgKGZpcnN0KSB0cmFuc2l0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHN0YXRlc1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0EnLCByZWRpcmVjdFRvOiAnQicgfSk7XG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQicsIHJlZGlyZWN0VG86ICdDJyB9KTtcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0QnIH0pO1xuICAgICAqXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgICAqXG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnRCcgfSwgKHRyYW5zKSA9PiB7XG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMucmVkaXJlY3RlZEZyb20oKS50bygpLm5hbWUgPT09ICdDJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFRyYW5zaXRpb24gdGhhdCBzdGFydGVkIGEgcmVkaXJlY3QgY2hhaW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcmlnaW5hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZiA9IHRoaXMucmVkaXJlY3RlZEZyb20oKTtcbiAgICAgICAgcmV0dXJuIChyZiAmJiByZi5vcmlnaW5hbFRyYW5zaXRpb24oKSkgfHwgdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBUcmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5lbnRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBleGl0ZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5leGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmV4aXRpbmcsIGhvZl8xLnByb3AoJ3N0YXRlJykpLm1hcChzdGF0ZVNlbGYpLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXRlcyBiZWluZyByZXRhaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IGFyZSBhbHJlYWR5IGVudGVyZWQgZnJvbSBhIHByZXZpb3VzIFRyYW5zaXRpb24sIHRoYXQgd2lsbCBub3QgYmVcbiAgICAgKiAgICBleGl0ZWQgZHVyaW5nIHRoaXMgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJldGFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLnJldGFpbmVkLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgW1tWaWV3Q29uZmlnXV1zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIEVhY2ggc3RhdGUgY2FuIGRlZmluZSBvbmUgb3IgbW9yZSB2aWV3cyAodGVtcGxhdGUvY29udHJvbGxlciksIHdoaWNoIGFyZSBlbmNhcHN1bGF0ZWQgYXMgYFZpZXdDb25maWdgIG9iamVjdHMuXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyB0aGUgYFZpZXdDb25maWdzYCBmb3IgYSBnaXZlbiBwYXRoIGluIHRoZSBUcmFuc2l0aW9uIChlLmcuLCBcInRvXCIgb3IgXCJlbnRlcmluZ1wiKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRobmFtZSB0aGUgbmFtZSBvZiB0aGUgcGF0aCB0byBmZXRjaCB2aWV3cyBmb3I6XG4gICAgICogICAoYCd0bydgLCBgJ2Zyb20nYCwgYCdlbnRlcmluZydgLCBgJ2V4aXRpbmcnYCwgYCdyZXRhaW5lZCdgKVxuICAgICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIFZpZXdDb25maWcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudmlld3MgPSBmdW5jdGlvbiAocGF0aG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChwYXRobmFtZSA9PT0gdm9pZCAwKSB7IHBhdGhuYW1lID0gXCJlbnRlcmluZ1wiOyB9XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xuICAgICAgICBwYXRoID0gIXN0YXRlID8gcGF0aCA6IHBhdGguZmlsdGVyKGhvZl8xLnByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xuICAgICAgICByZXR1cm4gcGF0aC5tYXAoaG9mXzEucHJvcChcInZpZXdzXCIpKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgPyB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0gOiB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uU2VydmljZV1dIGhvb2sgdG9cbiAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgodHJhbnMgPSB0cmFucy5yZWRpcmVjdGVkRnJvbSgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKytyZWRpcmVjdHMgPiAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkaXJlY3RPcHRzID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiBcInJlZGlyZWN0XCIgfTtcbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIGNhdXNlZCBieSBVUkwgc3luYywgdGhlbiB1c2UgeyBsb2NhdGlvbjogJ3JlcGxhY2UnIH1cbiAgICAgICAgLy8gb24gdGhlIG5ldyB0cmFuc2l0aW9uICh1bmxlc3MgdGhlIHRhcmdldCBzdGF0ZSBleHBsaWNpdGx5IHNwZWNpZmllcyBsb2NhdGlvbjogZmFsc2UpLlxuICAgICAgICAvLyBUaGlzIGNhdXNlcyB0aGUgb3JpZ2luYWwgdXJsIHRvIGJlIHJlcGxhY2VkIHdpdGggdGhlIHVybCBmb3IgdGhlIHJlZGlyZWN0IHRhcmdldFxuICAgICAgICAvLyBzbyB0aGUgb3JpZ2luYWwgdXJsIGRpc2FwcGVhcnMgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zKCkuc291cmNlID09PSAndXJsJyAmJiB0YXJnZXRTdGF0ZS5vcHRpb25zKCkubG9jYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZWRpcmVjdE9wdHMubG9jYXRpb24gPSAncmVwbGFjZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoe30sIHRoaXMub3B0aW9ucygpLCB0YXJnZXRTdGF0ZS5vcHRpb25zKCksIHJlZGlyZWN0T3B0cyk7XG4gICAgICAgIHRhcmdldFN0YXRlID0gbmV3IHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUodGFyZ2V0U3RhdGUuaWRlbnRpZmllcigpLCB0YXJnZXRTdGF0ZS4kc3RhdGUoKSwgdGFyZ2V0U3RhdGUucGFyYW1zKCksIG5ld09wdGlvbnMpO1xuICAgICAgICB2YXIgbmV3VHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZSh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHZhciBvcmlnaW5hbEVudGVyaW5nTm9kZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcbiAgICAgICAgdmFyIHJlZGlyZWN0RW50ZXJpbmdOb2RlcyA9IG5ld1RyYW5zaXRpb24uX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xuICAgICAgICAvLyAtLS0gUmUtdXNlIHJlc29sdmUgZGF0YSBmcm9tIG9yaWdpbmFsIHRyYW5zaXRpb24gLS0tXG4gICAgICAgIC8vIFdoZW4gcmVkaXJlY3RpbmcgZnJvbSBhIHBhcmVudCBzdGF0ZSB0byBhIGNoaWxkIHN0YXRlIHdoZXJlIHRoZSBwYXJlbnQgcGFyYW1ldGVyIHZhbHVlcyBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgLy8gKGJlY2F1c2Ugb2YgdGhlIHJlZGlyZWN0KSwgdGhlIHJlc29sdmVzIGZldGNoZWQgYnkgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gYXJlIHN0aWxsIHZhbGlkIGluIHRoZVxuICAgICAgICAvLyByZWRpcmVjdGVkIHRyYW5zaXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkZWZpbmUgYSByZWRpcmVjdCBvbiBhIHBhcmVudCBzdGF0ZSB3aGljaCBkZXBlbmRzIG9uIGFuIGFzeW5jIHJlc29sdmUgdmFsdWUuXG4gICAgICAgIC8vIFlvdSBjYW4gd2FpdCBmb3IgdGhlIHJlc29sdmUsIHRoZW4gcmVkaXJlY3QgdG8gYSBjaGlsZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0LlxuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCB0cmFuc2l0aW9uIGRvZXMgbm90IGhhdmUgdG8gcmUtZmV0Y2ggdGhlIHJlc29sdmUuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgbm9kZUlzUmVsb2FkaW5nID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7IHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFN0YXRlICYmIG5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07XG4gICAgICAgIH07IH07XG4gICAgICAgIC8vIEZpbmQgYW55IFwiZW50ZXJpbmdcIiBub2RlcyBpbiB0aGUgcmVkaXJlY3QgcGF0aCB0aGF0IG1hdGNoIHRoZSBvcmlnaW5hbCBwYXRoIGFuZCBhcmVuJ3QgYmVpbmcgcmVsb2FkZWRcbiAgICAgICAgdmFyIG1hdGNoaW5nRW50ZXJpbmdOb2RlcyA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1hdGNoaW5nKHJlZGlyZWN0RW50ZXJpbmdOb2Rlcywgb3JpZ2luYWxFbnRlcmluZ05vZGVzLCBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zKVxuICAgICAgICAgICAgLmZpbHRlcihob2ZfMS5ub3Qobm9kZUlzUmVsb2FkaW5nKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5yZWxvYWRTdGF0ZSkpKTtcbiAgICAgICAgLy8gVXNlIHRoZSBleGlzdGluZyAocG9zc2libHkgcHJlLXJlc29sdmVkKSByZXNvbHZhYmxlcyBmb3IgdGhlIG1hdGNoaW5nIGVudGVyaW5nIG5vZGVzLlxuICAgICAgICBtYXRjaGluZ0VudGVyaW5nTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaWR4KSB7XG4gICAgICAgICAgICBub2RlLnJlc29sdmFibGVzID0gb3JpZ2luYWxFbnRlcmluZ05vZGVzW2lkeF0ucmVzb2x2YWJsZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3VHJhbnNpdGlvbjtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIElmIGEgdHJhbnNpdGlvbiBkb2Vzbid0IGV4aXQvZW50ZXIgYW55IHN0YXRlcywgcmV0dXJucyBhbnkgW1tQYXJhbV1dIHdob3NlIHZhbHVlIGNoYW5nZWQgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5fY2hhbmdlZFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRjID0gdGhpcy5fdHJlZUNoYW5nZXM7XG4gICAgICAgIC8qKiBSZXR1cm4gdW5kZWZpbmVkIGlmIGl0J3Mgbm90IGEgXCJkeW5hbWljXCIgdHJhbnNpdGlvbiwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29ucyAqL1xuICAgICAgICAvLyBJZiB1c2VyIGV4cGxpY2l0bHkgd2FudHMgYSByZWxvYWRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVsb2FkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgYW55IHN0YXRlcyBhcmUgZXhpdGluZyBvciBlbnRlcmluZ1xuICAgICAgICBpZiAodGMuZXhpdGluZy5sZW5ndGggfHwgdGMuZW50ZXJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgdG8vZnJvbSBwYXRoIGxlbmd0aHMgZGlmZmVyXG4gICAgICAgIGlmICh0Yy50by5sZW5ndGggIT09IHRjLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgdGhlIHRvL2Zyb20gcGF0aHMgYXJlIGRpZmZlcmVudFxuICAgICAgICB2YXIgcGF0aHNEaWZmZXIgPSBjb21tb25fMS5hcnJheVR1cGxlcyh0Yy50bywgdGMuZnJvbSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZVswXS5zdGF0ZSAhPT0gdHVwbGVbMV0uc3RhdGU7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLmFueVRydWVSLCBmYWxzZSk7XG4gICAgICAgIGlmIChwYXRoc0RpZmZlcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEZpbmQgYW55IHBhcmFtZXRlciB2YWx1ZXMgdGhhdCBkaWZmZXJcbiAgICAgICAgdmFyIG5vZGVTY2hlbWFzID0gdGMudG8ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KTtcbiAgICAgICAgdmFyIF9hID0gW3RjLnRvLCB0Yy5mcm9tXS5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnBhcmFtVmFsdWVzOyB9KTsgfSksIHRvVmFsdWVzID0gX2FbMF0sIGZyb21WYWx1ZXMgPSBfYVsxXTtcbiAgICAgICAgdmFyIHR1cGxlcyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKG5vZGVTY2hlbWFzLCB0b1ZhbHVlcywgZnJvbVZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0dXBsZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hWzBdLCB0b1ZhbHMgPSBfYVsxXSwgZnJvbVZhbHMgPSBfYVsyXTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmNoYW5nZWQoc2NoZW1hLCB0b1ZhbHMsIGZyb21WYWxzKTtcbiAgICAgICAgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBkeW5hbWljLlxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGJ1dCBhdCBsZWFzdCBvbmUgZHluYW1pYyBwYXJhbWV0ZXIgaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIGR5bmFtaWNcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5keW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZWRQYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuICFjaGFuZ2VzID8gZmFsc2UgOiBjaGFuZ2VzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5keW5hbWljOyB9KS5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGFuZCBubyBwYXJhbWV0ZXIgdmFsdWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgaWdub3JlZC5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5pZ25vcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9pZ25vcmVkUmVhc29uKCk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9pZ25vcmVkUmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVuZGluZyA9IHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICAgICAgdmFyIHJlbG9hZFN0YXRlID0gdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZTtcbiAgICAgICAgdmFyIHNhbWUgPSBmdW5jdGlvbiAocGF0aEEsIHBhdGhCKSB7XG4gICAgICAgICAgICBpZiAocGF0aEEubGVuZ3RoICE9PSBwYXRoQi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IG1hdGNoaW5nLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gIXJlbG9hZFN0YXRlIHx8ICFub2RlLnN0YXRlLmluY2x1ZGVzW3JlbG9hZFN0YXRlLm5hbWVdOyB9KS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZXdUQyA9IHRoaXMudHJlZUNoYW5nZXMoKTtcbiAgICAgICAgdmFyIHBlbmRUQyA9IHBlbmRpbmcgJiYgcGVuZGluZy50cmVlQ2hhbmdlcygpO1xuICAgICAgICBpZiAocGVuZFRDICYmIHNhbWUocGVuZFRDLnRvLCBuZXdUQy50bykgJiYgc2FtZShwZW5kVEMuZXhpdGluZywgbmV3VEMuZXhpdGluZykpXG4gICAgICAgICAgICByZXR1cm4gXCJTYW1lQXNQZW5kaW5nXCI7XG4gICAgICAgIGlmIChuZXdUQy5leGl0aW5nLmxlbmd0aCA9PT0gMCAmJiBuZXdUQy5lbnRlcmluZy5sZW5ndGggPT09IDAgJiYgc2FtZShuZXdUQy5mcm9tLCBuZXdUQy50bykpXG4gICAgICAgICAgICByZXR1cm4gXCJTYW1lQXNDdXJyZW50XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgY2FsbGVkIGZyb20gdGhlIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcnVuQWxsSG9va3MgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzO1xuICAgICAgICAvLyBHZXRzIHRyYW5zaXRpb24gaG9va3MgYXJyYXkgZm9yIHRoZSBnaXZlbiBwaGFzZVxuICAgICAgICB2YXIgZ2V0SG9va3NGb3IgPSBmdW5jdGlvbiAocGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5faG9va0J1aWxkZXIuYnVpbGRIb29rc0ZvclBoYXNlKHBoYXNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2hlbiB0aGUgY2hhaW4gaXMgY29tcGxldGUsIHRoZW4gcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gICAgICAgIHZhciB0cmFuc2l0aW9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VTdWNjZXNzKF90aGlzLiR0bygpLCBfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5zdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9kZWZlcnJlZC5yZXNvbHZlKF90aGlzLnRvKCkpO1xuICAgICAgICAgICAgcnVuQWxsSG9va3MoZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5TVUNDRVNTKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlRXJyb3IocmVhc29uLCBfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5zdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICBfdGhpcy5fZXJyb3IgPSByZWFzb247XG4gICAgICAgICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkVSUk9SKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBydW5UcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2FpdCB0byBidWlsZCB0aGUgUlVOIGhvb2sgY2hhaW4gdW50aWwgdGhlIEJFRk9SRSBob29rcyBhcmUgZG9uZVxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgYSBCRUZPUkUgaG9vayB0byBkeW5hbWljYWxseSBhZGQgYWRkaXRpb25hbCBSVU4gaG9va3MgdmlhIHRoZSBUcmFuc2l0aW9uIG9iamVjdC5cbiAgICAgICAgICAgIHZhciBhbGxSdW5Ib29rcyA9IGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuUlVOKTtcbiAgICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbih1bmRlZmluZWQpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3MoYWxsUnVuSG9va3MsIGRvbmUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbHMgPSBfdGhpcy5yb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgICAgIGdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPSBfdGhpcy4kaWQ7XG4gICAgICAgICAgICBnbG9iYWxzLnRyYW5zaXRpb24gPSBfdGhpcztcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbkhpc3RvcnkuZW5xdWV1ZShfdGhpcyk7XG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVHJhbnNpdGlvblN0YXJ0KF90aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhbGxCZWZvcmVIb29rcyA9IGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuQkVGT1JFKTtcbiAgICAgICAgdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxCZWZvcmVIb29rcywgc3RhcnRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4ocnVuVHJhbnNpdGlvbilcbiAgICAgICAgICAgIC50aGVuKHRyYW5zaXRpb25TdWNjZXNzLCB0cmFuc2l0aW9uRXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBUcmFuc2l0aW9uIGlzIHZhbGlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIHZhbGlkXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpIHx8IHRoaXMuc3VjY2VzcyAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWJvcnRzIHRoaXMgdHJhbnNpdGlvblxuICAgICAqXG4gICAgICogSW1wZXJhdGl2ZSBBUEkgdG8gYWJvcnQgYSBUcmFuc2l0aW9uLlxuICAgICAqIFRoaXMgb25seSBhcHBsaWVzIHRvIFRyYW5zaXRpb25zIHRoYXQgYXJlIG5vdCB5ZXQgY29tcGxldGUuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdCBzZXQgZmxhZyBpZiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGNvbXBsZXRlXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNVbmRlZmluZWQodGhpcy5zdWNjZXNzKSkge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBUcmFuc2l0aW9uIGVycm9yIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGFuZCBjb3VsZCBub3QgYmUgcnVuKSwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQuXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gd2FzIHZhbGlkIGFuZCByYW4sIGJ1dCB3YXMgbm90IHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGV4cGxhaW5pbmcgd2h5IHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQsIG9yIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gZmFpbGVkLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLiR0bygpO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZi5hYnN0cmFjdClcbiAgICAgICAgICAgIHJldHVybiBcIkNhbm5vdCB0cmFuc2l0aW9uIHRvIGFic3RyYWN0IHN0YXRlICdcIiArIHN0YXRlLm5hbWUgKyBcIidcIjtcbiAgICAgICAgaWYgKCFwYXJhbV8xLlBhcmFtLnZhbGlkYXRlcyhzdGF0ZS5wYXJhbWV0ZXJzKCksIHRoaXMucGFyYW1zKCkpKVxuICAgICAgICAgICAgcmV0dXJuIFwiUGFyYW0gdmFsdWVzIG5vdCB2YWxpZCBmb3Igc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xuICAgICAgICBpZiAodGhpcy5zdWNjZXNzID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJvbVN0YXRlT3JOYW1lID0gdGhpcy5mcm9tKCk7XG4gICAgICAgIHZhciB0b1N0YXRlT3JOYW1lID0gdGhpcy50bygpO1xuICAgICAgICB2YXIgYXZvaWRFbXB0eUhhc2ggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmFtc1tcIiNcIl0gIT09IG51bGwgJiYgcGFyYW1zW1wiI1wiXSAhPT0gdW5kZWZpbmVkKSA/IHBhcmFtcyA6IGNvbW1vbl8xLm9taXQocGFyYW1zLCBbXCIjXCJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gKFgpIG1lYW5zIHRoZSB0byBzdGF0ZSBpcyBpbnZhbGlkLlxuICAgICAgICB2YXIgaWQgPSB0aGlzLiRpZCwgZnJvbSA9IHByZWRpY2F0ZXNfMS5pc09iamVjdChmcm9tU3RhdGVPck5hbWUpID8gZnJvbVN0YXRlT3JOYW1lLm5hbWUgOiBmcm9tU3RhdGVPck5hbWUsIGZyb21QYXJhbXMgPSBjb21tb25fMS50b0pzb24oYXZvaWRFbXB0eUhhc2godGhpcy5fdHJlZUNoYW5nZXMuZnJvbS5tYXAoaG9mXzEucHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKGNvbW1vbl8xLm1lcmdlUiwge30pKSksIHRvVmFsaWQgPSB0aGlzLnZhbGlkKCkgPyBcIlwiIDogXCIoWCkgXCIsIHRvID0gcHJlZGljYXRlc18xLmlzT2JqZWN0KHRvU3RhdGVPck5hbWUpID8gdG9TdGF0ZU9yTmFtZS5uYW1lIDogdG9TdGF0ZU9yTmFtZSwgdG9QYXJhbXMgPSBjb21tb25fMS50b0pzb24oYXZvaWRFbXB0eUhhc2godGhpcy5wYXJhbXMoKSkpO1xuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uI1wiICsgaWQgKyBcIiggJ1wiICsgZnJvbSArIFwiJ1wiICsgZnJvbVBhcmFtcyArIFwiIC0+IFwiICsgdG9WYWxpZCArIFwiJ1wiICsgdG8gKyBcIidcIiArIHRvUGFyYW1zICsgXCIgKVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb247XG59KCkpO1xuLyoqIEBoaWRkZW4gKi9cblRyYW5zaXRpb24uZGlUb2tlbiA9IFRyYW5zaXRpb247XG5leHBvcnRzLlRyYW5zaXRpb24gPSBUcmFuc2l0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/transition.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionEventType.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionEventType.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ \"./node_modules/@uirouter/core/lib/transition/transitionHook.js\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkV2ZW50VHlwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uRXZlbnRUeXBlLmpzPzk3MTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgYSB0eXBlIG9mIGhvb2ssIHN1Y2ggYXMgYG9uQmVmb3JlYCBvciBgb25FbnRlcmAuXG4gKiBQbHVnaW5zIGNhbiBkZWZpbmUgY3VzdG9tIGhvb2sgdHlwZXMsIHN1Y2ggYXMgc3RpY2t5IHN0YXRlcyBkb2VzIGZvciBgb25JbmFjdGl2ZWAuXG4gKlxuICogQGludGVyYWxhcGlcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudFR5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25FdmVudFR5cGUobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cykge1xuICAgICAgICBpZiAocmV2ZXJzZVNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlU29ydCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChnZXRSZXN1bHRIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0UmVzdWx0SGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVDsgfVxuICAgICAgICBpZiAoZ2V0RXJyb3JIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0RXJyb3JIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1I7IH1cbiAgICAgICAgaWYgKHN5bmNocm9ub3VzID09PSB2b2lkIDApIHsgc3luY2hyb25vdXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmhvb2tQaGFzZSA9IGhvb2tQaGFzZTtcbiAgICAgICAgdGhpcy5ob29rT3JkZXIgPSBob29rT3JkZXI7XG4gICAgICAgIHRoaXMuY3JpdGVyaWFNYXRjaFBhdGggPSBjcml0ZXJpYU1hdGNoUGF0aDtcbiAgICAgICAgdGhpcy5yZXZlcnNlU29ydCA9IHJldmVyc2VTb3J0O1xuICAgICAgICB0aGlzLmdldFJlc3VsdEhhbmRsZXIgPSBnZXRSZXN1bHRIYW5kbGVyO1xuICAgICAgICB0aGlzLmdldEVycm9ySGFuZGxlciA9IGdldEVycm9ySGFuZGxlcjtcbiAgICAgICAgdGhpcy5zeW5jaHJvbm91cyA9IHN5bmNocm9ub3VzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNpdGlvbkV2ZW50VHlwZTtcbn0oKSk7XG5leHBvcnRzLlRyYW5zaXRpb25FdmVudFR5cGUgPSBUcmFuc2l0aW9uRXZlbnRUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbkV2ZW50VHlwZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/transitionEventType.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionHook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionHook.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar rejectFactory_1 = __webpack_require__(/*! ./rejectFactory */ \"./node_modules/@uirouter/core/lib/transition/rejectFactory.js\");\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return rejectFactory_1.Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && predicates_1.isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(rejectFactory_1.Rejection.normalize(err));\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val) { return _this.handleHookResult(val); });\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return rejectFactory_1.Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n        }\n        if (this.transition._aborted) {\n            return rejectFactory_1.Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook's return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (predicates_1.isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    return TransitionHook;\n}());\n/**\n * These GetResultHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n    return hook.handleHookResult(result);\n}; };\n/**\n * If the result is a promise rejection, log it.\n * Otherwise, ignore the result.\n */\nTransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n    predicates_1.isPromise(result) && result.catch(function (err) {\n        return hook.logError(rejectFactory_1.Rejection.normalize(err));\n    });\n    return undefined;\n}; };\n/**\n * These GetErrorHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.LOG_ERROR = function (hook) { return function (error) {\n    return hook.logError(error);\n}; };\nTransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n    return common_1.silentRejection(error);\n}; };\nTransitionHook.THROW_ERROR = function (hook) { return function (error) {\n    throw error;\n}; };\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanM/NmVhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3JlamVjdEZhY3RvcnlcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjdXJyZW50OiBjb21tb25fMS5ub29wLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgdHJhY2VEYXRhOiB7fSxcbiAgICBiaW5kOiBudWxsLFxufTtcbi8qKiBAaGlkZGVuICovXG52YXIgVHJhbnNpdGlvbkhvb2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlQ29udGV4dCwgcmVnaXN0ZXJlZEhvb2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZUNvbnRleHQgPSBzdGF0ZUNvbnRleHQ7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEhvb2sgPSByZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc1N1cGVyc2VkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHlwZS5ob29rUGhhc2UgPT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuUlVOICYmICFfdGhpcy5vcHRpb25zLnRyYW5zaXRpb24uaXNBY3RpdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSByZWdpc3RlcmVkSG9vay5ldmVudFR5cGU7XG4gICAgfVxuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcigpKGVycik7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uSG9vay5wcm90b3R5cGUuaW52b2tlSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhvb2sgPSB0aGlzLnJlZ2lzdGVyZWRIb29rO1xuICAgICAgICBpZiAoaG9vay5fZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgICAgICBpZiAobm90Q3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBub3RDdXJyZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tJbnZvY2F0aW9uKHRoaXMsIHRoaXMudHJhbnNpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmNhbGxiYWNrLmNhbGwob3B0aW9ucy5iaW5kLCBfdGhpcy50cmFuc2l0aW9uLCBfdGhpcy5zdGF0ZUNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9ybWFsaXplRXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikudG9Qcm9taXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRFcnJvckhhbmRsZXIoX3RoaXMpKGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gaG9vay5ldmVudFR5cGUuZ2V0UmVzdWx0SGFuZGxlcihfdGhpcykocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbnZva2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuc3luY2hyb25vdXMgJiYgcHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChub3JtYWxpemVFcnIpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIGNhbGxiYWNrIHRocm93cyAoc3luY2hyb25vdXNseSlcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcihyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgVHJhbnNpdGlvbiBIb29rLlxuICAgICAqXG4gICAgICogQSBob29rIGNhbiByZXR1cm4gZmFsc2UgKGNhbmNlbCksIGEgVGFyZ2V0U3RhdGUgKHJlZGlyZWN0KSxcbiAgICAgKiBvciBhIHByb21pc2UgKHdoaWNoIG1heSBsYXRlciByZXNvbHZlIHRvIGZhbHNlIG9yIGEgcmVkaXJlY3QpXG4gICAgICpcbiAgICAgKiBUaGlzIGFsc28gaGFuZGxlcyBcInRyYW5zaXRpb24gc3VwZXJzZWRlZFwiIC0tIHdoZW4gYSBuZXcgdHJhbnNpdGlvblxuICAgICAqIHdhcyBzdGFydGVkIHdoaWxlIHRoZSBob29rIHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmhhbmRsZUhvb2tSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgICAgIGlmIChub3RDdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XG4gICAgICAgIC8vIEhvb2sgcmV0dXJuZWQgYSBwcm9taXNlXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJlcHJvY2VzcyB3aXRoIHRoZSByZXN1bHRpbmcgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiBfdGhpcy5oYW5kbGVIb29rUmVzdWx0KHZhbCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VIb29rUmVzdWx0KHJlc3VsdCwgdGhpcy50cmFuc2l0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAvLyBIb29rIHJldHVybmVkIGZhbHNlXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIFRyYW5zaXRpb25cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJIb29rIGFib3J0ZWQgdHJhbnNpdGlvblwiKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUYXJnZXRTdGF0ZSA9IGhvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpO1xuICAgICAgICAvLyBob29rIHJldHVybmVkIGEgVGFyZ2V0U3RhdGVcbiAgICAgICAgaWYgKGlzVGFyZ2V0U3RhdGUocmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gSGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCAoYSBuZXcgVHJhbnNpdGlvbikgdG8gdGhlIFRhcmdldFN0YXRlLlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ucmVkaXJlY3RlZChyZXN1bHQpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBSZWplY3Rpb24gcHJvbWlzZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBubyBsb25nZXIgY3VycmVudCBkdWVcbiAgICAgKiB0byBhIHN0b3BwZWQgcm91dGVyIChkaXNwb3NlZCksIG9yIGEgbmV3IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmdldE5vdEN1cnJlbnRSZWplY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyO1xuICAgICAgICAvLyBUaGUgcm91dGVyIGlzIHN0b3BwZWRcbiAgICAgICAgaWYgKHJvdXRlci5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJVSVJvdXRlciBpbnN0YW5jZSAjXCIgKyByb3V0ZXIuJGlkICsgXCIgaGFzIGJlZW4gc3RvcHBlZCAoZGlzcG9zZWQpXCIpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb24uX2Fib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQuXG4gICAgICAgIC8vIEFub3RoZXIgdHJhbnNpdGlvbiBzdGFydGVkIHdoaWxlIHRoaXMgaG9vayB3YXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNTdXBlcnNlZGVkKCkpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCh0aGlzLm9wdGlvbnMuY3VycmVudCgpKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgcmVnaXN0ZXJlZEhvb2sgPSBfYS5yZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdmFyIGV2ZW50ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuaG9va1R5cGVcIikob3B0aW9ucykgfHwgXCJpbnRlcm5hbFwiLCBjb250ZXh0ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lXCIpKG9wdGlvbnMpIHx8IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHRcIikob3B0aW9ucykgfHwgXCJ1bmtub3duXCIsIG5hbWUgPSBzdHJpbmdzXzEuZm5Ub1N0cmluZyhyZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoYWlucyB0b2dldGhlciBhbiBhcnJheSBvZiBUcmFuc2l0aW9uSG9va3MuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgW1tUcmFuc2l0aW9uSG9va11dIG9iamVjdHMsIGNoYWlucyB0aGVtIHRvZ2V0aGVyLlxuICAgICAqIEVhY2ggaG9vayBpcyBpbnZva2VkIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGhvb2tzOiBUcmFuc2l0aW9uSG9va1tdID0gZ2V0SG9va3MoKTtcbiAgICAgKiBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gVHJhbnNpdGlvbkhvb2suY2hhaW4oaG9va3MpO1xuICAgICAqXG4gICAgICogcHJvbWlzZS50aGVuKGhhbmRsZVN1Y2Nlc3MsIGhhbmRsZUVycm9yKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBob29rcyB0aGUgbGlzdCBvZiBob29rcyB0byBjaGFpbiB0b2dldGhlclxuICAgICAqIEBwYXJhbSB3YWl0Rm9yIGlmIHByb3ZpZGVkLCB0aGUgY2hhaW4gaXMgYC50aGVuKClgJ2VkIG9mZiB0aGlzIHByb21pc2VcbiAgICAgKiBAcmV0dXJucyBhIGBQcm9taXNlYCBmb3Igc2VxdWVudGlhbGx5IGludm9raW5nIHRoZSBob29rcyAoaW4gb3JkZXIpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suY2hhaW4gPSBmdW5jdGlvbiAoaG9va3MsIHdhaXRGb3IpIHtcbiAgICAgICAgLy8gQ2hhaW4gdGhlIG5leHQgaG9vayBvZmYgdGhlIHByZXZpb3VzXG4gICAgICAgIHZhciBjcmVhdGVIb29rQ2hhaW5SID0gZnVuY3Rpb24gKHByZXYsIG5leHRIb29rKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5leHRIb29rLmludm9rZUhvb2soKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBob29rcy5yZWR1Y2UoY3JlYXRlSG9va0NoYWluUiwgd2FpdEZvciB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhbGwgdGhlIHByb3ZpZGVkIFRyYW5zaXRpb25Ib29rcywgaW4gb3JkZXIuXG4gICAgICogRWFjaCBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQuXG4gICAgICogSWYgYW55IGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gdGhlIHJlc3Qgb2YgdGhlIGhvb2tzIGFyZSBjaGFpbmVkIG9mZiB0aGF0IHByb21pc2UsIGFuZCB0aGUgcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBubyBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGVuIGFsbCBob29rcyBhcmUgcHJvY2Vzc2VkIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgVHJhbnNpdGlvbkhvb2tzIHRvIGludm9rZVxuICAgICAqIEBwYXJhbSBkb25lQ2FsbGJhY2sgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgYWZ0ZXIgYWxsIHRoZSBob29rcyBoYXZlIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIHJlc3VsdCwgb3IgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyA9IGZ1bmN0aW9uIChob29rcywgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGhvb2tzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHZhciBob29rUmVzdWx0ID0gaG9va3NbaWR4XS5pbnZva2VIb29rKCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzUHJvbWlzZShob29rUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdIb29rcyA9IGhvb2tzLnNsaWNlKGlkeCArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uSG9vay5jaGFpbihyZW1haW5pbmdIb29rcywgaG9va1Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZG9uZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gYWxsIFRyYW5zaXRpb25Ib29rcywgaWdub3JpbmcgdGhlaXIgcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICAgIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhvb2suaW52b2tlSG9vaygpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSG9vaztcbn0oKSk7XG4vKipcbiAqIFRoZXNlIEdldFJlc3VsdEhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAqIEVhY2ggSG9va1R5cGUgY2hvb3NlcyBhIEdldFJlc3VsdEhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICovXG5UcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gaG9vay5oYW5kbGVIb29rUmVzdWx0KHJlc3VsdCk7XG59OyB9O1xuLyoqXG4gKiBJZiB0aGUgcmVzdWx0IGlzIGEgcHJvbWlzZSByZWplY3Rpb24sIGxvZyBpdC5cbiAqIE90aGVyd2lzZSwgaWdub3JlIHRoZSByZXN1bHQuXG4gKi9cblRyYW5zaXRpb25Ib29rLkxPR19SRUpFQ1RFRF9SRVNVTFQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHByZWRpY2F0ZXNfMS5pc1Byb21pc2UocmVzdWx0KSAmJiByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gaG9vay5sb2dFcnJvcihyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTsgfTtcbi8qKlxuICogVGhlc2UgR2V0RXJyb3JIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRFcnJvckhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICovXG5UcmFuc2l0aW9uSG9vay5MT0dfRVJST1IgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGhvb2subG9nRXJyb3IoZXJyb3IpO1xufTsgfTtcblRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKGVycm9yKTtcbn07IH07XG5UcmFuc2l0aW9uSG9vay5USFJPV19FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbn07IH07XG5leHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uSG9vay5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/transitionHook.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionService.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionService.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(/*! ./interface */ \"./node_modules/@uirouter/core/lib/transition/interface.js\");\nvar transition_1 = __webpack_require__(/*! ./transition */ \"./node_modules/@uirouter/core/lib/transition/transition.js\");\nvar hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ \"./node_modules/@uirouter/core/lib/transition/hookRegistry.js\");\nvar coreResolvables_1 = __webpack_require__(/*! ../hooks/coreResolvables */ \"./node_modules/@uirouter/core/lib/hooks/coreResolvables.js\");\nvar redirectTo_1 = __webpack_require__(/*! ../hooks/redirectTo */ \"./node_modules/@uirouter/core/lib/hooks/redirectTo.js\");\nvar onEnterExitRetain_1 = __webpack_require__(/*! ../hooks/onEnterExitRetain */ \"./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js\");\nvar resolve_1 = __webpack_require__(/*! ../hooks/resolve */ \"./node_modules/@uirouter/core/lib/hooks/resolve.js\");\nvar views_1 = __webpack_require__(/*! ../hooks/views */ \"./node_modules/@uirouter/core/lib/hooks/views.js\");\nvar updateGlobals_1 = __webpack_require__(/*! ../hooks/updateGlobals */ \"./node_modules/@uirouter/core/lib/hooks/updateGlobals.js\");\nvar url_1 = __webpack_require__(/*! ../hooks/url */ \"./node_modules/@uirouter/core/lib/hooks/url.js\");\nvar lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ \"./node_modules/@uirouter/core/lib/hooks/lazyLoad.js\");\nvar transitionEventType_1 = __webpack_require__(/*! ./transitionEventType */ \"./node_modules/@uirouter/core/lib/transition/transitionEventType.js\");\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ \"./node_modules/@uirouter/core/lib/transition/transitionHook.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar ignoredTransition_1 = __webpack_require__(/*! ../hooks/ignoredTransition */ \"./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js\");\nvar invalidTransition_1 = __webpack_require__(/*! ../hooks/invalidTransition */ \"./node_modules/@uirouter/core/lib/hooks/invalidTransition.js\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to);\n        this._defineEvent(\"onStart\", Phase.RUN, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent(\"onRetain\", Phase.RUN, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.RUN, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.RUN, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);\n        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);\n        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanM/Mzg0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpO1xudmFyIGhvb2tSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vaG9va1JlZ2lzdHJ5XCIpO1xudmFyIGNvcmVSZXNvbHZhYmxlc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL2NvcmVSZXNvbHZhYmxlc1wiKTtcbnZhciByZWRpcmVjdFRvXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVkaXJlY3RUb1wiKTtcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluXCIpO1xudmFyIHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9yZXNvbHZlXCIpO1xudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvdmlld3NcIik7XG52YXIgdXBkYXRlR2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VwZGF0ZUdsb2JhbHNcIik7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvdXJsXCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgdHJhbnNpdGlvbkV2ZW50VHlwZV8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBpZ25vcmVkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uXCIpO1xudmFyIGludmFsaWRUcmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvaW52YWxpZFRyYW5zaXRpb25cIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXG4gKlxuICogSW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIGFwcGx5aW5nIGN1c3RvbSBkZWZhdWx0czpcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG4gKiBsZXQgb3B0aW9ucyA9IGRlZmF1bHRzKHRoZWlyT3B0cywgY3VzdG9tRGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xuICAgIGxvY2F0aW9uOiB0cnVlLFxuICAgIHJlbGF0aXZlOiBudWxsLFxuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIG5vdGlmeTogdHJ1ZSxcbiAgICByZWxvYWQ6IGZhbHNlLFxuICAgIGN1c3RvbToge30sXG4gICAgY3VycmVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBzb3VyY2U6IFwidW5rbm93blwiXG59O1xuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gVHJhbnNpdGlvbnMuXG4gKlxuICogLSBNb3N0IGltcG9ydGFudGx5LCBpdCBhbGxvd3MgZ2xvYmFsIFRyYW5zaXRpb24gSG9va3MgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqIC0gSXQgYWxsb3dzIHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gZXJyb3IgaGFuZGxlciB0byBiZSBzZXQuXG4gKiAtIEl0IGFsc28gaGFzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdHMsICh1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0pLlxuICpcbiAqIEF0IGJvb3RzdHJhcCwgW1tVSVJvdXRlcl1dIGNyZWF0ZXMgYSBzaW5nbGUgaW5zdGFuY2UgKHNpbmdsZXRvbikgb2YgdGhpcyBjbGFzcy5cbiAqL1xudmFyIFRyYW5zaXRpb25TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25TZXJ2aWNlKF9yb3V0ZXIpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNvdW50ID0gMDtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlIHRyYW5zaXRpb24gaG9vayB0eXBlcywgc3VjaCBhcyBgb25FbnRlcmAsIGBvblN0YXJ0YCwgZXRjICovXG4gICAgICAgIHRoaXMuX2V2ZW50VHlwZXMgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rcyAqL1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlICBwYXRocyBvbiBhIGNyaXRlcmlhIG9iamVjdCAqL1xuICAgICAgICB0aGlzLl9jcml0ZXJpYVBhdGhzID0ge307XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XG4gICAgICAgIHRoaXMuJHZpZXcgPSBfcm91dGVyLnZpZXdTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVySG9va0ZucyA9IHt9O1xuICAgICAgICB0aGlzLl9wbHVnaW5hcGkgPSBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwodGhpcyksIHt9LCBob2ZfMS52YWwodGhpcyksIFtcbiAgICAgICAgICAgICdfZGVmaW5lUGF0aFR5cGUnLFxuICAgICAgICAgICAgJ19kZWZpbmVFdmVudCcsXG4gICAgICAgICAgICAnX2dldFBhdGhUeXBlcycsXG4gICAgICAgICAgICAnX2dldEV2ZW50cycsXG4gICAgICAgICAgICAnZ2V0SG9va3MnLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lQ29yZVBhdGhzKCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUNvcmVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb3JlVHJhbnNpdGlvbkhvb2tzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAgICpcbiAgICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGR1cmluZyB0cmFuc2l0aW9uIGNvbnN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbG93IGxldmVsIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBwbHVnaW5zLlxuICAgICAqIFRoaXMgY2FuIGJlIGEgdXNlZnVsIHRpbWUgZm9yIHBsdWdpbnMgdG8gYWRkIHJlc29sdmVzIG9yIG11dGF0ZSB0aGUgdHJhbnNpdGlvbiBhcyBuZWVkZWQuXG4gICAgICogVGhlIFN0aWNreSBTdGF0ZXMgcGx1Z2luIHVzZXMgdGhpcyBob29rIHRvIG1vZGlmeSB0aGUgdHJlZWNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAgICpcbiAgICAgKiBgb25DcmVhdGVgIGhvb2tzIGFyZSBpbnZva2VkICp3aGlsZSBhIHRyYW5zaXRpb24gaXMgYmVpbmcgY29uc3RydWN0ZWQqLlxuICAgICAqXG4gICAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgICAqXG4gICAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICogQHBhcmFtIGNyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIHJlZ2lzdHJhdGlvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25DcmVhdGUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25CZWZvcmUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25SZXRhaW4gPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgY29tbW9uXzEudmFsdWVzKHRoaXMuX3JlZ2lzdGVyZWRIb29rcykuZm9yRWFjaChmdW5jdGlvbiAoaG9va3NBcnJheSkgeyByZXR1cm4gaG9va3NBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICBob29rLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbShob29rc0FycmF5LCBob29rKTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW1RyYW5zaXRpb25dXSBvYmplY3RcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgVHJhbnNpdGlvbiBvYmplY3RzLlxuICAgICAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSBhbmQgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgY2FsbGVkIGJ5IGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggdGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgKHRoZSBmcm9tIHN0YXRlKVxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgdGFyZ2V0IHN0YXRlIChkZXN0aW5hdGlvbilcbiAgICAgKiBAcmV0dXJucyBhIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgdGhpcy5fcm91dGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVDb3JlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUGhhc2UgPSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlO1xuICAgICAgICB2YXIgVEggPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rO1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9jcml0ZXJpYVBhdGhzO1xuICAgICAgICB2YXIgTk9STUFMX1NPUlQgPSBmYWxzZSwgUkVWRVJTRV9TT1JUID0gdHJ1ZTtcbiAgICAgICAgdmFyIEFTWU5DSFJPTk9VUyA9IGZhbHNlLCBTWU5DSFJPTk9VUyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25DcmVhdGVcIiwgUGhhc2UuQ1JFQVRFLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILlRIUk9XX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25CZWZvcmVcIiwgUGhhc2UuQkVGT1JFLCAwLCBwYXRocy50byk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25TdGFydFwiLCBQaGFzZS5SVU4sIDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkV4aXRcIiwgUGhhc2UuUlVOLCAxMDAsIHBhdGhzLmV4aXRpbmcsIFJFVkVSU0VfU09SVCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25SZXRhaW5cIiwgUGhhc2UuUlVOLCAyMDAsIHBhdGhzLnJldGFpbmVkKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkVudGVyXCIsIFBoYXNlLlJVTiwgMzAwLCBwYXRocy5lbnRlcmluZyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25GaW5pc2hcIiwgUGhhc2UuUlVOLCA0MDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvblN1Y2Nlc3NcIiwgUGhhc2UuU1VDQ0VTUywgMCwgcGF0aHMudG8sIE5PUk1BTF9TT1JULCBUSC5MT0dfUkVKRUNURURfUkVTVUxULCBUSC5MT0dfRVJST1IsIFNZTkNIUk9OT1VTKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkVycm9yXCIsIFBoYXNlLkVSUk9SLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUNvcmVQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFNUQVRFID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSwgVFJBTlNJVElPTiA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTjtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJ0b1wiLCBUUkFOU0lUSU9OKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJmcm9tXCIsIFRSQU5TSVRJT04pO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcImV4aXRpbmdcIiwgU1RBVEUpO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcInJldGFpbmVkXCIsIFNUQVRFKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJlbnRlcmluZ1wiLCBTVEFURSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cykge1xuICAgICAgICBpZiAocmV2ZXJzZVNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlU29ydCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChnZXRSZXN1bHRIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0UmVzdWx0SGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVDsgfVxuICAgICAgICBpZiAoZ2V0RXJyb3JIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0RXJyb3JIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1I7IH1cbiAgICAgICAgaWYgKHN5bmNocm9ub3VzID09PSB2b2lkIDApIHsgc3luY2hyb25vdXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gbmV3IHRyYW5zaXRpb25FdmVudFR5cGVfMS5UcmFuc2l0aW9uRXZlbnRUeXBlKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpO1xuICAgICAgICB0aGlzLl9ldmVudFR5cGVzLnB1c2goZXZlbnRUeXBlKTtcbiAgICAgICAgaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KHRoaXMsIHRoaXMsIGV2ZW50VHlwZSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldEV2ZW50cyA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkhvb2tUeXBlcyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQocGhhc2UpID9cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50VHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSA9PT0gcGhhc2U7IH0pIDpcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50VHlwZXMuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25Ib29rVHlwZXMuc29ydChmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgICAgdmFyIGNtcEJ5UGhhc2UgPSBsLmhvb2tQaGFzZSAtIHIuaG9va1BoYXNlO1xuICAgICAgICAgICAgcmV0dXJuIGNtcEJ5UGhhc2UgPT09IDAgPyBsLmhvb2tPcmRlciAtIHIuaG9va09yZGVyIDogY21wQnlQaGFzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgUGF0aCB0byBiZSB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTogdGhlIGBleGl0aW5nYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFNUQVRFIHNjb3BlZCBwYXRoLlxuICAgICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCdleGl0aW5nJywgVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSlgXG4gICAgICogRWFjaCBzdGF0ZSBpbiB0aGUgZXhpdGluZyBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxuICAgICAqXG4gICAgICogQW5vdGhlciBleGFtcGxlOiB0aGUgYHRvYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFRSQU5TSVRJT04gc2NvcGVkIHBhdGguXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ3RvJywgVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OKWBcbiAgICAgKiBPbmx5IHRoZSB0YWlsIG9mIHRoZSBgdG9gIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVQYXRoVHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBob29rU2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRoc1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgc2NvcGU6IGhvb2tTY29wZSB9O1xuICAgIH07XG4gICAgLyoqICogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xuICAgICAgICBmbnMuYWRkQ29yZVJlc29sdmVzID0gY29yZVJlc29sdmFibGVzXzEucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXModGhpcyk7XG4gICAgICAgIGZucy5pZ25vcmVkID0gaWdub3JlZFRyYW5zaXRpb25fMS5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcbiAgICAgICAgZm5zLmludmFsaWQgPSBpbnZhbGlkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHJlZGlyZWN0VG8gaG9va1xuICAgICAgICBmbnMucmVkaXJlY3RUbyA9IHJlZGlyZWN0VG9fMS5yZWdpc3RlclJlZGlyZWN0VG9Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcbiAgICAgICAgZm5zLm9uRXhpdCA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkV4aXRIb29rKHRoaXMpO1xuICAgICAgICBmbnMub25SZXRhaW4gPSBvbkVudGVyRXhpdFJldGFpbl8xLnJlZ2lzdGVyT25SZXRhaW5Ib29rKHRoaXMpO1xuICAgICAgICBmbnMub25FbnRlciA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcbiAgICAgICAgLy8gV2lyZSB1cCBSZXNvbHZlIGhvb2tzXG4gICAgICAgIGZucy5lYWdlclJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoKHRoaXMpO1xuICAgICAgICBmbnMubGF6eVJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHRoZSBWaWV3IG1hbmFnZW1lbnQgaG9va3NcbiAgICAgICAgZm5zLmxvYWRWaWV3cyA9IHZpZXdzXzEucmVnaXN0ZXJMb2FkRW50ZXJpbmdWaWV3cyh0aGlzKTtcbiAgICAgICAgZm5zLmFjdGl2YXRlVmlld3MgPSB2aWV3c18xLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyh0aGlzKTtcbiAgICAgICAgLy8gVXBkYXRlcyBnbG9iYWwgc3RhdGUgYWZ0ZXIgYSB0cmFuc2l0aW9uXG4gICAgICAgIGZucy51cGRhdGVHbG9iYWxzID0gdXBkYXRlR2xvYmFsc18xLnJlZ2lzdGVyVXBkYXRlR2xvYmFsU3RhdGUodGhpcyk7XG4gICAgICAgIC8vIEFmdGVyIGdsb2JhbHMuY3VycmVudCBpcyB1cGRhdGVkIGF0IHByaW9yaXR5OiAxMDAwMFxuICAgICAgICBmbnMudXBkYXRlVXJsID0gdXJsXzEucmVnaXN0ZXJVcGRhdGVVcmwodGhpcyk7XG4gICAgICAgIC8vIExhenkgbG9hZCBzdGF0ZSB0cmVlc1xuICAgICAgICBmbnMubGF6eUxvYWQgPSBsYXp5TG9hZF8xLnJlZ2lzdGVyTGF6eUxvYWRIb29rKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNpdGlvblNlcnZpY2UgPSBUcmFuc2l0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25TZXJ2aWNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/transition/transitionService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./urlMatcher */ \"./node_modules/@uirouter/core/lib/url/urlMatcher.js\"));\n__export(__webpack_require__(/*! ./urlMatcherFactory */ \"./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js\"));\n__export(__webpack_require__(/*! ./urlRouter */ \"./node_modules/@uirouter/core/lib/url/urlRouter.js\"));\n__export(__webpack_require__(/*! ./urlRule */ \"./node_modules/@uirouter/core/lib/url/urlRule.js\"));\n__export(__webpack_require__(/*! ./urlService */ \"./node_modules/@uirouter/core/lib/url/urlService.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL2luZGV4LmpzPzE3ODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyRmFjdG9yeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxSb3V0ZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXJsUnVsZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxTZXJ2aWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlMatcher.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlMatcher.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar param_1 = __webpack_require__(/*! ../params/param */ \"./node_modules/@uirouter/core/lib/params/param.js\");\nvar strings_1 = __webpack_require__(/*! ../common/strings */ \"./node_modules/@uirouter/core/lib/common/strings.js\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/** @hidden */\nvar splitOnSlash = strings_1.splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(common_1.unnestR, [])\n            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(common_1.unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(common_1.unnestR, [])\n                    .reduce(strings_1.joinNeighborsR, [])\n                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(common_1.unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (predicates_1.isString(segment))\n                        return 2;\n                    if (segment instanceof param_1.Param)\n                        return 3;\n                });\n        };\n        var cmp, i, pairs = common_1.arrayTuples(weights(a), weights(b));\n        for (i = 0; i < pairs.length; i++) {\n            cmp = pairs[i][0] - pairs[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qcz9kMTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcXVvdGVSZWdFeHAoc3RyaW5nLCBwYXJhbSkge1xuICAgIHZhciBzdXJyb3VuZFBhdHRlcm4gPSBbJycsICcnXSwgcmVzdWx0ID0gc3RyaW5nLnJlcGxhY2UoL1tcXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0vZywgXCJcXFxcJCZcIik7XG4gICAgaWYgKCFwYXJhbSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHBhcmFtLnNxdWFzaCkge1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoJywgJyknICsgKHBhcmFtLmlzT3B0aW9uYWwgPyAnPycgOiAnJyldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoPzpcXC8oJywgJyl8XFwvKT8nXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gW1wiKFwiICsgcGFyYW0uc3F1YXNoICsgXCJ8XCIsICcpPyddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBtZW1vaXplVG8gPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBmbikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPSBvYmpbcHJvcF0gfHwgZm4oKTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIHNwbGl0T25TbGFzaCA9IHN0cmluZ3NfMS5zcGxpdE9uRGVsaW0oJy8nKTtcbi8qKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMuXG4gKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMgYW5kIGV4dHJhY3RzIG5hbWVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgcGF0aCBvciB0aGUgc2VhcmNoXG4gKiBwYXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdCBvZiBzZWFyY2ggKHF1ZXJ5KVxuICogcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSBbW1VybE1hdGNoZXIuZXhlY11dLlxuICpcbiAqIC0gKlBhdGggcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXJzIChgL3NvbWVwYXRoL3twYXJhbX1gKVxuICogb3IgY29sb24gcGxhY2Vob2xkZXJzIChgL3NvbWVQYXRoLzpwYXJhbWApLlxuICpcbiAqIC0gKkEgcGFyYW1ldGVyIFJlZ0V4cCogbWF5IGJlIGRlZmluZWQgZm9yIGEgcGFyYW0gYWZ0ZXIgYSBjb2xvblxuICogKGAvc29tZVBhdGgve3BhcmFtOlthLXpBLVowLTldK31gKSBpbiBhIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyLlxuICogVGhlIHJlZ2V4cCBtdXN0IG1hdGNoIGZvciB0aGUgdXJsIHRvIGJlIG1hdGNoZWQuXG4gKiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpbiBjdXJseSBicmFjZXMsIHRoZXkgbXVzdCBiZSBpbiBtYXRjaGVkIHBhaXJzIG9yIGVzY2FwZWQgd2l0aCBhIGJhY2tzbGFzaC5cbiAqXG4gKiBOb3RlOiBhIFJlZ0V4cCBwYXJhbWV0ZXIgd2lsbCBlbmNvZGUgaXRzIHZhbHVlIHVzaW5nIGVpdGhlciBbW1BhcmFtVHlwZXMucGF0aF1dIG9yIFtbUGFyYW1UeXBlcy5xdWVyeV1dLlxuICpcbiAqIC0gKkN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMqIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhZnRlciBhIGNvbG9uIChgL3NvbWVQYXRoL3twYXJhbTppbnR9YCkgaW4gY3VybHkgYnJhY2UgcGFyYW1ldGVycy5cbiAqICAgU2VlIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIC0gKkNhdGNoLWFsbCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBhbiBhc3RlcmlzayBwbGFjZWhvbGRlciAoYC9zb21lcGF0aC8qY2F0Y2hhbGxwYXJhbWApLlxuICogICBBIGNhdGNoLWFsbCAqIHBhcmFtZXRlciB2YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIHJlbWFpbmRlciBvZiB0aGUgVVJMLlxuICpcbiAqIC0tLVxuICpcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS5cbiAqIEEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGxcbiAqIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogKiBgJy9oZWxsby8nYCAtIE1hdGNoZXMgb25seSBpZiB0aGUgcGF0aCBpcyBleGFjdGx5ICcvaGVsbG8vJy4gVGhlcmUgaXMgbm8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yXG4gKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXG4gKiAqIGAnL3VzZXIvOmlkJ2AgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxuICogICAnL3VzZXIvYm9iL2RldGFpbHMnLiBUaGUgc2Vjb25kIHBhdGggc2VnbWVudCB3aWxsIGJlIGNhcHR1cmVkIGFzIHRoZSBwYXJhbWV0ZXIgJ2lkJy5cbiAqICogYCcvdXNlci97aWR9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxuICogKiBgJy91c2VyL3tpZDpbXi9dKn0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXG4gKiAqIGAnL3VzZXIve2lkOlswLTlhLWZBLUZdezEsOH19J2AgLSBTaW1pbGFyIHRvIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgb25seSBtYXRjaGVzIGlmIHRoZSBpZFxuICogICBwYXJhbWV0ZXIgY29uc2lzdHMgb2YgMSB0byA4IGhleCBkaWdpdHMuXG4gKiAqIGAnL2ZpbGVzL3twYXRoOi4qfSdgIC0gTWF0Y2hlcyBhbnkgVVJMIHN0YXJ0aW5nIHdpdGggJy9maWxlcy8nIGFuZCBjYXB0dXJlcyB0aGUgcmVzdCBvZiB0aGVcbiAqICAgcGF0aCBpbnRvIHRoZSBwYXJhbWV0ZXIgJ3BhdGgnLlxuICogKiBgJy9maWxlcy8qcGF0aCdgIC0gZGl0dG8uXG4gKiAqIGAnL2NhbGVuZGFyL3tzdGFydDpkYXRlfSdgIC0gTWF0Y2hlcyBcIi9jYWxlbmRhci8yMDE0LTExLTEyXCIgKGJlY2F1c2UgdGhlIHBhdHRlcm4gZGVmaW5lZFxuICogICBpbiB0aGUgYnVpbHQtaW4gIGBkYXRlYCBQYXJhbVR5cGUgbWF0Y2hlcyBgMjAxNC0xMS0xMmApIGFuZCBwcm92aWRlcyBhIERhdGUgb2JqZWN0IGluICRzdGF0ZVBhcmFtcy5zdGFydFxuICpcbiAqL1xudmFyIFVybE1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIGNvbXBpbGUgaW50byBhIG1hdGNoZXIuXG4gICAgICogQHBhcmFtIHBhcmFtVHlwZXMgVGhlIFtbUGFyYW1UeXBlc11dIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIGNvbmZpZyAgQSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIC0gYGNhc2VJbnNlbnNpdGl2ZWAgLSBgdHJ1ZWAgaWYgVVJMIG1hdGNoaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlLCBvdGhlcndpc2UgYGZhbHNlYCwgdGhlIGRlZmF1bHQgdmFsdWUgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KSBpcyBgZmFsc2VgLlxuICAgICAqIC0gYHN0cmljdGAgLSBgZmFsc2VgIGlmIG1hdGNoaW5nIGFnYWluc3QgYSBVUkwgd2l0aCBhIHRyYWlsaW5nIHNsYXNoIHNob3VsZCBiZSB0cmVhdGVkIGFzIGVxdWl2YWxlbnQgdG8gYSBVUkwgd2l0aG91dCBhIHRyYWlsaW5nIHNsYXNoLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVXJsTWF0Y2hlcihwYXR0ZXJuLCBwYXJhbVR5cGVzLCBwYXJhbUZhY3RvcnksIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7IHBhdGg6IFt0aGlzXSB9O1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9wYXJhbXMgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fc2VnbWVudHMgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb21tb25fMS5kZWZhdWx0cyh0aGlzLmNvbmZpZywge1xuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBwYXJhbU1hcDogY29tbW9uXzEuaWRlbnRpdHlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHBsYWNlaG9sZGVycyBhbmQgY3JlYXRlIGEgY29tcGlsZWQgcGF0dGVybiwgdXNpbmcgZWl0aGVyIGNsYXNzaWMgb3IgY3VybHkgc3ludGF4OlxuICAgICAgICAvLyAgICcqJyBuYW1lXG4gICAgICAgIC8vICAgJzonIG5hbWVcbiAgICAgICAgLy8gICAneycgbmFtZSAnfSdcbiAgICAgICAgLy8gICAneycgbmFtZSAnOicgcmVnZXhwICd9J1xuICAgICAgICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGlzIHNvbWV3aGF0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgbmVlZCB0byBhbGxvdyBjdXJseSBicmFjZXNcbiAgICAgICAgLy8gaW5zaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uIFRoZSBwbGFjZWhvbGRlciByZWdleHAgYnJlYWtzIGRvd24gYXMgZm9sbG93czpcbiAgICAgICAgLy8gICAgKFs6Kl0pKFtcXHdcXFtcXF1dKykgICAgICAgICAgICAgIC0gY2xhc3NpYyBwbGFjZWhvbGRlciAoJDEgLyAkMikgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlKVxuICAgICAgICAvLyAgICBcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooIC4uLiApKT9cXH0gIC0gY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIgKCQzKSB3aXRoIG9wdGlvbmFsIHJlZ2V4cC90eXBlIC4uLiAoJDQpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZVxuICAgICAgICAvLyAgICAoPzogLi4uIHwgLi4uIHwgLi4uICkrICAgICAgICAgLSB0aGUgcmVnZXhwIGNvbnNpc3RzIG9mIGFueSBudW1iZXIgb2YgYXRvbXMsIGFuIGF0b20gYmVpbmcgZWl0aGVyXG4gICAgICAgIC8vICAgIFtee31cXFxcXSsgICAgICAgICAgICAgICAgICAgICAgIC0gYW55dGhpbmcgb3RoZXIgdGhhbiBjdXJseSBicmFjZXMgb3IgYmFja3NsYXNoXG4gICAgICAgIC8vICAgIFxcXFwuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXG4gICAgICAgIC8vICAgIFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSAgICAgICAgICAtIGEgbWF0Y2hlZCBzZXQgb2YgY3VybHkgYnJhY2VzIGNvbnRhaW5pbmcgb3RoZXIgYXRvbXNcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gLyhbOipdKShbXFx3XFxbXFxdXSspfFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csIHNlYXJjaFBsYWNlaG9sZGVyID0gLyhbOl0/KShbXFx3XFxbXFxdLi1dKyl8XFx7KFtcXHdcXFtcXF0uLV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nLCBsYXN0ID0gMCwgbSwgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrUGFyYW1FcnJvcnMgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmICghVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yLnRlc3QoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbl8xLmZpbmQoX3RoaXMuX3BhcmFtcywgaG9mXzEucHJvcEVxKCdpZCcsIGlkKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lICdcIiArIGlkICsgXCInIGluIHBhdHRlcm4gJ1wiICsgcGF0dGVybiArIFwiJ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU3BsaXQgaW50byBzdGF0aWMgc2VnbWVudHMgc2VwYXJhdGVkIGJ5IHBhdGggcGFyYW1ldGVyIHBsYWNlaG9sZGVycy5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBhbHdheXMgMSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgbWF0Y2hEZXRhaWxzID0gZnVuY3Rpb24gKG0sIGlzU2VhcmNoKSB7XG4gICAgICAgICAgICAvLyBJRVs3OF0gcmV0dXJucyAnJyBmb3IgdW5tYXRjaGVkIGdyb3VwcyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgICAgICAgIHZhciBpZCA9IG1bMl0gfHwgbVszXTtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBpc1NlYXJjaCA/IG1bNF0gOiBtWzRdIHx8IChtWzFdID09PSAnKicgPyAnLionIDogbnVsbCk7XG4gICAgICAgICAgICB2YXIgbWFrZVJlZ2V4cFR5cGUgPSBmdW5jdGlvbiAocmVnZXhwKSB7IHJldHVybiBjb21tb25fMS5pbmhlcml0KHBhcmFtVHlwZXMudHlwZShpc1NlYXJjaCA/IFwicXVlcnlcIiA6IFwicGF0aFwiKSwge1xuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5ldyBSZWdFeHAocmVnZXhwLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICByZWdleHA6IHJlZ2V4cCxcbiAgICAgICAgICAgICAgICBjZmc6IF90aGlzLmNvbmZpZy5wYXJhbXNbaWRdLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QsIG0uaW5kZXgpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICFyZWdleHAgPyBudWxsIDogcGFyYW1UeXBlcy50eXBlKHJlZ2V4cCkgfHwgbWFrZVJlZ2V4cFR5cGUocmVnZXhwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAsIHNlZ21lbnQ7XG4gICAgICAgIHdoaWxlICgobSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XG4gICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChwLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3JlIGludG8gdGhlIHNlYXJjaCBwYXJ0XG4gICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21QYXRoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIGZhbHNlKSkpO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudHMucHVzaChwLnNlZ21lbnQpO1xuICAgICAgICAgICAgcGF0dGVybnMucHVzaChbcC5zZWdtZW50LCBjb21tb25fMS50YWlsKHRoaXMuX3BhcmFtcyldKTtcbiAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xuICAgICAgICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgICAgdmFyIGkgPSBzZWdtZW50LmluZGV4T2YoJz8nKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtID0gc2VhcmNoUGxhY2Vob2xkZXIuZXhlYyhzZWFyY2gpKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMucHVzaChwYXJhbUZhY3RvcnkuZnJvbVNlYXJjaChwLmlkLCBwLnR5cGUsIHRoaXMuY29uZmlnLnBhcmFtTWFwKHAuY2ZnLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiA/JlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB0aGlzLl9jb21waWxlZCA9IHBhdHRlcm5zLm1hcChmdW5jdGlvbiAocGF0dGVybikgeyByZXR1cm4gcXVvdGVSZWdFeHAuYXBwbHkobnVsbCwgcGF0dGVybik7IH0pLmNvbmNhdChxdW90ZVJlZ0V4cChzZWdtZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uY2F0ZW5hdGVkIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIEJ1aWxkcyBhIG5ldyBVcmxNYXRjaGVyIGJ5IGFwcGVuZGluZyBhbm90aGVyIFVybE1hdGNoZXIgdG8gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godXJsKTtcbiAgICAgICAgdXJsLl9jYWNoZSA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX2NhY2hlLnBhdGguY29uY2F0KHVybCksXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5wYXRoWzBdID09PSB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGlucHV0IHBhdHRlcm4gc3RyaW5nICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyB0aGUgc3BlY2lmaWVkIHVybC9wYXRoIGFnYWluc3QgdGhpcyBtYXRjaGVyLlxuICAgICAqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIHVybCBtYXRjaGVzIHRoaXMgbWF0Y2hlcidzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXB0dXJlZFxuICAgICAqIHBhcmFtZXRlciB2YWx1ZXMuICBSZXR1cm5zIG51bGwgaWYgdGhlIHBhdGggZG9lcyBub3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSB2YWx1ZXNcbiAgICAgKiBvZiBhbnkgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgbWVudGlvbmVkIGluIHRoZSBwYXR0ZXJuLCBidXQgdGhlaXIgdmFsdWUgbWF5IGJlIG51bGwgaWZcbiAgICAgKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxuICAgICAqIGFzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cSZyJykuZXhlYygnL3VzZXIvYm9iJywge1xuICAgICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXG4gICAgICogfSk7XG4gICAgICogLy8gcmV0dXJucyB7IGlkOiAnYm9iJywgcTogJ2hlbGxvJywgcjogbnVsbCB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAgICBUaGUgVVJMIHBhdGggdG8gbWF0Y2gsIGUuZy4gYCRsb2NhdGlvbi5wYXRoKClgLlxuICAgICAqIEBwYXJhbSBzZWFyY2ggIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cbiAgICAgKiBAcGFyYW0gaGFzaCAgICBVUkwgaGFzaCBlLmcuIGAkbG9jYXRpb24uaGFzaCgpYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNhcHR1cmVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChwYXRoLCBzZWFyY2gsIGhhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNlYXJjaCA9PT0gdm9pZCAwKSB7IHNlYXJjaCA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtYXRjaCA9IG1lbW9pemVUbyh0aGlzLl9jYWNoZSwgJ3BhdHRlcm4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChbXG4gICAgICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgICAgIGNvbW1vbl8xLnVubmVzdChfdGhpcy5fY2FjaGUucGF0aC5tYXAoaG9mXzEucHJvcCgnX2NvbXBpbGVkJykpKS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25maWcuc3RyaWN0ID09PSBmYWxzZSA/ICdcXC8/JyA6ICcnLFxuICAgICAgICAgICAgICAgICckJ1xuICAgICAgICAgICAgXS5qb2luKCcnKSwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pLmV4ZWMocGF0aCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy9vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgeyBpc29sYXRlOiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIGFsbFBhcmFtcyA9IHRoaXMucGFyYW1ldGVycygpLCBwYXRoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pc1NlYXJjaCgpOyB9KSwgc2VhcmNoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzU2VhcmNoKCk7IH0pLCBuUGF0aFNlZ21lbnRzID0gdGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKHVybG0pIHsgcmV0dXJuIHVybG0uX3NlZ21lbnRzLmxlbmd0aCAtIDE7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgeCkgeyByZXR1cm4gYSArIHg7IH0pLCB2YWx1ZXMgPSB7fTtcbiAgICAgICAgaWYgKG5QYXRoU2VnbWVudHMgIT09IG1hdGNoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJ1wiICsgdGhpcy5wYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTsgfTtcbiAgICAgICAgICAgIHZhciB1bnF1b3RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwtL2csIFwiLVwiKTsgfTtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHJldmVyc2VTdHJpbmcoc3RyaW5nKS5zcGxpdCgvLSg/IVxcXFwpLyk7XG4gICAgICAgICAgICB2YXIgYWxsUmV2ZXJzZWQgPSBjb21tb25fMS5tYXAoc3BsaXQsIHJldmVyc2VTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcChhbGxSZXZlcnNlZCwgdW5xdW90ZURhc2hlcykucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhdGhTZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXRoUGFyYW1zW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmFtIHZhbHVlIG1hdGNoZXMgYSBwcmUtcmVwbGFjZSBwYWlyLCByZXBsYWNlIHRoZSB2YWx1ZSBiZWZvcmUgZGVjb2RpbmcuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHBhcmFtLmFycmF5ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlUGF0aEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWFyY2hbcGFyYW0uaWRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzaClcbiAgICAgICAgICAgIHZhbHVlc1tcIiNcIl0gPSBoYXNoO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgYWxsIHRoZSBbW1BhcmFtXV0gb2JqZWN0cyBvZiBhbGwgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhpcyBwYXR0ZXJuIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBhcmFtPn0gIEFuIGFycmF5IG9mIFtbUGFyYW1dXSBvYmplY3RzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcbiAgICAgKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgaWYgKG9wdHMuaW5oZXJpdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudW5uZXN0KHRoaXMuX2NhY2hlLnBhdGgubWFwKGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVyLl9wYXJhbXM7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIHBhcmFtZXRlciBmcm9tIHRoaXMgVXJsTWF0Y2hlciBieSBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcmV0dXJucyB7VHxQYXJhbXxhbnl8Ym9vbGVhbnxVcmxNYXRjaGVyfG51bGx9XG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVyID0gZnVuY3Rpb24gKGlkLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciBmaW5kUGFyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuX3BhcmFtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmlkID09PSBpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fY2FjaGUucGFyZW50O1xuICAgICAgICByZXR1cm4gZmluZFBhcmFtKCkgfHwgKG9wdHMuaW5oZXJpdCAhPT0gZmFsc2UgJiYgcGFyZW50ICYmIHBhcmVudC5wYXJhbWV0ZXIoaWQsIG9wdHMpKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdmFsdWVzIGFnYWluc3QgdGhpcyBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuICAgICAqIHR5cGVzIG9mIHRoaXMgYFVybE1hdGNoZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbGlkUGFyYW1WYWwgPSBmdW5jdGlvbiAocGFyYW0sIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFwYXJhbSB8fCBwYXJhbS52YWxpZGF0ZXModmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAvLyBJJ20gbm90IHN1cmUgd2h5IHRoaXMgY2hlY2tzIG9ubHkgdGhlIHBhcmFtIGtleXMgcGFzc2VkIGluLCBhbmQgbm90IGFsbCB0aGUgcGFyYW1zIGtub3duIHRvIHRoZSBtYXRjaGVyXG4gICAgICAgIHZhciBwYXJhbVNjaGVtYSA9IHRoaXMucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbURlZi5pZCk7IH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1TY2hlbWEubWFwKGZ1bmN0aW9uIChwYXJhbURlZikgeyByZXR1cm4gdmFsaWRQYXJhbVZhbChwYXJhbURlZiwgcGFyYW1zW3BhcmFtRGVmLmlkXSk7IH0pLnJlZHVjZShjb21tb25fMS5hbGxUcnVlUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzLCBjcmVhdGVzIGEgVVJMIGZyb20gdGhpcyBVcmxNYXRjaGVyLlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJykuZm9ybWF0KHsgaWQ6J2JvYicsIHE6J3llcycgfSk7XG4gICAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBmdWxsIHBhdGggb2YgVXJsTWF0Y2hlcnMgKGluY2x1ZGluZyBhbGwgcGFyZW50IFVybE1hdGNoZXJzKVxuICAgICAgICB2YXIgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoO1xuICAgICAgICAvLyBFeHRyYWN0IGFsbCB0aGUgc3RhdGljIHNlZ21lbnRzIGFuZCBQYXJhbXMgKHByb2Nlc3NlZCBhcyBQYXJhbURldGFpbHMpXG4gICAgICAgIC8vIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAgICAgICB2YXIgcGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSA/IHggOiBnZXREZXRhaWxzKHgpOyB9KTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcXVlcnkgcGFyYW1zIGludG8gYSBzZXBhcmF0ZSBhcnJheVxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSB1cmxNYXRjaGVycy5tYXAoVXJsTWF0Y2hlci5xdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAubWFwKGdldERldGFpbHMpO1xuICAgICAgICB2YXIgaXNJbnZhbGlkID0gZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1ZhbGlkID09PSBmYWxzZTsgfTtcbiAgICAgICAgaWYgKHBhdGhTZWdtZW50c0FuZFBhcmFtcy5jb25jYXQocXVlcnlQYXJhbXMpLmZpbHRlcihpc0ludmFsaWQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgUGFyYW0sIGFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gdHlwZWQgdmFsdWVcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pO1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBwYXJhbS52YWxpZGF0ZXModmFsdWUpO1xuICAgICAgICAgICAgdmFyIGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gc3F1YXNoIG1vZGUgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHZhciBzcXVhc2ggPSBpc0RlZmF1bHRWYWx1ZSA/IHBhcmFtLnNxdWFzaCA6IGZhbHNlO1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBwYXJhbS50eXBlLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgaXNWYWxpZDogaXNWYWxpZCwgaXNEZWZhdWx0VmFsdWU6IGlzRGVmYXVsdFZhbHVlLCBzcXVhc2g6IHNxdWFzaCwgZW5jb2RlZDogZW5jb2RlZCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBwYXRoLXBvcnRpb24gZnJvbSB0aGUgbGlzdCBvZiBzdGF0aWMgc2VnbWVudHMgYW5kIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoU2VnbWVudHNBbmRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyB4O1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW1EZXRhaWxzLlxuICAgICAgICAgICAgdmFyIHNxdWFzaCA9IHguc3F1YXNoLCBlbmNvZGVkID0geC5lbmNvZGVkLCBwYXJhbSA9IHgucGFyYW07XG4gICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgPT09IHRydWUsIHRyeSB0byByZW1vdmUgYSBzbGFzaCBmcm9tIHRoZSBwYXRoXG4gICAgICAgICAgICBpZiAoc3F1YXNoID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjLm1hdGNoKC9cXC8kLykpID8gYWNjLnNsaWNlKDAsIC0xKSA6IGFjYztcbiAgICAgICAgICAgIC8vIElmIHNxdWFzaCBpcyBhIHN0cmluZywgdXNlIHRoZSBzdHJpbmcgZm9yIHRoZSBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBzcXVhc2g7XG4gICAgICAgICAgICBpZiAoc3F1YXNoICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjOyAvLyA/XG4gICAgICAgICAgICBpZiAoZW5jb2RlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShlbmNvZGVkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgY29tbW9uXzEubWFwKGVuY29kZWQsIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzKS5qb2luKFwiLVwiKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICAgICAgIGlmIChwYXJhbS5yYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZWQ7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gYWNjICsgZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgLy8gQnVpbGQgdGhlIHF1ZXJ5IHN0cmluZyBieSBhcHBseWluZyBwYXJhbWV0ZXIgdmFsdWVzIChhcnJheSBvciByZWd1bGFyKVxuICAgICAgICAvLyB0aGVuIG1hcHBpbmcgdG8ga2V5PXZhbHVlLCB0aGVuIGZsYXR0ZW5pbmcgYW5kIGpvaW5pbmcgdXNpbmcgXCImXCJcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbURldGFpbHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtRGV0YWlscy5wYXJhbSwgc3F1YXNoID0gcGFyYW1EZXRhaWxzLnNxdWFzaCwgZW5jb2RlZCA9IHBhcmFtRGV0YWlscy5lbmNvZGVkLCBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtRGV0YWlscy5pc0RlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwgfHwgKGlzRGVmYXVsdFZhbHVlICYmIHNxdWFzaCAhPT0gZmFsc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IFtlbmNvZGVkXTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXBhcmFtLnJhdylcbiAgICAgICAgICAgICAgICBlbmNvZGVkID0gY29tbW9uXzEubWFwKGVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyYW0uaWQgKyBcIj1cIiArIHZhbDsgfSk7XG4gICAgICAgIH0pLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKS5qb2luKFwiJlwiKTtcbiAgICAgICAgLy8gQ29uY2F0IHRoZSBwYXRoc3RyaW5nIHdpdGggdGhlIHF1ZXJ5U3RyaW5nIChpZiBleGlzdHMpIGFuZCB0aGUgaGFzaFN0cmluZyAoaWYgZXhpc3RzKVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyArIChxdWVyeVN0cmluZyA/IFwiP1wiICsgcXVlcnlTdHJpbmcgOiBcIlwiKSArICh2YWx1ZXNbXCIjXCJdID8gXCIjXCIgKyB2YWx1ZXNbXCIjXCJdIDogXCJcIik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvLS9nLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gXCIlNUMlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHBhdGggc2VnbWVudHMgYW5kIHBhdGggcGFyYW1zLCBpbiBvcmRlciAqL1xuICAgIFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgdmFyIHN0YXRpY1NlZ21lbnRzID0gbWF0Y2hlci5fc2VnbWVudHM7XG4gICAgICAgIHZhciBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlBBVEg7IH0pO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuYXJyYXlUdXBsZXMoc3RhdGljU2VnbWVudHMsIHBhdGhQYXJhbXMuY29uY2F0KHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gXCJcIiAmJiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBxdWVyeSBwYXJhbXMgKi9cbiAgICBVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubG9jYXRpb24gPT09IHBhcmFtXzEuRGVmVHlwZS5TRUFSQ0g7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gVXJsTWF0Y2hlcnNcbiAgICAgKlxuICAgICAqIFRoaXMgY29tcGFyaXNvbiBmdW5jdGlvbiBjb252ZXJ0cyBhIFVybE1hdGNoZXIgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBFYWNoIHN0YXRpYyBwYXRoIHNlZ21lbnQgaXMgYSBzdGF0aWMgc3RyaW5nIGJldHdlZW4gYSBwYXRoIHNlcGFyYXRvciAoc2xhc2ggY2hhcmFjdGVyKS5cbiAgICAgKiBFYWNoIGR5bmFtaWMgc2VnbWVudCBpcyBhIHBhdGggcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gc29ydHMgc3RhdGljIHNlZ21lbnRzIGJlZm9yZSBkeW5hbWljIG9uZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm4gYSBVcmxNYXRjaGVyIGFuZCBhbGwgaXRzIHBhcmVudCBtYXRjaGVycyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAqIG9mIHNsYXNoIGxpdGVyYWxzICcvJywgc3RyaW5nIGxpdGVyYWxzLCBhbmQgUGFyYW0gb2JqZWN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGV4YW1wbGUgbWF0Y2hlciBtYXRjaGVzIHN0cmluZ3MgbGlrZSBcIi9mb28vOnBhcmFtL3RhaWxcIjpcbiAgICAgICAgICogdmFyIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vXCIpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCIvOnBhcmFtXCIpKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiL1wiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcInRhaWxcIikpO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gc2VnbWVudHMobWF0Y2hlcik7IC8vIFsgJy8nLCAnZm9vJywgJy8nLCBQYXJhbSwgJy8nLCAndGFpbCcgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHNgXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzID0gbWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgfHxcbiAgICAgICAgICAgICAgICBtYXRjaGVyLl9jYWNoZS5wYXRoLm1hcChVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShzdHJpbmdzXzEuam9pbk5laWdoYm9yc1IsIFtdKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkgPyBzcGxpdE9uU2xhc2goeCkgOiB4OyB9KVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHNvcnQgd2VpZ2h0IGZvciBlYWNoIHNlZ21lbnQgb2YgYSBVcmxNYXRjaGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIENhY2hlcyB0aGUgcmVzdWx0IGFzIGBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzYFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHdlaWdodHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuX2NhY2hlLndlaWdodHMgPSBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzIHx8XG4gICAgICAgICAgICAgICAgc2VnbWVudHMobWF0Y2hlcikubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgc2xhc2hlcyBmaXJzdCwgdGhlbiBzdGF0aWMgc3RyaW5ncywgdGhlIFBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy8nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc2VnbWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBwYXJhbV8xLlBhcmFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbXAsIGksIHBhaXJzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMod2VpZ2h0cyhhKSwgd2VpZ2h0cyhiKSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gcGFpcnNbaV1bMF0gLSBwYWlyc1tpXVsxXTtcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIHJldHVybiBVcmxNYXRjaGVyO1xufSgpKTtcbi8qKiBAaGlkZGVuICovXG5VcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IgPSAvXlxcdysoWy0uXStcXHcrKSooPzpcXFtcXF0pPyQvO1xuZXhwb3J0cy5VcmxNYXRjaGVyID0gVXJsTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybE1hdGNoZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/urlMatcher.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ \"./node_modules/@uirouter/core/lib/url/urlMatcher.js\");\nvar param_1 = __webpack_require__(/*! ../params/param */ \"./node_modules/@uirouter/core/lib/params/param.js\");\nvar paramTypes_1 = __webpack_require__(/*! ../params/paramTypes */ \"./node_modules/@uirouter/core/lib/params/paramTypes.js\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybE1hdGNoZXJGYWN0b3J5LmpzPzA4YTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIHBhcmFtVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1UeXBlc1wiKTtcbi8qKlxuICogRmFjdG9yeSBmb3IgW1tVcmxNYXRjaGVyXV0gaW5zdGFuY2VzLlxuICpcbiAqIFRoZSBmYWN0b3J5IGlzIGF2YWlsYWJsZSB0byBuZzEgc2VydmljZXMgYXNcbiAqIGAkdXJsTWF0Y2hlckZhY3RvcmAgb3IgbmcxIHByb3ZpZGVycyBhcyBgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJgLlxuICovXG52YXIgVXJsTWF0Y2hlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVybE1hdGNoZXJGYWN0b3J5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLnBhcmFtVHlwZXMgPSBuZXcgcGFyYW1UeXBlc18xLlBhcmFtVHlwZXMoKTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeSA9IGZhbHNlO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9nZXRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHsgc3RyaWN0OiBfdGhpcy5faXNTdHJpY3RNb2RlLCBjYXNlSW5zZW5zaXRpdmU6IF90aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSB9LCBjb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsYXBpIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZvciBhIGdpdmVuIGxvY2F0aW9uIChEZWZUeXBlKSAqL1xuICAgICAgICB0aGlzLnBhcmFtRmFjdG9yeSA9IHtcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgQ09ORklHIGJsb2NrICovXG4gICAgICAgICAgICBmcm9tQ29uZmlnOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuQ09ORklHLCBfdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSB1cmwgUEFUSCAqL1xuICAgICAgICAgICAgZnJvbVBhdGg6IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbV8xLlBhcmFtKGlkLCB0eXBlLCBjb25maWcsIHBhcmFtXzEuRGVmVHlwZS5QQVRILCBfdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSB1cmwgU0VBUkNIICovXG4gICAgICAgICAgICBmcm9tU2VhcmNoOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuU0VBUkNILCBfdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgeyBVcmxNYXRjaGVyOiB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlciwgUGFyYW06IHBhcmFtXzEuUGFyYW0gfSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5jYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLnN0cmljdE1vZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3RyaWN0TW9kZSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc1N0cmljdE1vZGU7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuZGVmYXVsdFNxdWFzaFBvbGljeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlICYmICFwcmVkaWNhdGVzXzEuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcXVhc2ggcG9saWN5OiBcIiArIHZhbHVlICsgXCIuIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgYXJiaXRyYXJ5LXN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3kgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1VybE1hdGNoZXJdXSBmb3IgdGhlIHNwZWNpZmllZCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdHRlcm4gIFRoZSBVUkwgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0gY29uZmlnICBUaGUgY29uZmlnIG9iamVjdCBoYXNoLlxuICAgICAqIEByZXR1cm5zIFRoZSBVcmxNYXRjaGVyLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHBhdHRlcm4sIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKHBhdHRlcm4sIHRoaXMucGFyYW1UeXBlcywgdGhpcy5wYXJhbUZhY3RvcnksIHRoaXMuX2dldENvbmZpZyhjb25maWcpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIFtbVXJsTWF0Y2hlcl1dLCBvciBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0ICBUaGUgb2JqZWN0IHRvIHBlcmZvcm0gdGhlIHR5cGUgY2hlY2sgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtYXRjaGVzIHRoZSBgVXJsTWF0Y2hlcmAgaW50ZXJmYWNlLCBieVxuICAgICAqICAgICAgICAgIGltcGxlbWVudGluZyBhbGwgdGhlIHNhbWUgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuaXNNYXRjaGVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAvLyBUT0RPOiB0eXBlb2Y/XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzT2JqZWN0KG9iamVjdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBjb21tb25fMS5mb3JFYWNoKHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyLnByb3RvdHlwZSwgZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHZhbCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG9iamVjdFtuYW1lXSkgJiYgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24ob2JqZWN0W25hbWVdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIGN1c3RvbSBbW1BhcmFtVHlwZV1dIG9iamVjdFxuICAgICAqXG4gICAgICogQSBbW1BhcmFtVHlwZV1dIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgIFRoZSB0eXBlIG5hbWUuXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gVGhlIHR5cGUgZGVmaW5pdGlvbi4gU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9uRm4gQSBmdW5jdGlvbiB0aGF0IGlzIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwIHJ1bnRpbWUgc3RhcnRzLlxuICAgICAqICAgICAgICBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0uXG4gICAgICogICAgICAgIFRoZSByZXN1bHQgaXMgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGBkZWZpbml0aW9uYC5cbiAgICAgKiAgICAgICAgU2VlIFtbUGFyYW1UeXBlXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIGlmIGEgdHlwZSB3YXMgcmVnaXN0ZXJlZDogdGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXVxuICAgICAqICAgLSBpZiBvbmx5IHRoZSBgbmFtZWAgcGFyYW1ldGVyIHdhcyBzcGVjaWZpZWQ6IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBbW1BhcmFtVHlwZV1dIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBOb3RlOiBSZWdpc3RlciBjdXN0b20gdHlwZXMgKmJlZm9yZSB1c2luZyB0aGVtKiBpbiBhIHN0YXRlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIGV4YW1wbGVzXG4gICAgICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5wYXJhbVR5cGVzLnR5cGUobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKTtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGRlZmluaXRpb24pID8gdHlwZSA6IHRoaXM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJhbVR5cGVzLmVucXVldWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJhbVR5cGVzLl9mbHVzaFR5cGVRdWV1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVXJsTWF0Y2hlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5VcmxNYXRjaGVyRmFjdG9yeSA9IFVybE1hdGNoZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsTWF0Y2hlckZhY3RvcnkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlRouter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ \"./node_modules/@uirouter/core/lib/url/urlMatcher.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar urlRule_1 = __webpack_require__(/*! ./urlRule */ \"./node_modules/@uirouter/core/lib/url/urlRule.js\");\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ \"./node_modules/@uirouter/core/lib/state/targetState.js\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this._sorted = false;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\nfunction getHandlerFn(handler) {\n    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n    }\n    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n}\n//# sourceMappingURL=urlRouter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSb3V0ZXIuanM/YTYxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdXJsUnVsZV8xID0gcmVxdWlyZShcIi4vdXJsUnVsZVwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgYWJzb2x1dGUsIGJhc2VIcmVmKSB7XG4gICAgaWYgKGJhc2VIcmVmID09PSAnLycpXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgaWYgKGlzSHRtbDUpXG4gICAgICAgIHJldHVybiBiYXNlSHJlZi5zbGljZSgwLCAtMSkgKyB1cmw7XG4gICAgaWYgKGFic29sdXRlKVxuICAgICAgICByZXR1cm4gYmFzZUhyZWYuc2xpY2UoMSkgKyB1cmw7XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgZ2V0TWF0Y2hlciA9IGhvZl8xLnByb3AoXCJ1cmxNYXRjaGVyXCIpO1xuLyoqXG4gKiBEZWZhdWx0IHJ1bGUgcHJpb3JpdHkgc29ydGluZyBmdW5jdGlvbi5cbiAqXG4gKiBTb3J0cyBydWxlcyBieTpcbiAqXG4gKiAtIEV4cGxpY2l0IHByaW9yaXR5IChzZXQgcnVsZSBwcmlvcml0eSB1c2luZyBbW1VybFJ1bGVzQXBpLndoZW5dXSlcbiAqIC0gUnVsZSB0eXBlIChTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxKVxuICogLSBgVXJsTWF0Y2hlcmAgc3BlY2lmaWNpdHkgKFtbVXJsTWF0Y2hlci5jb21wYXJlXV0pOiB3b3JrcyBmb3IgU1RBVEUgYW5kIFVSTE1BVENIRVIgdHlwZXMgdG8gcGljayB0aGUgbW9zdCBzcGVjaWZpYyBydWxlLlxuICogLSBSZWdpc3RyYXRpb24gb3JkZXIgKGZvciBydWxlIHR5cGVzIG90aGVyIHRoYW4gU1RBVEUgYW5kIFVSTE1BVENIRVIpXG4gKlxuICogQGNvcmVhcGlcbiAqL1xudmFyIGRlZmF1bHRSdWxlU29ydEZuO1xuZGVmYXVsdFJ1bGVTb3J0Rm4gPSBjb21tb25fMS5jb21wb3NlU29ydChjb21tb25fMS5zb3J0QnkoaG9mXzEucGlwZShob2ZfMS5wcm9wKFwicHJpb3JpdHlcIiksIGZ1bmN0aW9uICh4KSB7IHJldHVybiAteDsgfSkpLCBjb21tb25fMS5zb3J0QnkoaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidHlwZVwiKSwgZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuICh7IFwiU1RBVEVcIjogNCwgXCJVUkxNQVRDSEVSXCI6IDQsIFwiUkVHRVhQXCI6IDMsIFwiUkFXXCI6IDIsIFwiT1RIRVJcIjogMSB9KVt0eXBlXTsgfSkpLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGdldE1hdGNoZXIoYSkgJiYgZ2V0TWF0Y2hlcihiKSkgPyB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlci5jb21wYXJlKGdldE1hdGNoZXIoYSksIGdldE1hdGNoZXIoYikpIDogMDsgfSwgY29tbW9uXzEuc29ydEJ5KGhvZl8xLnByb3AoXCIkaWRcIiksIGNvbW1vbl8xLmluQXJyYXkoW1wiUkVHRVhQXCIsIFwiUkFXXCIsIFwiT1RIRVJcIl0pKSk7XG4vKipcbiAqIFVwZGF0ZXMgVVJMIGFuZCByZXNwb25kcyB0byBVUkwgY2hhbmdlc1xuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc0FwaV1dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAqXG4gKiBUaGlzIGNsYXNzIHVwZGF0ZXMgdGhlIFVSTCB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICogSXQgYWxzbyByZXNwb25kcyB0byBjaGFuZ2VzIGluIHRoZSBVUkwuXG4gKi9cbnZhciBVcmxSb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gVXJsUm91dGVyKHJvdXRlcikge1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9zb3J0Rm4gPSBkZWZhdWx0UnVsZVNvcnRGbjtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5pbnRlcmNlcHREZWZlcnJlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9pZCA9IDA7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMudXJsUnVsZUZhY3RvcnkgPSBuZXcgdXJsUnVsZV8xLlVybFJ1bGVGYWN0b3J5KHJvdXRlcik7XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGhvZl8xLnZhbChVcmxSb3V0ZXIucHJvdG90eXBlKSwgdGhpcywgaG9mXzEudmFsKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLl9ydWxlcyA9IFtdO1xuICAgICAgICBkZWxldGUgdGhpcy5fb3RoZXJ3aXNlRm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoY29tcGFyZUZuKSB7XG4gICAgICAgIHRoaXMuX3J1bGVzLnNvcnQodGhpcy5fc29ydEZuID0gY29tcGFyZUZuIHx8IHRoaXMuX3NvcnRGbik7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmVuc3VyZVNvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc29ydGVkIHx8IHRoaXMuc29ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBVUkwsIGNoZWNrIGFsbCBydWxlcyBhbmQgcmV0dXJuIHRoZSBiZXN0IFtbTWF0Y2hSZXN1bHRdXVxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKiBAcmV0dXJucyB7TWF0Y2hSZXN1bHR9XG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICAgICAgdXJsID0gY29tbW9uXzEuZXh0ZW5kKHsgcGF0aDogJycsIHNlYXJjaDoge30sIGhhc2g6ICcnIH0sIHVybCk7XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX290aGVyd2lzZUZuKVxuICAgICAgICAgICAgcnVsZXMucHVzaCh0aGlzLl9vdGhlcndpc2VGbik7XG4gICAgICAgIC8vIENoZWNrcyBhIHNpbmdsZSBydWxlLiBSZXR1cm5zIHsgcnVsZTogcnVsZSwgbWF0Y2g6IG1hdGNoLCB3ZWlnaHQ6IHdlaWdodCB9IGlmIGl0IG1hdGNoZWQsIG9yIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY2hlY2tSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2godXJsLCBfdGhpcy5fcm91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiB7IG1hdGNoOiBtYXRjaCwgcnVsZTogcnVsZSwgd2VpZ2h0OiBydWxlLm1hdGNoUHJpb3JpdHkobWF0Y2gpIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBydWxlcyBhcmUgcHJlLXNvcnRlZC5cbiAgICAgICAgLy8gLSBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyBydWxlLlxuICAgICAgICAvLyAtIEZpbmQgYW55IG90aGVyIG1hdGNoaW5nIHJ1bGUgdGhhdCBzb3J0ZWQgKmV4YWN0bHkgdGhlIHNhbWUqLCBhY2NvcmRpbmcgdG8gYC5zb3J0KClgLlxuICAgICAgICAvLyAtIENob29zZSB0aGUgcnVsZSB3aXRoIHRoZSBoaWdoZXN0IG1hdGNoIHdlaWdodC5cbiAgICAgICAgdmFyIGJlc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFN0b3Agd2hlbiB0aGVyZSBpcyBhICdiZXN0JyBydWxlIGFuZCB0aGUgbmV4dCBydWxlIHNvcnRzIGRpZmZlcmVudGx5IHRoYW4gaXQuXG4gICAgICAgICAgICBpZiAoYmVzdCAmJiB0aGlzLl9zb3J0Rm4ocnVsZXNbaV0sIGJlc3QucnVsZSkgIT09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGNoZWNrUnVsZShydWxlc1tpXSk7XG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBiZXN0IE1hdGNoUmVzdWx0XG4gICAgICAgICAgICBiZXN0ID0gKCFiZXN0IHx8IGN1cnJlbnQgJiYgY3VycmVudC53ZWlnaHQgPiBiZXN0LndlaWdodCkgPyBjdXJyZW50IDogYmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiBldnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuX3JvdXRlciwgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlLCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAgICB2YXIgdXJsID0ge1xuICAgICAgICAgICAgcGF0aDogJHVybC5wYXRoKCksIHNlYXJjaDogJHVybC5zZWFyY2goKSwgaGFzaDogJHVybC5oYXNoKCksXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiZXN0ID0gdGhpcy5tYXRjaCh1cmwpO1xuICAgICAgICB2YXIgYXBwbHlSZXN1bHQgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdHJpbmcsIGZ1bmN0aW9uIChuZXd1cmwpIHsgcmV0dXJuICR1cmwudXJsKG5ld3VybCwgdHJ1ZSk7IH1dLFxuICAgICAgICAgICAgW3RhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUuaXNEZWYsIGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuICRzdGF0ZS5nbyhkZWYuc3RhdGUsIGRlZi5wYXJhbXMsIGRlZi5vcHRpb25zKTsgfV0sXG4gICAgICAgICAgICBbaG9mXzEuaXModGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSksIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICRzdGF0ZS5nbyh0YXJnZXQuc3RhdGUoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTsgfV0sXG4gICAgICAgIF0pO1xuICAgICAgICBhcHBseVJlc3VsdChiZXN0ICYmIGJlc3QucnVsZS5oYW5kbGVyKGJlc3QubWF0Y2gsIHVybCwgcm91dGVyKSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcEZuICYmIHRoaXMuX3N0b3BGbigpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0b3BGbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wRm4gPSB0aGlzLl9zdG9wRm4gfHwgdGhpcy5fcm91dGVyLnVybFNlcnZpY2Uub25DaGFuZ2UoZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuc3luYyhldnQpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQVBJLlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlYWQpIHtcbiAgICAgICAgdmFyICR1cmwgPSB0aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlO1xuICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICR1cmwucGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkdXJsLnBhdGgoKSA9PT0gdGhpcy5sb2NhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgJHVybC51cmwodGhpcy5sb2NhdGlvbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBBUEkuXG4gICAgICpcbiAgICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVwbGFjZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLnVybCh1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbmQgcmV0dXJucyBhIFVSTCB3aXRoIGludGVycG9sYXRlZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Fib3V0LzpwZXJzb25cIik7XG4gICAgICogcGFyYW1zID0geyBwZXJzb246IFwiYm9iXCIgfTtcbiAgICAgKiAkYm9iID0gJHVybFJvdXRlci5ocmVmKG1hdGNoZXIsIHBhcmFtcyk7XG4gICAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyIFRoZSBbW1VybE1hdGNoZXJdXSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBhcyB0aGUgdGVtcGxhdGUgb2YgdGhlIFVSTCB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIG1hdGNoZXIncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZnVsbHkgY29tcGlsZWQgVVJMLCBvciBgbnVsbGAgaWYgYHBhcmFtc2AgZmFpbCB2YWxpZGF0aW9uIGFnYWluc3QgYHVybE1hdGNoZXJgXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgYWJzb2x1dGU6IGZhbHNlIH07XG4gICAgICAgIHZhciBjZmcgPSB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgICAgIHZhciBpc0h0bWw1ID0gY2ZnLmh0bWw1TW9kZSgpO1xuICAgICAgICBpZiAoIWlzSHRtbDUgJiYgdXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcIiNcIiArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBvcHRpb25zLmFic29sdXRlLCBjZmcuYmFzZUhyZWYoKSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZSB8fCAhdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbGFzaCA9ICghaXNIdG1sNSAmJiB1cmwgPyAnLycgOiAnJyksIHBvcnQgPSBjZmcucG9ydCgpO1xuICAgICAgICBwb3J0ID0gKHBvcnQgPT09IDgwIHx8IHBvcnQgPT09IDQ0MyA/ICcnIDogJzonICsgcG9ydCk7XG4gICAgICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGFkZHMgYSBVUkwgUnVsZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHksIGEgdXJsIHJ1bGUgaXMgYWRkZWQgdXNpbmcgW1tTdGF0ZURlY2xhcmF0aW9uLnVybF1dIG9yIFtbd2hlbl1dLlxuICAgICAqIFRoaXMgYXBpIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGZvciBtb3JlIGNvbnRyb2wgKHRvIHJlZ2lzdGVyIGEgW1tCYXNlVXJsUnVsZV1dLCBmb3IgZXhhbXBsZSkuXG4gICAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1tVcmxSb3V0ZXIudXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQSBydWxlIHNob3VsZCBoYXZlIGEgYG1hdGNoYCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRydXRoeSBpZiB0aGUgcnVsZSBtYXRjaGVkLlxuICAgICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBydWxlXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1cmxSdWxlXzEuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBydWxlXCIpO1xuICAgICAgICBydWxlLiRpZCA9IHRoaXMuX2lkKys7XG4gICAgICAgIHJ1bGUucHJpb3JpdHkgPSBydWxlLnByaW9yaXR5IHx8IDA7XG4gICAgICAgIHRoaXMuX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlUnVsZShydWxlKTsgfTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUucmVtb3ZlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5fcnVsZXMsIHJ1bGUpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzLnNsaWNlKCk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVyRm4gPSBnZXRIYW5kbGVyRm4oaGFuZGxlcik7XG4gICAgICAgIHRoaXMuX290aGVyd2lzZUZuID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUoaG9mXzEudmFsKHRydWUpLCBoYW5kbGVyRm4pO1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmluaXRpYWwgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB2YXIgbWF0Y2hGbiA9IGZ1bmN0aW9uICh1cmxQYXJ0cywgcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbkhpc3Rvcnkuc2l6ZSgpID09PSAwICYmICEhL15cXC8/JC8uZXhlYyh1cmxQYXJ0cy5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uIChtYXRjaGVyLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUobWF0Y2hlciwgaGFuZGxlcik7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkpXG4gICAgICAgICAgICBydWxlLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgICAgICAgdGhpcy5ydWxlKHJ1bGUpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG4gICAgICAgIGlmIChkZWZlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVmZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZGVmZXI7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIFVybFJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcbmZ1bmN0aW9uIGdldEhhbmRsZXJGbihoYW5kbGVyKSB7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpICYmICFob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKShoYW5kbGVyKSAmJiAhdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZihoYW5kbGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyIDogaG9mXzEudmFsKGhhbmRsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/urlRouter.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlRule.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlRule.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ \"./node_modules/@uirouter/core/lib/url/urlMatcher.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qcz82N2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXVxuICpcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXSBmcm9tIGE6XG4gKlxuICogLSBgc3RyaW5nYFxuICogLSBbW1VybE1hdGNoZXJdXVxuICogLSBgUmVnRXhwYFxuICogLSBbW1N0YXRlT2JqZWN0XV1cbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgVXJsUnVsZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVybFJ1bGVGYWN0b3J5KHJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB9XG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHN0cik7XG4gICAgfTtcbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1ha2VSdWxlID0gaG9mXzEucGF0dGVybihbXG4gICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzU3RyaW5nLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIG1ha2VSdWxlKF90aGlzLmNvbXBpbGUoX3doYXQpKTsgfV0sXG4gICAgICAgICAgICBbaG9mXzEuaXModXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIpLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21VcmxNYXRjaGVyKF93aGF0LCBoYW5kbGVyKTsgfV0sXG4gICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzU3RhdGUsIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVN0YXRlKF93aGF0LCBfdGhpcy5yb3V0ZXIpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyhSZWdFeHApLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21SZWdFeHAoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBuZXcgQmFzZVVybFJ1bGUoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBydWxlID0gbWFrZVJ1bGUod2hhdCk7XG4gICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ3doYXQnIGluIHdoZW4oKVwiKTtcbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBiYXNlZCBvbiBhIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIGBzdHJpbmdgLCBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGFub3RoZXIgW1tVcmxNYXRjaGVyXV1cbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XG4gICAgICpcbiAgICAgKiAtIG1hdGNoZWQgcGFyYW1ldGVyIHZhbHVlcyAoW1tSYXdQYXJhbXNdXSBmcm9tIFtbVXJsTWF0Y2hlci5leGVjXV0pXG4gICAgICogLSB1cmw6IHRoZSBjdXJyZW50IFVybCAoW1tVcmxQYXJ0c11dKVxuICAgICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHVybE1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vLzpmb29JZC86YmFySWRcIik7XG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaC5mb29JZCArIFwiL1wiICsgbWF0Y2guYmFySWQpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgVXJsTWF0Y2hlciwgdGhlIGhhbmRsZXIgbWF0Y2hlciBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbmV3IHVybC5cbiAgICAgKiBUaGUgYGhhbmRsZXJgIFVybE1hdGNoZXIgaXMgZm9ybWF0dGVkIHVzaW5nIHRoZSBtYXRjaGVkIHBhcmFtIGZyb20gdGhlIGZpcnN0IG1hdGNoZXIuXG4gICAgICogVGhlIHVybCBpcyByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgaGFuZGxlciA9ICR1bWYuY29tcGlsZShcIi9ob21lLzpmb29JZC86YmFySWRcIik7XG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIGhhbmRsZXIpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVVybE1hdGNoZXIgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpKVxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoaGFuZGxlcik7XG4gICAgICAgIGlmIChob2ZfMS5pcyh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlcikoaGFuZGxlcikpXG4gICAgICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gaGFuZGxlci5mb3JtYXQobWF0Y2gpOyB9O1xuICAgICAgICBmdW5jdGlvbiBtYXRjaCh1cmwpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHVybE1hdGNoZXIuZXhlYyh1cmwucGF0aCwgdXJsLnNlYXJjaCwgdXJsLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHVybE1hdGNoZXIudmFsaWRhdGVzKG1hdGNoKSAmJiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmlvcml0aXplIFVSTHMsIGxvd2VzdCB0byBoaWdoZXN0OlxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgVVJMIHBhcmFtZXRlcnMsIGJ1dCBub25lIG1hdGNoZWRcbiAgICAgICAgLy8gLSBObyBvcHRpb25hbCBwYXJhbWV0ZXJzIGluIFVSTFxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycywgc29tZSBtYXRjaGVkXG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBhbGwgbWF0Y2hlZFxuICAgICAgICBmdW5jdGlvbiBtYXRjaFByaW9yaXR5KHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdXJsTWF0Y2hlci5wYXJhbWV0ZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaXNPcHRpb25hbDsgfSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbmFsLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAwMDE7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG9wdGlvbmFsLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtc1twYXJhbS5pZF07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoIC8gb3B0aW9uYWwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXRhaWxzID0geyB1cmxNYXRjaGVyOiB1cmxNYXRjaGVyLCBtYXRjaFByaW9yaXR5OiBtYXRjaFByaW9yaXR5LCB0eXBlOiBcIlVSTE1BVENIRVJcIiB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgX2hhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGEgc3RhdGUgYnkgaXRzIHVybFxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21TdGF0ZSgkc3RhdGUuZ2V0KCdmb28nKSwgcm91dGVyKTtcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTtcbiAgICAgKiAvLyBTdGFydHMgYSB0cmFuc2l0aW9uIHRvICdmb28nIHdpdGggcGFyYW1zOiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByb3V0ZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgbWF0Y2ggYnkgdHJhbnNpdGlvbmluZyB0byBtYXRjaGVkIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpcnN0IGNoZWNrcyBpZiB0aGUgcm91dGVyIHNob3VsZCBzdGFydCBhIG5ldyB0cmFuc2l0aW9uLlxuICAgICAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIGlzIG5vdCByZXF1aXJlZCBpZiB0aGUgY3VycmVudCBzdGF0ZSdzIFVSTFxuICAgICAgICAgKiBhbmQgdGhlIG5ldyBVUkwgYXJlIGFscmVhZHkgaWRlbnRpY2FsXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IHJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgaWYgKCRzdGF0ZS5ocmVmKHN0YXRlLCBtYXRjaCkgIT09ICRzdGF0ZS5ocmVmKGdsb2JhbHMuY3VycmVudCwgZ2xvYmFscy5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgbWF0Y2gsIHsgaW5oZXJpdDogdHJ1ZSwgc291cmNlOiBcInVybFwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGV0YWlscyA9IHsgc3RhdGU6IHN0YXRlLCB0eXBlOiBcIlNUQVRFXCIgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh0aGlzLmZyb21VcmxNYXRjaGVyKHN0YXRlLnVybCwgaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aDpcbiAgICAgKlxuICAgICAqIC0gcmVnZXhwIG1hdGNoIGFycmF5IChmcm9tIGByZWdleHBgKVxuICAgICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcbiAgICAgKiAtIHJvdXRlcjogdGhlIHJvdXRlciBvYmplY3QgKFtbVUlSb3V0ZXJdXSlcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tUmVnRXhwKC9eXFwvZm9vXFwvKGJhcnxiYXopJC8sIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaFsxXSlcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvYmFyJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBzdHJpbmdcbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIHN0cmluZywgdGhlIHVybCBpcyAqcmVwbGFjZWQgYnkgdGhlIHN0cmluZyogd2hlbiB0aGUgUnVsZSBpcyBpbnZva2VkLlxuICAgICAqIFRoZSBzdHJpbmcgaXMgZmlyc3QgaW50ZXJwb2xhdGVkIHVzaW5nIGBzdHJpbmcucmVwbGFjZSgpYCBzdHlsZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgXCIvaG9tZS8kMVwiKVxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vYmFyJyk7IC8vIHJlc3VsdHMgaW4gWyAnL2Zvby9iYXInLCAnYmFyJyBdXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXG4gICAgICogYGBgXG4gICAgICovXG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmZyb21SZWdFeHAgPSBmdW5jdGlvbiAocmVnZXhwLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChyZWdleHAuZ2xvYmFsIHx8IHJlZ2V4cC5zdGlja3kpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5XCIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaGFuZGxlciBpcyBhIHN0cmluZywgdGhlIHVybCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcuXG4gICAgICAgICAqIElmIHRoZSBzdHJpbmcgaGFzIGFueSBTdHJpbmcucmVwbGFjZSgpIHN0eWxlIHZhcmlhYmxlcyBpbiBpdCAobGlrZSBgJDJgKSxcbiAgICAgICAgICogdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjYXB0dXJlcyBmcm9tIFtbbWF0Y2hdXVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZGlyZWN0VXJsVG8gPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvICQxICQyLCBldGMgdXNpbmcgYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnJlcGxhY2UoL1xcJChcXCR8XFxkezEsMn0pLywgZnVuY3Rpb24gKG0sIHdoYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbd2hhdCA9PT0gJyQnID8gMCA6IE51bWJlcih3aGF0KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpID8gcmVkaXJlY3RVcmxUbyA6IGhhbmRsZXI7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleHAuZXhlYyh1cmwucGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXRhaWxzID0geyByZWdleHA6IHJlZ2V4cCwgdHlwZTogXCJSRUdFWFBcIiB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgX2hhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIHJldHVybiBVcmxSdWxlRmFjdG9yeTtcbn0oKSk7XG5VcmxSdWxlRmFjdG9yeS5pc1VybFJ1bGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBbJ3R5cGUnLCAnbWF0Y2gnLCAnaGFuZGxlciddLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqW2tleV0pOyB9KTtcbn07XG5leHBvcnRzLlVybFJ1bGVGYWN0b3J5ID0gVXJsUnVsZUZhY3Rvcnk7XG4vKipcbiAqIEEgYmFzZSBydWxlIHdoaWNoIGNhbGxzIGBtYXRjaGBcbiAqXG4gKiBUaGUgdmFsdWUgZnJvbSB0aGUgYG1hdGNoYCBmdW5jdGlvbiBpcyBwYXNzZWQgdGhyb3VnaCB0byB0aGUgYGhhbmRsZXJgLlxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBCYXNlVXJsUnVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVVybFJ1bGUobWF0Y2gsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIlJBV1wiO1xuICAgICAgICB0aGlzLm1hdGNoUHJpb3JpdHkgPSBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIDAgLSBfdGhpcy4kaWQ7IH07XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXIgfHwgY29tbW9uXzEuaWRlbnRpdHk7XG4gICAgfVxuICAgIHJldHVybiBCYXNlVXJsUnVsZTtcbn0oKSk7XG5leHBvcnRzLkJhc2VVcmxSdWxlID0gQmFzZVVybFJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxSdWxlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/urlRule.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlService.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlService.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @coreapi\n * @module url\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"initial\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxTZXJ2aWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsU2VydmljZS5qcz9kZWI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIG1ha2VTdHViID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiAoYWNjW2tleV0gPSBjb3Jlc2VydmljZXNfMS5ub3RJbXBsZW1lbnRlZChrZXkpLCBhY2MpOyB9LCB7IGRpc3Bvc2U6IGNvbW1vbl8xLm5vb3AgfSk7XG59O1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uU2VydmljZXNGbnMgPSBbXCJ1cmxcIiwgXCJwYXRoXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCBcIm9uQ2hhbmdlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uQ29uZmlnRm5zID0gW1wicG9ydFwiLCBcInByb3RvY29sXCIsIFwiaG9zdFwiLCBcImJhc2VIcmVmXCIsIFwiaHRtbDVNb2RlXCIsIFwiaGFzaFByZWZpeFwiXTtcbi8qKiBAaGlkZGVuICovIHZhciB1bWZGbnMgPSBbXCJ0eXBlXCIsIFwiY2FzZUluc2Vuc2l0aXZlXCIsIFwic3RyaWN0TW9kZVwiLCBcImRlZmF1bHRTcXVhc2hQb2xpY3lcIl07XG4vKiogQGhpZGRlbiAqLyB2YXIgcnVsZXNGbnMgPSBbXCJzb3J0XCIsIFwid2hlblwiLCBcImluaXRpYWxcIiwgXCJvdGhlcndpc2VcIiwgXCJydWxlc1wiLCBcInJ1bGVcIiwgXCJyZW1vdmVSdWxlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIHN5bmNGbnMgPSBbXCJkZWZlckludGVyY2VwdFwiLCBcImxpc3RlblwiLCBcInN5bmNcIiwgXCJtYXRjaFwiXTtcbi8qKlxuICogQVBJIGZvciBVUkwgbWFuYWdlbWVudFxuICovXG52YXIgVXJsU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBVcmxTZXJ2aWNlKHJvdXRlciwgbGF0ZUJpbmQpIHtcbiAgICAgICAgaWYgKGxhdGVCaW5kID09PSB2b2lkIDApIHsgbGF0ZUJpbmQgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnJ1bGVzID0ge307XG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgICAgIC8vIHByb3h5IGZ1bmN0aW9uIGNhbGxzIGZyb20gVXJsU2VydmljZSB0byB0aGUgTG9jYXRpb25TZXJ2aWNlL0xvY2F0aW9uQ29uZmlnXG4gICAgICAgIHZhciBsb2NhdGlvblNlcnZpY2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmxvY2F0aW9uU2VydmljZTsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMobG9jYXRpb25TZXJ2aWNlcywgdGhpcywgbG9jYXRpb25TZXJ2aWNlcywgbG9jYXRpb25TZXJ2aWNlc0ZucywgbGF0ZUJpbmQpO1xuICAgICAgICB2YXIgbG9jYXRpb25Db25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubG9jYXRpb25Db25maWc7IH07XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGxvY2F0aW9uQ29uZmlnLCB0aGlzLmNvbmZpZywgbG9jYXRpb25Db25maWcsIGxvY2F0aW9uQ29uZmlnRm5zLCBsYXRlQmluZCk7XG4gICAgICAgIHZhciB1bWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudXJsTWF0Y2hlckZhY3Rvcnk7IH07XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKHVtZiwgdGhpcy5jb25maWcsIHVtZiwgdW1mRm5zKTtcbiAgICAgICAgdmFyIHVybFJvdXRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci51cmxSb3V0ZXI7IH07XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKHVybFJvdXRlciwgdGhpcy5ydWxlcywgdXJsUm91dGVyLCBydWxlc0Zucyk7XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKHVybFJvdXRlciwgdGhpcywgdXJsUm91dGVyLCBzeW5jRm5zKTtcbiAgICB9XG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKG5ld3VybCwgcmVwbGFjZSwgc3RhdGUpIHsgcmV0dXJuOyB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGFydHNcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGN1cnJlbnQgVVJMIGNvbXBvbmVudHMgYXMgYSBbW1VybFBhcnRzXV0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXJsIHBhcnRzXG4gICAgICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUucGFydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHRoaXMucGF0aCgpLCBzZWFyY2g6IHRoaXMuc2VhcmNoKCksIGhhc2g6IHRoaXMuaGFzaCgpIH07XG4gICAgfTtcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoZW5hYmxlZCkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmxQYXJ0cykgeyByZXR1cm47IH07XG4gICAgcmV0dXJuIFVybFNlcnZpY2U7XG59KCkpO1xuLyoqIEBoaWRkZW4gKi9cblVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YiA9IG1ha2VTdHViKGxvY2F0aW9uU2VydmljZXNGbnMpO1xuLyoqIEBoaWRkZW4gKi9cblVybFNlcnZpY2UubG9jYXRpb25Db25maWdTdHViID0gbWFrZVN0dWIobG9jYXRpb25Db25maWdGbnMpO1xuZXhwb3J0cy5VcmxTZXJ2aWNlID0gVXJsU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFNlcnZpY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/url/urlService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla.js":
/*!****************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(__webpack_require__(/*! ./vanilla/index */ \"./node_modules/@uirouter/core/lib/vanilla/index.js\"));\n//# sourceMappingURL=vanilla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEuanM/ZDViZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vdmFuaWxsYS9pbmRleFwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YW5pbGxhLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js":
/*!************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @internalapi\n * @module vanilla\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@uirouter/core/lib/vanilla/utils.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9iYXNlTG9jYXRpb25TZXJ2aWNlLmpzPzFlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xuLyoqIEEgYmFzZSBgTG9jYXRpb25TZXJ2aWNlc2AgKi9cbnZhciBCYXNlTG9jYXRpb25TZXJ2aWNlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUxvY2F0aW9uU2VydmljZXMocm91dGVyLCBmaXJlQWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5maXJlQWZ0ZXJVcGRhdGUgPSBmaXJlQWZ0ZXJVcGRhdGU7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoZXZ0KTsgfSk7IH07XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkuaGFzaDsgfTtcbiAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLnBhdGg7IH07XG4gICAgICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRQYXJhbXModXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLnNlYXJjaCk7IH07XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gd2luZG93ICYmIHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IHdpbmRvdyAmJiB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gICAgQmFzZUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh1cmwpICYmIHVybCAhPT0gdGhpcy5fZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldChudWxsLCBudWxsLCB1cmwsIHJlcGxhY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyZUFmdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dF8xID0gY29tbW9uXzEuZXh0ZW5kKG5ldyBFdmVudChcImxvY2F0aW9uY2hhbmdlXCIpLCB7IHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoZXZ0XzEpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHNfMS5idWlsZFVybCh0aGlzKTtcbiAgICB9O1xuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9saXN0ZW5lcnMsIGNiKTsgfTtcbiAgICB9O1xuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBjb21tb25fMS5kZXJlZ0FsbCh0aGlzLl9saXN0ZW5lcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VMb2NhdGlvblNlcnZpY2VzO1xufSgpKTtcbmV4cG9ydHMuQmFzZUxvY2F0aW9uU2VydmljZXMgPSBCYXNlTG9jYXRpb25TZXJ2aWNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VMb2NhdGlvblNlcnZpY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === 'https' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, '');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYnJvd3NlckxvY2F0aW9uQ29uZmlnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcz8zMWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG4vKiogQSBgTG9jYXRpb25Db25maWdgIHRoYXQgZGVsZWdhdGVzIHRvIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBvYmplY3QgKi9cbnZhciBCcm93c2VyTG9jYXRpb25Db25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJMb2NhdGlvbkNvbmZpZyhyb3V0ZXIsIF9pc0h0bWw1KSB7XG4gICAgICAgIGlmIChfaXNIdG1sNSA9PT0gdm9pZCAwKSB7IF9pc0h0bWw1ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5faXNIdG1sNSA9IF9pc0h0bWw1O1xuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faGFzaFByZWZpeCA9IFwiXCI7XG4gICAgfVxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobG9jYXRpb24ucG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2woKSA9PT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoLzovZywgJycpO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5ob3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdDtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNIdG1sNTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXdwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQobmV3cHJlZml4KSA/IHRoaXMuX2hhc2hQcmVmaXggPSBuZXdwcmVmaXggOiB0aGlzLl9oYXNoUHJlZml4O1xuICAgIH07XG4gICAgO1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuYmFzZUhyZWYgPSBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChocmVmKSA/IHRoaXMuX2Jhc2VIcmVmID0gaHJlZiA6IHRoaXMuX2Jhc2VIcmVmIHx8IHRoaXMuYXBwbHlEb2N1bWVudEJhc2VIcmVmKCk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmFwcGx5RG9jdW1lbnRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2VUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUhyZWYgPSBiYXNlVGFncy5sZW5ndGggPyBiYXNlVGFnc1swXS5ocmVmLnN1YnN0cihsb2NhdGlvbi5vcmlnaW4ubGVuZ3RoKSA6IFwiXCI7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyA9IEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js":
/*!************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@uirouter/core/lib/vanilla/utils.js\");\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaGFzaExvY2F0aW9uU2VydmljZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9oYXNoTG9jYXRpb25TZXJ2aWNlLmpzP2MyZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCB1c2VzIHRoZSBicm93c2VyIGhhc2ggXCIjXCIgdG8gZ2V0L3NldCB0aGUgY3VycmVudCBsb2NhdGlvbiAqL1xudmFyIEhhc2hMb2NhdGlvblNlcnZpY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXNoTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhhc2hMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgZmFsc2UpIHx8IHRoaXM7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgX3RoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSGFzaExvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEudHJpbUhhc2hWYWwodGhpcy5fbG9jYXRpb24uaGFzaCk7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCByb3V0ZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBIYXNoTG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuSGFzaExvY2F0aW9uU2VydmljZSA9IEhhc2hMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoTG9jYXRpb25TZXJ2aWNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./q */ \"./node_modules/@uirouter/core/lib/vanilla/q.js\"));\n__export(__webpack_require__(/*! ./injector */ \"./node_modules/@uirouter/core/lib/vanilla/injector.js\"));\n__export(__webpack_require__(/*! ./baseLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js\"));\n__export(__webpack_require__(/*! ./hashLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js\"));\n__export(__webpack_require__(/*! ./memoryLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js\"));\n__export(__webpack_require__(/*! ./pushStateLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js\"));\n__export(__webpack_require__(/*! ./memoryLocationConfig */ \"./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js\"));\n__export(__webpack_require__(/*! ./browserLocationConfig */ \"./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js\"));\n__export(__webpack_require__(/*! ./utils */ \"./node_modules/@uirouter/core/lib/vanilla/utils.js\"));\n__export(__webpack_require__(/*! ./plugins */ \"./node_modules/@uirouter/core/lib/vanilla/plugins.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5kZXguanM/MWY4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9xXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2luamVjdG9yXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGFzaExvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21lbW9yeUxvY2F0aW9uQ29uZmlnXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wbHVnaW5zXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/injector.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/injector.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(/*! ../common/index */ \"./node_modules/@uirouter/core/lib/common/index.js\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=injector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanM/MzFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG4vLyBnbG9iYWxseSBhdmFpbGFibGUgaW5qZWN0YWJsZXNcbnZhciBnbG9iYWxzID0ge307XG52YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG52YXIgQVJHVU1FTlRfTkFNRVMgPSAvKFteXFxzLF0rKS9nO1xuLyoqXG4gKiBBIGJhc2ljIGFuZ3VsYXIxLWxpa2UgaW5qZWN0b3IgYXBpXG4gKlxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcbiAqIFthbmd1bGFyIDEgZGVwZW5kZW5jeSBpbmplY3Rvcl0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL2F1dG8vc2VydmljZS8kaW5qZWN0b3IpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBvYmplY3QgcHJvdmlkZXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdsb2JhbGx5IHNjb3BlZCBkZXBlbmRlbmN5IGluamVjdGlvbiBzeXN0ZW0uXG4gKiBJdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIERJIGFwcHJvYWNoZXM6XG4gKlxuICogIyMjIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xuICpcbiAqIEEgZnVuY3Rpb24ncyBgLnRvU3RyaW5nKClgIGlzIGNhbGxlZCwgYW5kIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlIHBhcnNlZC5cbiAqIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlbid0IFwibWFuZ2xlZFwiIGJ5IGEgbWluaWZpZXIgc3VjaCBhcyBVZ2xpZnlKUy5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihGb29TZXJ2aWNlLCBCYXJTZXJ2aWNlKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgRnVuY3Rpb24gYW5ub3RhdGlvblxuICpcbiAqIEEgZnVuY3Rpb24gbWF5IGJlIGFubm90YXRlZCB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY3kgbmFtZXMgYXMgdGhlIGAkaW5qZWN0YCBwcm9wZXJ0eS5cbiAqXG4gKiBgYGBqc1xuICogaW5qZWN0ZWRGdW5jdGlvbi4kaW5qZWN0ID0gWyAnRm9vU2VydmljZScsICdCYXJTZXJ2aWNlJyBdO1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBBcnJheSBub3RhdGlvblxuICpcbiAqIEFuIGFycmF5IHByb3ZpZGVzIHRoZSBuYW1lcyBvZiB0aGUgZGVwZW5kZW5jaWVzIHRvIGluamVjdCAoYXMgc3RyaW5ncykuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogYGBganNcbiAqIFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScsIGZ1bmN0aW9uIChmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiBAdHlwZSB7JEluamVjdG9yTGlrZX1cbiAqL1xuZXhwb3J0cy4kaW5qZWN0b3IgPSB7XG4gICAgLyoqIEdldHMgYW4gb2JqZWN0IGZyb20gREkgYmFzZWQgb24gYSBzdHJpbmcgdG9rZW4gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnbG9iYWxzW25hbWVdOyB9LFxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IG5hbWVkIGBuYW1lYCBleGlzdHMgaW4gZ2xvYmFsIERJICovXG4gICAgaGFzOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZXhwb3J0cy4kaW5qZWN0b3IuZ2V0KG5hbWUpICE9IG51bGw7IH0sXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gdGhlIGZ1bmN0aW9uIHRvIGluamVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBmdW5jdGlvbidzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogQHBhcmFtIGxvY2FscyBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIERJIHRva2VucyBhbmQgdmFsdWVzLCBzdWNoIGFzIGB7IHNvbWVUb2tlbjogeyBmb286IDEgfSB9YFxuICAgICAqL1xuICAgIGludm9rZTogZnVuY3Rpb24gKGZuLCBjb250ZXh0LCBsb2NhbHMpIHtcbiAgICAgICAgdmFyIGFsbCA9IGluZGV4XzEuZXh0ZW5kKHt9LCBnbG9iYWxzLCBsb2NhbHMgfHwge30pO1xuICAgICAgICB2YXIgcGFyYW1zID0gZXhwb3J0cy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4pO1xuICAgICAgICB2YXIgZW5zdXJlRXhpc3QgPSBpbmRleF8xLmFzc2VydFByZWRpY2F0ZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhbGwuaGFzT3duUHJvcGVydHkoa2V5KTsgfSwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gXCJESSBjYW4ndCBmaW5kIGluamVjdGFibGU6ICdcIiArIGtleSArIFwiJ1wiOyB9KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBwYXJhbXMuZmlsdGVyKGVuc3VyZUV4aXN0KS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFsbFt4XTsgfSk7XG4gICAgICAgIGlmIChpbmRleF8xLmlzRnVuY3Rpb24oZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZm4uc2xpY2UoLTEpWzBdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uJ3MgZGVwZW5kZW5jaWVzXG4gICAgICpcbiAgICAgKiBBbmFseXplcyBhIGZ1bmN0aW9uIChvciBhcnJheSkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgREkgdG9rZW5zIHRoYXQgdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYHN0cmluZ2BzXG4gICAgICovXG4gICAgYW5ub3RhdGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAoIWluZGV4XzEuaXNJbmplY3RhYmxlKGZuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uOiBcIiArIGZuKTtcbiAgICAgICAgaWYgKGZuICYmIGZuLiRpbmplY3QpXG4gICAgICAgICAgICByZXR1cm4gZm4uJGluamVjdDtcbiAgICAgICAgaWYgKGluZGV4XzEuaXNBcnJheShmbikpXG4gICAgICAgICAgICByZXR1cm4gZm4uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgZm5TdHIgPSBmbi50b1N0cmluZygpLnJlcGxhY2UoU1RSSVBfQ09NTUVOVFMsICcnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goQVJHVU1FTlRfTkFNRVMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3Rvci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/injector.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanM/YzMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgbW9jayB0aGF0IGdldHMvc2V0cyBhbGwgY29uZmlnIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xudmFyIE1lbW9yeUxvY2F0aW9uQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW1vcnlMb2NhdGlvbkNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSAnJztcbiAgICAgICAgdGhpcy5fcG9ydCA9IDgwO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IFwiaHR0cFwiO1xuICAgICAgICB0aGlzLl9ob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgdGhpcy5faGFzaFByZWZpeCA9IFwiXCI7XG4gICAgICAgIHRoaXMucG9ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wb3J0OyB9O1xuICAgICAgICB0aGlzLnByb3RvY29sID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3Byb3RvY29sOyB9O1xuICAgICAgICB0aGlzLmhvc3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faG9zdDsgfTtcbiAgICAgICAgdGhpcy5iYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9iYXNlSHJlZjsgfTtcbiAgICAgICAgdGhpcy5odG1sNU1vZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgdGhpcy5oYXNoUHJlZml4ID0gZnVuY3Rpb24gKG5ld3ZhbCkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChuZXd2YWwpID8gX3RoaXMuX2hhc2hQcmVmaXggPSBuZXd2YWwgOiBfdGhpcy5faGFzaFByZWZpeDsgfTtcbiAgICAgICAgdGhpcy5kaXNwb3NlID0gY29tbW9uXzEubm9vcDtcbiAgICB9XG4gICAgcmV0dXJuIE1lbW9yeUxvY2F0aW9uQ29uZmlnO1xufSgpKTtcbmV4cG9ydHMuTWVtb3J5TG9jYXRpb25Db25maWcgPSBNZW1vcnlMb2NhdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeUxvY2F0aW9uQ29uZmlnLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uU2VydmljZS5qcz9iODU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG52YXIgTWVtb3J5TG9jYXRpb25TZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVtb3J5TG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbW9yeUxvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgdHJ1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH07XG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB9O1xuICAgIHJldHVybiBNZW1vcnlMb2NhdGlvblNlcnZpY2U7XG59KGJhc2VMb2NhdGlvblNlcnZpY2VfMS5CYXNlTG9jYXRpb25TZXJ2aWNlcykpO1xuZXhwb3J0cy5NZW1vcnlMb2NhdGlvblNlcnZpY2UgPSBNZW1vcnlMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnlMb2NhdGlvblNlcnZpY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/plugins.js":
/*!************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/plugins.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = __webpack_require__(/*! ./browserLocationConfig */ \"./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js\");\nvar hashLocationService_1 = __webpack_require__(/*! ./hashLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@uirouter/core/lib/vanilla/utils.js\");\nvar pushStateLocationService_1 = __webpack_require__(/*! ./pushStateLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js\");\nvar memoryLocationService_1 = __webpack_require__(/*! ./memoryLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js\");\nvar memoryLocationConfig_1 = __webpack_require__(/*! ./memoryLocationConfig */ \"./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js\");\nvar injector_1 = __webpack_require__(/*! ./injector */ \"./node_modules/@uirouter/core/lib/vanilla/injector.js\");\nvar q_1 = __webpack_require__(/*! ./q */ \"./node_modules/@uirouter/core/lib/vanilla/q.js\");\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ \"./node_modules/@uirouter/core/lib/common/coreservices.js\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = injector_1.$injector;\n    coreservices_1.services.$q = q_1.$q;\n    return { name: \"vanilla.services\", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcGx1Z2lucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wbHVnaW5zLmpzPzJiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xID0gcmVxdWlyZShcIi4vYnJvd3NlckxvY2F0aW9uQ29uZmlnXCIpO1xudmFyIGhhc2hMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIG1lbW9yeUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIG1lbW9yeUxvY2F0aW9uQ29uZmlnXzEgPSByZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKTtcbnZhciBpbmplY3Rvcl8xID0gcmVxdWlyZShcIi4vaW5qZWN0b3JcIik7XG52YXIgcV8xID0gcmVxdWlyZShcIi4vcVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuZnVuY3Rpb24gc2VydmljZXNQbHVnaW4ocm91dGVyKSB7XG4gICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yID0gaW5qZWN0b3JfMS4kaW5qZWN0b3I7XG4gICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEgPSBxXzEuJHE7XG4gICAgcmV0dXJuIHsgbmFtZTogXCJ2YW5pbGxhLnNlcnZpY2VzXCIsICRxOiBxXzEuJHEsICRpbmplY3RvcjogaW5qZWN0b3JfMS4kaW5qZWN0b3IsIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfTtcbn1cbmV4cG9ydHMuc2VydmljZXNQbHVnaW4gPSBzZXJ2aWNlc1BsdWdpbjtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdXNlcyB0aGUgYnJvd3NlciBoYXNoIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbmV4cG9ydHMuaGFzaExvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoJ3ZhbmlsbGEuaGFzaEJhbmdMb2NhdGlvbicsIGZhbHNlLCBoYXNoTG9jYXRpb25TZXJ2aWNlXzEuSGFzaExvY2F0aW9uU2VydmljZSwgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEuQnJvd3NlckxvY2F0aW9uQ29uZmlnKTtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpcyAqL1xuZXhwb3J0cy5wdXNoU3RhdGVMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KFwidmFuaWxsYS5wdXNoU3RhdGVMb2NhdGlvblwiLCB0cnVlLCBwdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VfMS5QdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyk7XG4vKiogQSBgVUlSb3V0ZXJQbHVnaW5gIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xuZXhwb3J0cy5tZW1vcnlMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KFwidmFuaWxsYS5tZW1vcnlMb2NhdGlvblwiLCBmYWxzZSwgbWVtb3J5TG9jYXRpb25TZXJ2aWNlXzEuTWVtb3J5TG9jYXRpb25TZXJ2aWNlLCBtZW1vcnlMb2NhdGlvbkNvbmZpZ18xLk1lbW9yeUxvY2F0aW9uQ29uZmlnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/plugins.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@uirouter/core/lib/vanilla/utils.js\");\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ \"./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcz8xODg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XG4vKipcbiAqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHVzaW5nIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBhbmQgYGhpc3RvcnlgIGFwaXNcbiAqXG4gKiBVc2VzIGBoaXN0b3J5LnB1c2hTdGF0ZWAgYW5kIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZWBcbiAqL1xudmFyIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgdHJ1ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NvbmZpZyA9IHJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBfdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICA7XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9sb2NhdGlvbiwgcGF0aG5hbWUgPSBfYS5wYXRobmFtZSwgaGFzaCA9IF9hLmhhc2gsIHNlYXJjaCA9IF9hLnNlYXJjaDtcbiAgICAgICAgc2VhcmNoID0gdXRpbHNfMS5zcGxpdFF1ZXJ5KHNlYXJjaClbMV07IC8vIHN0cmlwID8gaWYgZm91bmRcbiAgICAgICAgaGFzaCA9IHV0aWxzXzEuc3BsaXRIYXNoKGhhc2gpWzFdOyAvLyBzdHJpcCAjIGlmIGZvdW5kXG4gICAgICAgIHJldHVybiBwYXRobmFtZSArIChzZWFyY2ggPyBcIj9cIiArIHNlYXJjaCA6IFwiXCIpICsgKGhhc2ggPyBcIiRcIiArIHNlYXJjaCA6IFwiXCIpO1xuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9jb25maWcgPSBfYS5fY29uZmlnLCBfaGlzdG9yeSA9IF9hLl9oaXN0b3J5O1xuICAgICAgICB2YXIgZnVsbFVybCA9IF9jb25maWcuYmFzZUhyZWYoKSArIHVybDtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIF9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgZnVsbFVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcywgcm91dGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlID0gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/q.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/q.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(/*! ../common/index */ \"./node_modules/@uirouter/core/lib/common/index.js\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=q.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9xLmpzP2JhZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2luZGV4XCIpO1xuLyoqXG4gKiBBbiBhbmd1bGFyMS1saWtlIHByb21pc2UgYXBpXG4gKlxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcbiAqIFthbmd1bGFyIDEgcHJvbWlzZSBhcGldKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy9zZXJ2aWNlLyRxKVxuICpcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cbiAqIEhvd2V2ZXIsIHNvbWUgb2YgdGhlIGBAdWlyb3V0ZXIvY29yZWAgY29kZSB1c2VzIHRoZXNlIG5nMSBzdHlsZSBBUElzIHRvIHN1cHBvcnQgbmcxIHN0eWxlIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgQVBJIHByb3ZpZGVzIG5hdGl2ZSBFUzYgcHJvbWlzZSBzdXBwb3J0IHdyYXBwZWQgYXMgYSAkcS1saWtlIEFQSS5cbiAqIEludGVybmFsbHksIFVJLVJvdXRlciB1c2VzIHRoaXMgJHEgb2JqZWN0IHRvIHBlcmZvcm0gcHJvbWlzZSBvcGVyYXRpb25zLlxuICogVGhlIGBhbmd1bGFyLXVpLXJvdXRlcmAgKHVpLXJvdXRlciBmb3IgYW5ndWxhciAxKSB1c2VzIHRoZSAkcSBBUEkgcHJvdmlkZWQgYnkgYW5ndWxhci5cbiAqXG4gKiAkcS1saWtlIHByb21pc2UgYXBpXG4gKi9cbmV4cG9ydHMuJHEgPSB7XG4gICAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgKi9cbiAgICB3aGVuOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJldHVybiByZXNvbHZlKHZhbCk7IH0pOyB9LFxuICAgIC8qKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBwcm9taXNlIHJlamVjdGlvbiAqL1xuICAgIHJlamVjdDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZWplY3QodmFsKTsgfSk7IH0sXG4gICAgLyoqIEByZXR1cm5zIGEgZGVmZXJyZWQgb2JqZWN0LCB3aGljaCBoYXMgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMgKi9cbiAgICBkZWZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB7fTtcbiAgICAgICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH0sXG4gICAgLyoqIExpa2UgUHJvbWlzZS5hbGwoKSwgYnV0IGFsc28gc3VwcG9ydHMgb2JqZWN0IGtleS9wcm9taXNlIG5vdGF0aW9uIGxpa2UgJHEgKi9cbiAgICBhbGw6IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBpZiAoaW5kZXhfMS5pc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhfMS5pc09iamVjdChwcm9taXNlcykpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcHJvbWlzZXMgbWFwIHRvIHByb21pc2VzIGFycmF5LlxuICAgICAgICAgICAgLy8gV2hlbiBlYWNoIHByb21pc2UgcmVzb2x2ZXMsIG1hcCBpdCB0byBhIHR1cGxlIHsga2V5OiBrZXksIHZhbDogdmFsIH1cbiAgICAgICAgICAgIHZhciBjaGFpbiA9IE9iamVjdC5rZXlzKHByb21pc2VzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJvbWlzZXNba2V5XS50aGVuKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IHZhbCB9KTsgfSk7IH0pO1xuICAgICAgICAgICAgLy8gVGhlbiB3YWl0IGZvciBhbGwgcHJvbWlzZXMgdG8gcmVzb2x2ZSwgYW5kIGNvbnZlcnQgdGhlbSBiYWNrIHRvIGFuIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuJHEuYWxsKGNoYWluKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0dXBsZSkgeyBhY2NbdHVwbGUua2V5XSA9IHR1cGxlLnZhbDsgcmV0dXJuIGFjYzsgfSwge30pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/q.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/utils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(/*! ../common/index */ \"./node_modules/@uirouter/core/lib/common/index.js\");\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanM/NWYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBiZWZvcmVBZnRlclN1YnN0ciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBbXCJcIiwgXCJcIl07XG4gICAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKGNoYXIpO1xuICAgIGlmIChpZHggPT09IC0xKVxuICAgICAgICByZXR1cm4gW3N0ciwgXCJcIl07XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyKDAsIGlkeCksIHN0ci5zdWJzdHIoaWR4ICsgMSldO1xufTsgfTtcbmV4cG9ydHMuc3BsaXRIYXNoID0gYmVmb3JlQWZ0ZXJTdWJzdHIoXCIjXCIpO1xuZXhwb3J0cy5zcGxpdFF1ZXJ5ID0gYmVmb3JlQWZ0ZXJTdWJzdHIoXCI/XCIpO1xuZXhwb3J0cy5zcGxpdEVxdWFsID0gYmVmb3JlQWZ0ZXJTdWJzdHIoXCI9XCIpO1xuZXhwb3J0cy50cmltSGFzaFZhbCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC9eIy8sIFwiXCIpIDogXCJcIjsgfTtcbmV4cG9ydHMua2V5VmFsc1RvT2JqZWN0UiA9IGZ1bmN0aW9uIChhY2N1bSwgX2EpIHtcbiAgICB2YXIga2V5ID0gX2FbMF0sIHZhbCA9IF9hWzFdO1xuICAgIGlmICghYWNjdW0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBhY2N1bVtrZXldID0gdmFsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleF8xLmlzQXJyYXkoYWNjdW1ba2V5XSkpIHtcbiAgICAgICAgYWNjdW1ba2V5XS5wdXNoKHZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY2N1bVtrZXldID0gW2FjY3VtW2tleV0sIHZhbF07XG4gICAgfVxuICAgIHJldHVybiBhY2N1bTtcbn07XG5leHBvcnRzLmdldFBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeVN0cmluZykge1xuICAgIHJldHVybiBxdWVyeVN0cmluZy5zcGxpdChcIiZcIikuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5tYXAoZXhwb3J0cy5zcGxpdEVxdWFsKS5yZWR1Y2UoZXhwb3J0cy5rZXlWYWxzVG9PYmplY3RSLCB7fSk7XG59O1xuZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gICAgdmFyIG9yRW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCB8fCBcIlwiOyB9O1xuICAgIHZhciBfYSA9IGV4cG9ydHMuc3BsaXRIYXNoKHVybCkubWFwKG9yRW1wdHlTdHJpbmcpLCBiZWZvcmVoYXNoID0gX2FbMF0sIGhhc2ggPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBleHBvcnRzLnNwbGl0UXVlcnkoYmVmb3JlaGFzaCkubWFwKG9yRW1wdHlTdHJpbmcpLCBwYXRoID0gX2JbMF0sIHNlYXJjaCA9IF9iWzFdO1xuICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIHNlYXJjaDogc2VhcmNoLCBoYXNoOiBoYXNoLCB1cmw6IHVybCB9O1xufVxuZXhwb3J0cy5wYXJzZVVybCA9IHBhcnNlVXJsO1xuZXhwb3J0cy5idWlsZFVybCA9IGZ1bmN0aW9uIChsb2MpIHtcbiAgICB2YXIgcGF0aCA9IGxvYy5wYXRoKCk7XG4gICAgdmFyIHNlYXJjaE9iamVjdCA9IGxvYy5zZWFyY2goKTtcbiAgICB2YXIgaGFzaCA9IGxvYy5oYXNoKCk7XG4gICAgdmFyIHNlYXJjaCA9IE9iamVjdC5rZXlzKHNlYXJjaE9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gc2VhcmNoT2JqZWN0W2tleV07XG4gICAgICAgIHZhciB2YWxzID0gaW5kZXhfMS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcbiAgICAgICAgcmV0dXJuIHZhbHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGtleSArIFwiPVwiICsgdmFsOyB9KTtcbiAgICB9KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiBwYXRoICsgKHNlYXJjaCA/IFwiP1wiICsgc2VhcmNoIDogXCJcIikgKyAoaGFzaCA/IFwiI1wiICsgaGFzaCA6IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGxvY2F0aW9uUGx1Z2luRmFjdG9yeShuYW1lLCBpc0h0bWw1LCBzZXJ2aWNlQ2xhc3MsIGNvbmZpZ3VyYXRpb25DbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uU2VydmljZSA9IG5ldyBzZXJ2aWNlQ2xhc3Mocm91dGVyKTtcbiAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSByb3V0ZXIubG9jYXRpb25Db25maWcgPSBuZXcgY29uZmlndXJhdGlvbkNsYXNzKHJvdXRlciwgaXNIdG1sNSk7XG4gICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2Uocm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIuZGlzcG9zZShzZXJ2aWNlKTtcbiAgICAgICAgICAgIHJvdXRlci5kaXNwb3NlKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHNlcnZpY2U6IHNlcnZpY2UsIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sIGRpc3Bvc2U6IGRpc3Bvc2UgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5sb2NhdGlvblBsdWdpbkZhY3RvcnkgPSBsb2NhdGlvblBsdWdpbkZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/vanilla/utils.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/view/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/view/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./view */ \"./node_modules/@uirouter/core/lib/view/view.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvaW5kZXguanM/ZjBjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92aWV3XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/view/index.js\n");

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/view/view.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/view/view.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ \"./node_modules/@uirouter/core/lib/common/common.js\");\nvar hof_1 = __webpack_require__(/*! ../common/hof */ \"./node_modules/@uirouter/core/lib/common/hof.js\");\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ \"./node_modules/@uirouter/core/lib/common/predicates.js\");\nvar trace_1 = __webpack_require__(/*! ../common/trace */ \"./node_modules/@uirouter/core/lib/common/trace.js\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(\".\").length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy92aWV3LmpzP2QzZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHZpZXdcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xuLyoqXG4gKiBUaGUgVmlldyBzZXJ2aWNlXG4gKlxuICogVGhpcyBzZXJ2aWNlIHBhaXJzIGV4aXN0aW5nIGB1aS12aWV3YCBjb21wb25lbnRzICh3aGljaCBsaXZlIGluIHRoZSBET00pXG4gKiB3aXRoIHZpZXcgY29uZmlncyAoZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb24gb2JqZWN0czogW1tTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV0pLlxuICpcbiAqIC0gQWZ0ZXIgYSBzdWNjZXNzZnVsIFRyYW5zaXRpb24sIHRoZSB2aWV3cyBmcm9tIHRoZSBuZXdseSBlbnRlcmVkIHN0YXRlcyBhcmUgYWN0aXZhdGVkIHZpYSBbW2FjdGl2YXRlVmlld0NvbmZpZ11dLlxuICogICBUaGUgdmlld3MgZnJvbSBleGl0ZWQgc3RhdGVzIGFyZSBkZWFjdGl2YXRlZCB2aWEgW1tkZWFjdGl2YXRlVmlld0NvbmZpZ11dLlxuICogICAoU2VlOiB0aGUgW1tyZWdpc3RlckFjdGl2YXRlVmlld3NdXSBUcmFuc2l0aW9uIEhvb2spXG4gKlxuICogLSBBcyBgdWktdmlld2AgY29tcG9uZW50cyBwb3AgaW4gYW5kIG91dCBvZiBleGlzdGVuY2UsIHRoZXkgcmVnaXN0ZXIgdGhlbXNlbHZlcyB1c2luZyBbW3JlZ2lzdGVyVUlWaWV3XV0uXG4gKlxuICogLSBXaGVuIHRoZSBbW3N5bmNdXSBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSByZWdpc3RlcmVkIGB1aS12aWV3YChzKSAoW1tBY3RpdmVVSVZpZXddXSlcbiAqIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIG1hdGNoaW5nIFtbVmlld0NvbmZpZ11dKHMpXG4gKlxuICovXG52YXIgVmlld1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl91aVZpZXdzID0gW107XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzID0gW107XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGx1Z2luYXBpID0ge1xuICAgICAgICAgICAgX3Jvb3RWaWV3Q29udGV4dDogdGhpcy5fcm9vdFZpZXdDb250ZXh0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfdmlld0NvbmZpZ0ZhY3Rvcnk6IHRoaXMuX3ZpZXdDb25maWdGYWN0b3J5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfcmVnaXN0ZXJlZFVJVmlld3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91aVZpZXdzOyB9LFxuICAgICAgICAgICAgX2FjdGl2ZVZpZXdDb25maWdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmlld0NvbmZpZ3M7IH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5fcm9vdFZpZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RDb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLl9yb290Q29udGV4dDtcbiAgICB9O1xuICAgIDtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuX3ZpZXdDb25maWdGYWN0b3J5ID0gZnVuY3Rpb24gKHZpZXdUeXBlLCBmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXNbdmlld1R5cGVdID0gZmFjdG9yeTtcbiAgICB9O1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHBhdGgsIGRlY2wpIHtcbiAgICAgICAgdmFyIGNmZ0ZhY3RvcnkgPSB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW2RlY2wuJHR5cGVdO1xuICAgICAgICBpZiAoIWNmZ0ZhY3RvcnkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3U2VydmljZTogTm8gdmlldyBjb25maWcgZmFjdG9yeSByZWdpc3RlcmVkIGZvciB0eXBlIFwiICsgZGVjbC4kdHlwZSk7XG4gICAgICAgIHZhciBjZmdzID0gY2ZnRmFjdG9yeShwYXRoLCBkZWNsKTtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0FycmF5KGNmZ3MpID8gY2ZncyA6IFtjZmdzXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIGEgVmlld0NvbmZpZy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgYSBgVmlld0NvbmZpZ2AuXG4gICAgICogQWZ0ZXIgY2FsbGluZyBbW3N5bmNdXSwgaXQgd2lsbCB1bi1wYWlyIGZyb20gYW55IGB1aS12aWV3YCB3aXRoIHdoaWNoIGl0IGlzIGN1cnJlbnRseSBwYWlyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld0NvbmZpZyBUaGUgVmlld0NvbmZpZyB2aWV3IHRvIGRlcmVnaXN0ZXIuXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmRlYWN0aXZhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoXCI8LSBSZW1vdmluZ1wiLCB2aWV3Q29uZmlnKTtcbiAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLl92aWV3Q29uZmlncywgdmlld0NvbmZpZyk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoXCItPiBSZWdpc3RlcmluZ1wiLCB2aWV3Q29uZmlnKTtcbiAgICAgICAgdGhpcy5fdmlld0NvbmZpZ3MucHVzaCh2aWV3Q29uZmlnKTtcbiAgICB9O1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdWlWaWV3c0J5RnFuID0gdGhpcy5fdWlWaWV3cy5tYXAoZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gW3Vpdi5mcW4sIHVpdl07IH0pLnJlZHVjZShjb21tb25fMS5hcHBseVBhaXJzLCB7fSk7XG4gICAgICAgIC8vIFJldHVybiBhIHdlaWdodGVkIGRlcHRoIHZhbHVlIGZvciBhIHVpVmlldy5cbiAgICAgICAgLy8gVGhlIGRlcHRoIGlzIHRoZSBuZXN0aW5nIGRlcHRoIG9mIHVpLXZpZXdzIChiYXNlZCBvbiBGUU47IHRpbWVzIDEwLDAwMClcbiAgICAgICAgLy8gcGx1cyB0aGUgZGVwdGggb2YgdGhlIHN0YXRlIHRoYXQgaXMgcG9wdWxhdGluZyB0aGUgdWlWaWV3XG4gICAgICAgIGZ1bmN0aW9uIHVpVmlld0RlcHRoKHVpVmlldykge1xuICAgICAgICAgICAgdmFyIHN0YXRlRGVwdGggPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0ICYmIGNvbnRleHQucGFyZW50ID8gc3RhdGVEZXB0aChjb250ZXh0LnBhcmVudCkgKyAxIDogMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKHVpVmlldy5mcW4uc3BsaXQoXCIuXCIpLmxlbmd0aCAqIDEwMDAwKSArIHN0YXRlRGVwdGgodWlWaWV3LmNyZWF0aW9uQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBWaWV3Q29uZmlnJ3MgY29udGV4dCdzIGRlcHRoIGluIHRoZSBjb250ZXh0IHRyZWUuXG4gICAgICAgIGZ1bmN0aW9uIHZpZXdDb25maWdEZXB0aChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29uZmlnLnZpZXdEZWNsLiRjb250ZXh0LCBjb3VudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKytjb3VudCAmJiBjb250ZXh0LnBhcmVudClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2l2ZW4gYSBkZXB0aCBmdW5jdGlvbiwgcmV0dXJucyBhIGNvbXBhcmUgZnVuY3Rpb24gd2hpY2ggY2FuIHJldHVybiBlaXRoZXIgYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgdmFyIGRlcHRoQ29tcGFyZSA9IGhvZl8xLmN1cnJ5KGZ1bmN0aW9uIChkZXB0aEZuLCBwb3NOZWcsIGxlZnQsIHJpZ2h0KSB7IHJldHVybiBwb3NOZWcgKiAoZGVwdGhGbihsZWZ0KSAtIGRlcHRoRm4ocmlnaHQpKTsgfSk7XG4gICAgICAgIHZhciBtYXRjaGluZ0NvbmZpZ1BhaXIgPSBmdW5jdGlvbiAodWlWaWV3KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdDb25maWdzID0gX3RoaXMuX3ZpZXdDb25maWdzLmZpbHRlcihWaWV3U2VydmljZS5tYXRjaGVzKHVpVmlld3NCeUZxbiwgdWlWaWV3KSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdDb25maWdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLiAgQ2hpbGQgc3RhdGVzIGNhbiB0YXJnZXQgYSB1aS12aWV3IHRoYXQgdGhlIHBhcmVudCBzdGF0ZSBhbHNvIHRhcmdldHMgKHRoZSBjaGlsZCB3aW5zKVxuICAgICAgICAgICAgICAgIC8vIFNvcnQgYnkgZGVwdGggYW5kIHJldHVybiB0aGUgbWF0Y2ggZnJvbSB0aGUgZGVlcGVzdCBjaGlsZFxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBNdWx0aXBsZSBtYXRjaGluZyB2aWV3IGNvbmZpZ3MgZm9yICR7dWlWaWV3LmZxbn1gLCBtYXRjaGluZ0NvbmZpZ3MpO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nQ29uZmlncy5zb3J0KGRlcHRoQ29tcGFyZSh2aWV3Q29uZmlnRGVwdGgsIC0xKSk7IC8vIGRlc2NlbmRpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdWlWaWV3LCBtYXRjaGluZ0NvbmZpZ3NbMF1dO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29uZmlndXJlVUlWaWV3ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdWlWaWV3ID0gX2FbMF0sIHZpZXdDb25maWcgPSBfYVsxXTtcbiAgICAgICAgICAgIC8vIElmIGEgcGFyZW50IHVpLXZpZXcgaXMgcmVjb25maWd1cmVkLCBpdCBjb3VsZCBkZXN0cm95IGNoaWxkIHVpLXZpZXdzLlxuICAgICAgICAgICAgLy8gQmVmb3JlIGNvbmZpZ3VyaW5nIGEgY2hpbGQgdWktdmlldywgbWFrZSBzdXJlIGl0J3Mgc3RpbGwgaW4gdGhlIGFjdGl2ZSB1aVZpZXdzIGFycmF5LlxuICAgICAgICAgICAgaWYgKF90aGlzLl91aVZpZXdzLmluZGV4T2YodWlWaWV3KSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgdWlWaWV3LmNvbmZpZ1VwZGF0ZWQodmlld0NvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNvcnQgdmlld3MgYnkgRlFOIGFuZCBzdGF0ZSBkZXB0aC4gUHJvY2VzcyB1aXZpZXdzIG5lYXJlc3QgdGhlIHJvb3QgZmlyc3QuXG4gICAgICAgIHRoaXMuX3VpVmlld3Muc29ydChkZXB0aENvbXBhcmUodWlWaWV3RGVwdGgsIDEpKS5tYXAobWF0Y2hpbmdDb25maWdQYWlyKS5mb3JFYWNoKGNvbmZpZ3VyZVVJVmlldyk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgYHVpLXZpZXdgIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogV2hlbiBhIGB1aS12aWV3YCBjb21wb25lbnQgaXMgY3JlYXRlZCwgaXQgdXNlcyB0aGlzIG1ldGhvZCB0byByZWdpc3RlciBpdHNlbGYuXG4gICAgICogQWZ0ZXIgcmVnaXN0cmF0aW9uIHRoZSBbW3N5bmNdXSBtZXRob2QgaXMgdXNlZCB0byBlbnN1cmUgYWxsIGB1aS12aWV3YCBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBwcm9wZXIgW1tWaWV3Q29uZmlnXV0uXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgYHVpLXZpZXdgIGNvbXBvbmVudCB1c2VzIHRoZSBgVmlld0NvbmZpZ2AgdG8gZGV0ZXJtaW5lIHdoYXQgdmlldyBzaG91bGQgYmUgbG9hZGVkIGluc2lkZSB0aGUgYHVpLXZpZXdgLFxuICAgICAqIGFuZCB3aGF0IHRoZSB2aWV3J3Mgc3RhdGUgY29udGV4dCBpcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgYGRlcmVnaXN0ZXJVSVZpZXdgLlxuICAgICAqICAgICAgIEEgYHVpLXZpZXdgIHNob3VsZCBoYW5nIG9uIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgYHJlZ2lzdGVyVUlWaWV3YCBhbmQgaW52b2tlIGl0IHRvIGRlcmVnaXN0ZXIgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpVmlldyBUaGUgbWV0YWRhdGEgZm9yIGEgVUlWaWV3XG4gICAgICogQHJldHVybiBhIGRlLXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiB1c2VkIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlclVJVmlldyA9IGZ1bmN0aW9uICh1aVZpZXcpIHtcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoXCItPiBSZWdpc3RlcmluZ1wiLCB1aVZpZXcpO1xuICAgICAgICB2YXIgdWlWaWV3cyA9IHRoaXMuX3VpVmlld3M7XG4gICAgICAgIHZhciBmcW5NYXRjaGVzID0gZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbjsgfTtcbiAgICAgICAgaWYgKHVpVmlld3MuZmlsdGVyKGZxbk1hdGNoZXMpLmxlbmd0aClcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KFwiISEhISBkdXBsaWNhdGUgdWlWaWV3IG5hbWVkOlwiLCB1aVZpZXcpO1xuICAgICAgICB1aVZpZXdzLnB1c2godWlWaWV3KTtcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdWlWaWV3cy5pbmRleE9mKHVpVmlldyk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KFwiVHJpZWQgcmVtb3Zpbmcgbm9uLXJlZ2lzdGVyZWQgdWlWaWV3XCIsIHVpVmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoXCI8LSBEZXJlZ2lzdGVyaW5nXCIsIHVpVmlldyk7XG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHVpVmlld3MpKHVpVmlldyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2aWV3cyBjdXJyZW50bHkgYXZhaWxhYmxlIG9uIHRoZSBwYWdlLCBieSBmdWxseS1xdWFsaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91aVZpZXdzLm1hcChob2ZfMS5wcm9wKFwiZnFuXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3Mgb24gdGhlIHBhZ2UgY29udGFpbmluZyBsb2FkZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91aVZpZXdzLmZpbHRlcihob2ZfMS5wcm9wKFwiJGNvbmZpZ1wiKSkubWFwKGhvZl8xLnByb3AoXCJuYW1lXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB2aWV3J3MgbmFtZSBmcm9tIGEgc3RhdGUudmlld3MgY29uZmlndXJhdGlvbiBibG9jay5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgYnkgYSBmcmFtZXdvcmsgaW1wbGVtZW50YXRpb24gdG8gY2FsY3VsYXRlIHRoZSB2YWx1ZXMgZm9yXG4gICAgICogW1tfVmlld0RlY2xhcmF0aW9uLiR1aVZpZXdOYW1lXV0gYW5kIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3Q29udGV4dEFuY2hvcl1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHQgdGhlIGNvbnRleHQgb2JqZWN0IChzdGF0ZSBkZWNsYXJhdGlvbikgdGhhdCB0aGUgdmlldyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHJhd1ZpZXdOYW1lIHRoZSBuYW1lIG9mIHRoZSB2aWV3LCBhcyBkZWNsYXJlZCBpbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHVpVmlld05hbWUgYW5kIHVpVmlld0NvbnRleHRBbmNob3IgdGhhdCB0aGUgdmlldyB0YXJnZXRzXG4gICAgICovXG4gICAgVmlld1NlcnZpY2Uubm9ybWFsaXplVUlWaWV3VGFyZ2V0ID0gZnVuY3Rpb24gKGNvbnRleHQsIHJhd1ZpZXdOYW1lKSB7XG4gICAgICAgIGlmIChyYXdWaWV3TmFtZSA9PT0gdm9pZCAwKSB7IHJhd1ZpZXdOYW1lID0gXCJcIjsgfVxuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSBpbmNvbWluZyB2aWV3IG5hbWUgd2l0aCBhIHJlZ2V4cCB0byBhbGxvdzpcbiAgICAgICAgLy8gZXg6IFwidmlldy5uYW1lQGZvby5iYXJcIiAsIFwiXi5eLnZpZXcubmFtZVwiICwgXCJ2aWV3Lm5hbWVAXi5eXCIgLCBcIlwiICxcbiAgICAgICAgLy8gXCJAXCIgLCBcIiRkZWZhdWx0QF5cIiAsIFwiISRkZWZhdWx0LiRkZWZhdWx0XCIgLCBcIiFmb28uYmFyXCJcbiAgICAgICAgdmFyIHZpZXdBdENvbnRleHQgPSByYXdWaWV3TmFtZS5zcGxpdChcIkBcIik7XG4gICAgICAgIHZhciB1aVZpZXdOYW1lID0gdmlld0F0Q29udGV4dFswXSB8fCBcIiRkZWZhdWx0XCI7IC8vIGRlZmF1bHQgdG8gdW5uYW1lZCB2aWV3XG4gICAgICAgIHZhciB1aVZpZXdDb250ZXh0QW5jaG9yID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHZpZXdBdENvbnRleHRbMV0pID8gdmlld0F0Q29udGV4dFsxXSA6IFwiXlwiOyAvLyBkZWZhdWx0IHRvIHBhcmVudCBjb250ZXh0XG4gICAgICAgIC8vIEhhbmRsZSByZWxhdGl2ZSB2aWV3LW5hbWUgc3VnYXIgc3ludGF4LlxuICAgICAgICAvLyBNYXRjaGVzIHJhd1ZpZXdOYW1lIFwiXi5eLl4uZm9vLmJhclwiIGludG8gYXJyYXk6IFtcIl4uXi5eLmZvby5iYXJcIiwgXCJeLl4uXlwiLCBcImZvby5iYXJcIl0sXG4gICAgICAgIHZhciByZWxhdGl2ZVZpZXdOYW1lU3VnYXIgPSAvXihcXF4oPzpcXC5cXF4pKilcXC4oLiokKS8uZXhlYyh1aVZpZXdOYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVmlld05hbWVTdWdhcikge1xuICAgICAgICAgICAgLy8gQ2xvYmJlcnMgZXhpc3RpbmcgY29udGV4dEFuY2hvciAocmF3Vmlld05hbWUgdmFsaWRhdGlvbiB3aWxsIGZpeCB0aGlzKVxuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IHJlbGF0aXZlVmlld05hbWVTdWdhclsxXTsgLy8gc2V0IGFuY2hvciB0byBcIl4uXi5eXCJcbiAgICAgICAgICAgIHVpVmlld05hbWUgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMl07IC8vIHNldCB2aWV3LW5hbWUgdG8gXCJmb28uYmFyXCJcbiAgICAgICAgfVxuICAgICAgICBpZiAodWlWaWV3TmFtZS5jaGFyQXQoMCkgPT09ICchJykge1xuICAgICAgICAgICAgdWlWaWV3TmFtZSA9IHVpVmlld05hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IFwiXCI7IC8vIHRhcmdldCBhYnNvbHV0ZWx5IGZyb20gcm9vdFxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBwYXJlbnQgcmVsYXRpdmUgdGFyZ2V0aW5nIFwiXi5eLl5cIlxuICAgICAgICB2YXIgcmVsYXRpdmVNYXRjaCA9IC9eKFxcXig/OlxcLlxcXikqKSQvO1xuICAgICAgICBpZiAocmVsYXRpdmVNYXRjaC5leGVjKHVpVmlld0NvbnRleHRBbmNob3IpKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdWlWaWV3Q29udGV4dEFuY2hvci5zcGxpdChcIi5cIikucmVkdWNlKChmdW5jdGlvbiAoYW5jaG9yLCB4KSB7IHJldHVybiBhbmNob3IucGFyZW50OyB9KSwgY29udGV4dCk7XG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gYW5jaG9yLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodWlWaWV3Q29udGV4dEFuY2hvciA9PT0gJy4nKSB7XG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gY29udGV4dC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVpVmlld05hbWU6IHVpVmlld05hbWUsIHVpVmlld0NvbnRleHRBbmNob3I6IHVpVmlld0NvbnRleHRBbmNob3IgfTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3U2VydmljZTtcbn0oKSk7XG4vKipcbiAqIEdpdmVuIGEgdWktdmlldyBhbmQgYSBWaWV3Q29uZmlnLCBkZXRlcm1pbmVzIGlmIHRoZXkgXCJtYXRjaFwiLlxuICpcbiAqIEEgdWktdmlldyBoYXMgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSAoZnFuKSBhbmQgYSBjb250ZXh0IG9iamVjdC4gIFRoZSBmcW4gaXMgYnVpbHQgZnJvbSBpdHMgb3ZlcmFsbCBsb2NhdGlvbiBpblxuICogdGhlIERPTSwgZGVzY3JpYmluZyBpdHMgbmVzdGluZyByZWxhdGlvbnNoaXAgdG8gYW55IHBhcmVudCB1aS12aWV3IHRhZ3MgaXQgaXMgbmVzdGVkIGluc2lkZSBvZi5cbiAqXG4gKiBBIFZpZXdDb25maWcgaGFzIGEgdGFyZ2V0IHVpLXZpZXcgbmFtZSBhbmQgYSBjb250ZXh0IGFuY2hvci4gIFRoZSB1aS12aWV3IG5hbWUgY2FuIGJlIGEgc2ltcGxlIG5hbWUsIG9yXG4gKiBjYW4gYmUgYSBzZWdtZW50ZWQgdWktdmlldyBwYXRoLCBkZXNjcmliaW5nIGEgcG9ydGlvbiBvZiBhIHVpLXZpZXcgZnFuLlxuICpcbiAqIEluIG9yZGVyIGZvciBhIHVpLXZpZXcgdG8gbWF0Y2ggVmlld0NvbmZpZywgdWktdmlldydzICR0eXBlIG11c3QgbWF0Y2ggdGhlIFZpZXdDb25maWcncyAkdHlwZVxuICpcbiAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNpbXBsZSBuYW1lIChubyBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcbiAqIC0gdGhlIHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICogLSB0aGUgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICpcbiAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNlZ21lbnRlZCBuYW1lICh3aXRoIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyB3aGVyZTpcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IChpbmRleCAwKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyAoaW5kZXggMS4ubikgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZSBtYXRjaCB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxblxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogRE9NOlxuICogPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSByb290IGNvbnRleHQgKG5hbWU6IFwiXCIpIC0tPlxuICogICA8dWktdmlldyBuYW1lPVwiZm9vXCI+ICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBXCIgICAgICAtLT5cbiAqICAgICA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkJcIiAgICAtLT5cbiAqICAgICAgIDx1aS12aWV3IG5hbWU9XCJiYXJcIj4gICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CLkNcIiAgLS0+XG4gKiAgICAgICA8L3VpLXZpZXc+XG4gKiAgICAgPC91aS12aWV3PlxuICogICA8L3VpLXZpZXc+XG4gKiA8L3VpLXZpZXc+XG4gKlxuICogdWlWaWV3czogW1xuICogIHsgZnFuOiBcIiRkZWZhdWx0XCIsICAgICAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiXCIgfSB9LFxuICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvb1wiLCAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQVwiIH0gfSxcbiAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHRcIiwgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQlwiIH0gfVxuICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiwgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CLkNcIiB9IH1cbiAqIF1cbiAqXG4gKiBUaGVzZSBmb3VyIHZpZXcgY29uZmlncyBhbGwgbWF0Y2ggdGhlIHVpLXZpZXcgd2l0aCB0aGUgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIjpcbiAqXG4gKiAtIFZpZXdDb25maWcxOiB7IHVpVmlld05hbWU6IFwiYmFyXCIsICAgICAgICAgICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQi5DXCIgfVxuICogLSBWaWV3Q29uZmlnMjogeyB1aVZpZXdOYW1lOiBcIiRkZWZhdWx0LmJhclwiLCAgICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBLkJcIiB9XG4gKiAtIFZpZXdDb25maWczOiB7IHVpVmlld05hbWU6IFwiZm9vLiRkZWZhdWx0LmJhclwiLCAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkFcIiB9XG4gKiAtIFZpZXdDb25maWc0OiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIlwiIH1cbiAqXG4gKiBVc2luZyBWaWV3Q29uZmlnMyBhcyBhbiBleGFtcGxlLCBpdCBtYXRjaGVzIHRoZSB1aS12aWV3IHdpdGggZnFuIFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiIGJlY2F1c2U6XG4gKiAtIFRoZSBWaWV3Q29uZmlnJ3Mgc2VnbWVudGVkIHRhcmdldCBuYW1lIGlzOiBbIFwiZm9vXCIsIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdXG4gKiAtIFRoZXJlIGV4aXN0cyBhIHBhcmVudCB1aS12aWV3ICh3aGljaCBoYXMgZnFuOiBcIiRkZWZhdWx0LmZvb1wiKSB3aGVyZTpcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBcImZvb1wiIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgXCJmb29cIiBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgXCJBXCIgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvciBjb250ZXh0IFwiQVwiXG4gKiAtIEFuZCB0aGUgcmVtYWluaW5nIHNlZ21lbnRzIFsgXCIkZGVmYXVsdFwiLCBcImJhclwiIF0uam9pbihcIi5cIl8gb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZSBtYXRjaFxuICogICB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxbiBcImRlZmF1bHQuYmFyXCJcbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuVmlld1NlcnZpY2UubWF0Y2hlcyA9IGZ1bmN0aW9uICh1aVZpZXdzQnlGcW4sIHVpVmlldykgeyByZXR1cm4gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAvLyBEb24ndCBzdXBwbHkgYW4gbmcxIHVpLXZpZXcgd2l0aCBhbiBuZzIgVmlld0NvbmZpZywgZXRjXG4gICAgaWYgKHVpVmlldy4kdHlwZSAhPT0gdmlld0NvbmZpZy52aWV3RGVjbC4kdHlwZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNwbGl0IG5hbWVzIGFwYXJ0IGZyb20gYm90aCB2aWV3Q29uZmlnIGFuZCB1aVZpZXcgaW50byBzZWdtZW50c1xuICAgIHZhciB2YyA9IHZpZXdDb25maWcudmlld0RlY2w7XG4gICAgdmFyIHZjU2VnbWVudHMgPSB2Yy4kdWlWaWV3TmFtZS5zcGxpdChcIi5cIik7XG4gICAgdmFyIHVpdlNlZ21lbnRzID0gdWlWaWV3LmZxbi5zcGxpdChcIi5cIik7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhaWxzIG9mIHRoZSBzZWdtZW50IGFycmF5cyBtYXRjaC4gZXgsIHRoZXNlIGFycmF5cycgdGFpbHMgbWF0Y2g6XG4gICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cbiAgICBpZiAoIWNvbW1vbl8xLmVxdWFscyh2Y1NlZ21lbnRzLCB1aXZTZWdtZW50cy5zbGljZSgwIC0gdmNTZWdtZW50cy5sZW5ndGgpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZnFuIGVuZGluZyBhdCB0aGUgZmlyc3Qgc2VnbWVudCBvZiB0aGUgdmlld0NvbmZpZyBtYXRjaGVzIHRoZSBjb250ZXh0OlxuICAgIC8vIFtcIiRkZWZhdWx0XCIsIFwiZm9vXCJdLmpvaW4oXCIuXCIpID09IFwiJGRlZmF1bHQuZm9vXCIsIGRvZXMgdGhlIHVpLXZpZXcgJGRlZmF1bHQuZm9vIGNvbnRleHQgbWF0Y2g/XG4gICAgdmFyIG5lZ09mZnNldCA9ICgxIC0gdmNTZWdtZW50cy5sZW5ndGgpIHx8IHVuZGVmaW5lZDtcbiAgICB2YXIgZnFuVG9GaXJzdFNlZ21lbnQgPSB1aXZTZWdtZW50cy5zbGljZSgwLCBuZWdPZmZzZXQpLmpvaW4oXCIuXCIpO1xuICAgIHZhciB1aVZpZXdDb250ZXh0ID0gdWlWaWV3c0J5RnFuW2ZxblRvRmlyc3RTZWdtZW50XS5jcmVhdGlvbkNvbnRleHQ7XG4gICAgcmV0dXJuIHZjLiR1aVZpZXdDb250ZXh0QW5jaG9yID09PSAodWlWaWV3Q29udGV4dCAmJiB1aVZpZXdDb250ZXh0Lm5hbWUpO1xufTsgfTtcbmV4cG9ydHMuVmlld1NlcnZpY2UgPSBWaWV3U2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uirouter/core/lib/view/view.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/angular.js":
/*!*******************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/angular.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ng_from_import = __webpack_require__(/*! angular */ \"./node_modules/angular/index.js\");\nvar ng_from_global = angular;\nexports.ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n//# sourceMappingURL=angular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2FuZ3VsYXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2FuZ3VsYXIuanM/NmU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZ19mcm9tX2ltcG9ydCA9IHJlcXVpcmUoXCJhbmd1bGFyXCIpO1xudmFyIG5nX2Zyb21fZ2xvYmFsID0gYW5ndWxhcjtcbmV4cG9ydHMubmcgPSAobmdfZnJvbV9pbXBvcnQgJiYgbmdfZnJvbV9pbXBvcnQubW9kdWxlKSA/IG5nX2Zyb21faW1wb3J0IDogbmdfZnJvbV9nbG9iYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmd1bGFyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/angular.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/directives/stateDirectives.js":
/*!**************************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/directives/stateDirectives.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\nvar angular_1 = __webpack_require__(/*! ../angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\n/** @hidden */\nfunction parseStateRef(ref) {\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = core_1.parse('$cfg.path')($uiView);\n    return path ? core_1.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = core_1.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === \"FORM\";\n    return {\n        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n        clickable: !isForm\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount-- <= 0)\n                    $timeout.cancel(transition);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: \"sref\"\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!core_1.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSref;\nuiSref = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val) {\n                        rawDef.uiStateParams = core_1.extend({}, val);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = core_1.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiState;\nuiState = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core_1.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: \"A\",\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [], activeEqClass, uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (core_1.isObject(uiSrefActive)) {\n                        core_1.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (core_1.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (core_1.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            core_1.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(core_1.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core_1.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core_1.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core_1.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !core_1.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }]\n        };\n    }];\nangular_1.ng.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n//# sourceMappingURL=stateDirectives.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2RpcmVjdGl2ZXMvc3RhdGVEaXJlY3RpdmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktcm91dGVyL2xpYi9kaXJlY3RpdmVzL3N0YXRlRGlyZWN0aXZlcy5qcz8zMmVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIEFuZ3VsYXIgMSBEaXJlY3RpdmVzXG4gKlxuICogVGhlc2UgYXJlIHRoZSBkaXJlY3RpdmVzIGluY2x1ZGVkIGluIFVJLVJvdXRlciBmb3IgQW5ndWxhciAxLlxuICogVGhlc2UgZGlyZWN0aXZlcyBhcmUgdXNlZCBpbiB0ZW1wbGF0ZXMgdG8gY3JlYXRlIHZpZXdwb3J0cyBhbmQgbGluay9uYXZpZ2F0ZSB0byBzdGF0ZXMuXG4gKlxuICogQG5nMWFwaVxuICogQHByZWZlcnJlZFxuICogQG1vZHVsZSBkaXJlY3RpdmVzXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4uL2FuZ3VsYXJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVSZWYocmVmKSB7XG4gICAgdmFyIHBhcmFtc09ubHkgPSByZWYubWF0Y2goL15cXHMqKHtbXn1dKn0pXFxzKiQvKSwgcGFyc2VkO1xuICAgIGlmIChwYXJhbXNPbmx5KVxuICAgICAgICByZWYgPSAnKCcgKyBwYXJhbXNPbmx5WzFdICsgJyknO1xuICAgIHBhcnNlZCA9IHJlZi5yZXBsYWNlKC9cXG4vZywgXCIgXCIpLm1hdGNoKC9eXFxzKihbXihdKj8pXFxzKihcXCgoLiopXFwpKT9cXHMqJC8pO1xuICAgIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgcmVmICdcIiArIHJlZiArIFwiJ1wiKTtcbiAgICByZXR1cm4geyBzdGF0ZTogcGFyc2VkWzFdIHx8IG51bGwsIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzdGF0ZUNvbnRleHQoZWwpIHtcbiAgICB2YXIgJHVpVmlldyA9IGVsLnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcbiAgICB2YXIgcGF0aCA9IGNvcmVfMS5wYXJzZSgnJGNmZy5wYXRoJykoJHVpVmlldyk7XG4gICAgcmV0dXJuIHBhdGggPyBjb3JlXzEudGFpbChwYXRoKS5zdGF0ZS5uYW1lIDogdW5kZWZpbmVkO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NlZERlZigkc3RhdGUsICRlbGVtZW50LCBkZWYpIHtcbiAgICB2YXIgdWlTdGF0ZSA9IGRlZi51aVN0YXRlIHx8ICRzdGF0ZS5jdXJyZW50Lm5hbWU7XG4gICAgdmFyIHVpU3RhdGVPcHRzID0gY29yZV8xLmV4dGVuZChkZWZhdWx0T3B0cygkZWxlbWVudCwgJHN0YXRlKSwgZGVmLnVpU3RhdGVPcHRzIHx8IHt9KTtcbiAgICB2YXIgaHJlZiA9ICRzdGF0ZS5ocmVmKHVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zLCB1aVN0YXRlT3B0cyk7XG4gICAgcmV0dXJuIHsgdWlTdGF0ZTogdWlTdGF0ZSwgdWlTdGF0ZVBhcmFtczogZGVmLnVpU3RhdGVQYXJhbXMsIHVpU3RhdGVPcHRzOiB1aVN0YXRlT3B0cywgaHJlZjogaHJlZiB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG4gICAgLy8gU1ZHQUVsZW1lbnQgZG9lcyBub3QgdXNlIHRoZSBocmVmIGF0dHJpYnV0ZSwgYnV0IHJhdGhlciB0aGUgJ3hsaW5rSHJlZicgYXR0cmlidXRlLlxuICAgIHZhciBpc1N2ZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbC5wcm9wKCdocmVmJykpID09PSAnW29iamVjdCBTVkdBbmltYXRlZFN0cmluZ10nO1xuICAgIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cjogaXNGb3JtID8gXCJhY3Rpb25cIiA6IChpc1N2ZyA/ICd4bGluazpocmVmJyA6ICdocmVmJyksXG4gICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKFwidGFnTmFtZVwiKS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIixcbiAgICAgICAgY2xpY2thYmxlOiAhaXNGb3JtXG4gICAgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBjbGlja0hvb2soZWwsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gZS53aGljaCB8fCBlLmJ1dHRvbiwgdGFyZ2V0ID0gZ2V0RGVmKCk7XG4gICAgICAgIGlmICghKGJ1dHRvbiA+IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGVsLmF0dHIoJ3RhcmdldCcpKSkge1xuICAgICAgICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28odGFyZ2V0LnVpU3RhdGUsIHRhcmdldC51aVN0YXRlUGFyYW1zLCB0YXJnZXQudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGUgaGFzIG5vIFVSTCwgaWdub3JlIG9uZSBwcmV2ZW50RGVmYXVsdCBmcm9tIHRoZSA8YT4gZGlyZWN0aXZlLlxuICAgICAgICAgICAgdmFyIGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQgPSB0eXBlLmlzQW5jaG9yICYmICF0YXJnZXQuaHJlZiA/IDEgOiAwO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlUHJldmVudERlZmF1bHRDb3VudC0tIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPcHRzKGVsLCAkc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWxhdGl2ZTogc3RhdGVDb250ZXh0KGVsKSB8fCAkc3RhdGUuJGN1cnJlbnQsXG4gICAgICAgIGluaGVyaXQ6IHRydWUsXG4gICAgICAgIHNvdXJjZTogXCJzcmVmXCJcbiAgICB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgdWlTdGF0ZU9wdHMpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGlmICh1aVN0YXRlT3B0cykge1xuICAgICAgICBldmVudHMgPSB1aVN0YXRlT3B0cy5ldmVudHM7XG4gICAgfVxuICAgIGlmICghY29yZV8xLmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgICBldmVudHMgPSBbJ2NsaWNrJ107XG4gICAgfVxuICAgIHZhciBvbiA9IGVsZW1lbnQub24gPyAnb24nIDogJ2JpbmQnO1xuICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRzXzEgPSBldmVudHM7IF9pIDwgZXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBldmVudF8xID0gZXZlbnRzXzFbX2ldO1xuICAgICAgICBlbGVtZW50W29uXShldmVudF8xLCBob29rRm4pO1xuICAgIH1cbiAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2ZmID0gZWxlbWVudC5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGV2ZW50c18yID0gZXZlbnRzOyBfaSA8IGV2ZW50c18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBldmVudHNfMltfaV07XG4gICAgICAgICAgICBlbGVtZW50W29mZl0oZXZlbnRfMiwgaG9va0ZuKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBgdWktc3JlZmA6IEEgZGlyZWN0aXZlIGZvciBsaW5raW5nIHRvIGEgc3RhdGVcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBsaW5rcyB0byBhIHN0YXRlIChhbmQgb3B0aW9uYWxseSwgcGFyYW1ldGVycykuXG4gKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogIyMjIExpbmtlZCBTdGF0ZVxuICogVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgYHVpLXNyZWZgIGlzIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBsaW5rIHRvLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgd2lsbCBhY3RpdmF0ZSB0aGUgYGhvbWVgIHN0YXRlIHdoZW4gdGhlIGxpbmsgaXMgY2xpY2tlZC5cbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBSZWxhdGl2ZSBMaW5rc1xuICogWW91IGNhbiBhbHNvIHVzZSByZWxhdGl2ZSBzdGF0ZSBwYXRocyB3aXRoaW4gYHVpLXNyZWZgLCBqdXN0IGxpa2UgYSByZWxhdGl2ZSBwYXRoIHBhc3NlZCB0byBgJHN0YXRlLmdvKClgIChbW1N0YXRlU2VydmljZS5nb11dKS5cbiAqIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgc3RhdGUgdGhhdCAqY3JlYXRlZCogdGhlIGxpbmsuXG4gKiBUaGlzIGFsbG93cyBhIHN0YXRlIHRvIGNyZWF0ZSBhIHJlbGF0aXZlIGB1aS1zcmVmYCB3aGljaCBhbHdheXMgdGFyZ2V0cyB0aGUgc2FtZSBkZXN0aW5hdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBCb3RoIHRoZXNlIGxpbmtzIGFyZSByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHN0YXRlLCBldmVuIHdoZW4gYSBjaGlsZCBzdGF0ZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cIi5jaGlsZDFcIj5jaGlsZCAxIHN0YXRlPC9hPlxuICogPGEgdWktc3JlZj1cIi5jaGlsZDJcIj5jaGlsZCAyIHN0YXRlPC9hPlxuICogYGBgXG4gKlxuICogVGhpcyBsaW5rIGFjdGl2YXRlcyB0aGUgcGFyZW50IHN0YXRlLlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cIl5cIj5SZXR1cm48L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgaHJlZnNcbiAqIElmIHRoZSBsaW5rZWQgc3RhdGUgaGFzIGEgVVJMLCB0aGUgZGlyZWN0aXZlIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhbmRcbiAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBBc3N1bWluZyB0aGUgYHVzZXJzYCBzdGF0ZSBoYXMgYSB1cmwgb2YgYC91c2Vycy9gXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwidXNlcnNcIiBocmVmPVwiL3VzZXJzL1wiPlVzZXJzPC9hPlxuICogYGBgXG4gKlxuICogIyMjIFBhcmFtZXRlciBWYWx1ZXNcbiAqIEluIGFkZGl0aW9uIHRvIHRoZSBzdGF0ZSBuYW1lLCBhIGB1aS1zcmVmYCBjYW4gaW5jbHVkZSBwYXJhbWV0ZXIgdmFsdWVzIHdoaWNoIGFyZSBhcHBsaWVkIHdoZW4gYWN0aXZhdGluZyB0aGUgc3RhdGUuXG4gKiBQYXJhbSB2YWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgdWktc3JlZmAgdmFsdWUgYWZ0ZXIgdGhlIHN0YXRlIG5hbWUsIGVuY2xvc2VkIGJ5IHBhcmVudGhlc2VzLlxuICogVGhlIGNvbnRlbnQgaW5zaWRlIHRoZSBwYXJlbnRoZXNlcyBpcyBhbiBleHByZXNzaW9uLCBldmFsdWF0ZWQgdG8gdGhlIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIHJlbmRlcnMgYSBsaXN0IG9mIGxpbmtzIHRvIHVzZXJzLlxuICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxuICogYGBgaHRtbFxuICogPGxpIG5nLXJlcGVhdD1cInVzZXIgaW4gdXNlcnNcIj5cbiAqICAgPGEgdWktc3JlZj1cInVzZXJzLmRldGFpbCh7IHVzZXJJZDogdXNlci5pZCB9KVwiPnt7IHVzZXIuZGlzcGxheU5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogTm90ZTpcbiAqIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIGV4cHJlc3Npb24gaXMgYCR3YXRjaGBlZCBmb3IgdXBkYXRlcy5cbiAqXG4gKiAjIyMgVHJhbnNpdGlvbiBPcHRpb25zXG4gKiBZb3UgY2FuIHNwZWNpZnkgW1tUcmFuc2l0aW9uT3B0aW9uc11dIHRvIHBhc3MgdG8gW1tTdGF0ZVNlcnZpY2UuZ29dXSBieSB1c2luZyB0aGUgYHVpLXNyZWYtb3B0c2AgYXR0cmlidXRlLlxuICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiIHVpLXNyZWYtb3B0cz1cInsgcmVsb2FkOiB0cnVlIH1cIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIE90aGVyIERPTSBFdmVudHNcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3VzdG9taXplIHdoaWNoIERPTSBldmVudHMgdG8gcmVzcG9uZCB0byAoaW5zdGVhZCBvZiBgY2xpY2tgKSBieVxuICogcHJvdmlkaW5nIGFuIGBldmVudHNgIGFycmF5IGluIHRoZSBgdWktc3JlZi1vcHRzYCBhdHRyaWJ1dGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdWktc3JlZj1cImNvbnRhY3RzXCIgdWktc3JlZi1vcHRzPVwieyBldmVudHM6IFsnY2hhbmdlJywgJ2JsdXInXSB9XCI+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSGlnaGxpZ2h0aW5nIHRoZSBhY3RpdmUgbGlua1xuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW3VpU3JlZkFjdGl2ZV1dIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsuXG4gKlxuICogIyMjIEV4YW1wbGVzXG4gKiBJZiB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT5cbiAqIDxhIHVpLXNyZWY9XCJhYm91dFwiPkFib3V0PC9hPlxuICogPGEgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cbiAqXG4gKiA8dWw+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+e3sgY29udGFjdC5uYW1lIH19PC9hPlxuICogICAgIDwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogVGhlbiAoYXNzdW1pbmcgdGhlIGN1cnJlbnQgc3RhdGUgaXMgYGNvbnRhY3RzYCkgdGhlIHJlbmRlcmVkIGh0bWwgaW5jbHVkaW5nIGhyZWZzIHdvdWxkIGJlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIGhyZWY9XCIjL2hvbWVcIiB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gKiA8YSBocmVmPVwiIy9hYm91dFwiIHVpLXNyZWY9XCJhYm91dFwiPkFib3V0PC9hPlxuICogPGEgaHJlZj1cIiMvY29udGFjdHM/cGFnZT0yXCIgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cbiAqXG4gKiA8dWw+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvMVwiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkpvZTwvYT5cbiAqICAgICA8L2xpPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzJcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5BbGljZTwvYT5cbiAqICAgICA8L2xpPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzNcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Cb2I8L2E+XG4gKiAgICAgPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPGEgaHJlZj1cIiMvaG9tZVwiIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwie3JlbG9hZDogdHJ1ZX1cIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIE5vdGVzXG4gKlxuICogLSBZb3UgY2FuIHVzZSBgdWktc3JlZmAgdG8gY2hhbmdlICoqb25seSB0aGUgcGFyYW1ldGVyIHZhbHVlcyoqIGJ5IG9taXR0aW5nIHRoZSBzdGF0ZSBuYW1lIGFuZCBwYXJlbnRoZXNlcy5cbiAqICMjIyMgRXhhbXBsZTpcbiAqIFNldHMgdGhlIGBsYW5nYCBwYXJhbWV0ZXIgdG8gYGVuYCBhbmQgcmVtYWlucyBvbiB0aGUgc2FtZSBzdGF0ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxuICogYGBgXG4gKlxuICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cbiAqXG4gKiAtIFVubGlrZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uLCB0aGUgc3RhdGUgbmFtZSBpcyBub3QgYCR3YXRjaGBlZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLlxuICogSWYgeW91IG5lZWQgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBzdGF0ZSBiZWluZyBsaW5rZWQgdG8sIHVzZSB0aGUgZnVsbHkgZHluYW1pYyBbW3VpU3RhdGVdXSBkaXJlY3RpdmUuXG4gKi9cbnZhciB1aVNyZWY7XG51aVNyZWYgPSBbJyR1aVJvdXRlcicsICckdGltZW91dCcsXG4gICAgZnVuY3Rpb24gJFN0YXRlUmVmRGlyZWN0aXZlKCR1aVJvdXRlciwgJHRpbWVvdXQpIHtcbiAgICAgICAgdmFyICRzdGF0ZSA9ICR1aVJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB1aVNyZWZBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGVJbmZvKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xuICAgICAgICAgICAgICAgIHZhciB1bmxpbmtJbmZvRm4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBob29rRm47XG4gICAgICAgICAgICAgICAgdmFyIHJhd0RlZiA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBnZXREZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzZWREZWYoJHN0YXRlLCBlbGVtZW50LCByYXdEZWYpOyB9O1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBwYXJzZVN0YXRlUmVmKGF0dHJzLnVpU3JlZik7XG4gICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGUgPSByZWYuc3RhdGU7XG4gICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVPcHRzID0gYXR0cnMudWlTcmVmT3B0cyA/IHNjb3BlLiRldmFsKGF0dHJzLnVpU3JlZk9wdHMpIDoge307XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmxpbmtJbmZvRm4pXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbiA9IGFjdGl2ZS4kJGFkZFN0YXRlSW5mbyhkZWYudWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmhyZWYgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWYucGFyYW1FeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChyZWYucGFyYW1FeHByLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdEZWYudWlTdGF0ZVBhcmFtcyA9IGNvcmVfMS5leHRlbmQoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gY29yZV8xLmV4dGVuZCh7fSwgc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dO1xuLyoqXG4gKiBgdWktc3RhdGVgOiBBIGZ1bGx5IGR5bmFtaWMgZGlyZWN0aXZlIGZvciBsaW5raW5nIHRvIGEgc3RhdGVcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBsaW5rcyB0byBhIHN0YXRlIChhbmQgb3B0aW9uYWxseSwgcGFyYW1ldGVycykuXG4gKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogKipUaGlzIGRpcmVjdGl2ZSBpcyB2ZXJ5IHNpbWlsYXIgdG8gW1t1aVNyZWZdXSwgYnV0IGl0IGAkb2JzZXJ2ZWBzIGFuZCBgJHdhdGNoYGVzL2V2YWx1YXRlcyBhbGwgaXRzIGlucHV0cy4qKlxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMgTGlua2VkIFN0YXRlXG4gKiBUaGUgYXR0cmlidXRlIHZhbHVlIG9mIGB1aS1zdGF0ZWAgaXMgYW4gZXhwcmVzc2lvbiB3aGljaCBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgdGhlIHN0YXRlIHRvIGxpbmsgdG8uXG4gKiAqKlRoaXMgaXMgaW4gY29udHJhc3Qgd2l0aCBgdWktc3JlZmAsIHdoaWNoIHRha2VzIGEgc3RhdGUgbmFtZSBhcyBhIHN0cmluZyBsaXRlcmFsLioqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQ3JlYXRlIGEgbGlzdCBvZiBsaW5rcy5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCI+XG4gKiAgIDxhIHVpLXN0YXRlPVwibGluay5zdGF0ZVwiPnt7IGxpbmsuZGlzcGxheU5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIFJlbGF0aXZlIExpbmtzXG4gKiBJZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYSByZWxhdGl2ZSBwYXRoLCBpdCBpcyBwcm9jZXNzZWQgbGlrZSBbW3VpU3JlZl1dLlxuICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cbiAqIFRoaXMgYWxsb3dzIGEgc3RhdGUgdG8gY3JlYXRlIHJlbGF0aXZlIGB1aS1zdGF0ZWAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXG4gKlxuICogIyMjIGhyZWZzXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXG4gKiB1cGRhdGUgdGhlIGBocmVmYCBhdHRyaWJ1dGUgKHVzaW5nIHRoZSBbW1N0YXRlU2VydmljZS5ocmVmXV0gIG1ldGhvZCkuXG4gKlxuICogIyMjIFBhcmFtZXRlciBWYWx1ZXNcbiAqIEluIGFkZGl0aW9uIHRvIHRoZSBzdGF0ZSBuYW1lIGV4cHJlc3Npb24sIGEgYHVpLXN0YXRlYCBjYW4gaW5jbHVkZSBwYXJhbWV0ZXIgdmFsdWVzIHdoaWNoIGFyZSBhcHBsaWVkIHdoZW4gYWN0aXZhdGluZyB0aGUgc3RhdGUuXG4gKiBQYXJhbSB2YWx1ZXMgc2hvdWxkIGJlIHByb3ZpZGVkIHVzaW5nIHRoZSBgdWktc3RhdGUtcGFyYW1zYCBhdHRyaWJ1dGUuXG4gKiBUaGUgYHVpLXN0YXRlLXBhcmFtc2AgYXR0cmlidXRlIHZhbHVlIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyBhbiBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB3aXRoIHBhcmFtIHZhbHVlcy5cbiAqIFRoZSBzdGF0ZSdzIGB1c2VySWRgIHBhcmFtZXRlciB2YWx1ZSBjb21lcyBmcm9tIGVhY2ggdXNlcidzIGB1c2VyLmlkYCBwcm9wZXJ0eS5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCI+XG4gKiAgIDxhIHVpLXN0YXRlPVwibGluay5zdGF0ZVwiIHVpLXN0YXRlLXBhcmFtcz1cImxpbmsucGFyYW1zXCI+e3sgbGluay5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiAjIyMgVHJhbnNpdGlvbiBPcHRpb25zXG4gKiBZb3UgY2FuIHNwZWNpZnkgW1tUcmFuc2l0aW9uT3B0aW9uc11dIHRvIHBhc3MgdG8gW1tTdGF0ZVNlcnZpY2UuZ29dXSBieSB1c2luZyB0aGUgYHVpLXN0YXRlLW9wdHNgIGF0dHJpYnV0ZS5cbiAqIE9wdGlvbnMgYXJlIHJlc3RyaWN0ZWQgdG8gYGxvY2F0aW9uYCwgYGluaGVyaXRgLCBhbmQgYHJlbG9hZGAuXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGB1aS1zdGF0ZS1vcHRzYCBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zdGF0ZT1cInJldHVybnRvLnN0YXRlXCIgdWktc3RhdGUtb3B0cz1cInsgcmVsb2FkOiB0cnVlIH1cIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIE90aGVyIERPTSBFdmVudHNcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3VzdG9taXplIHdoaWNoIERPTSBldmVudHMgdG8gcmVzcG9uZCB0byAoaW5zdGVhZCBvZiBgY2xpY2tgKSBieVxuICogcHJvdmlkaW5nIGFuIGBldmVudHNgIGFycmF5IGluIHRoZSBgdWktc3RhdGUtb3B0c2AgYXR0cmlidXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXN0YXRlPVwiY29udGFjdHNcIiB1aS1zdGF0ZS1vcHRzPVwieyBldmVudHM6IFsnY2hhbmdlJywgJ2JsdXInXSB9XCI+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSGlnaGxpZ2h0aW5nIHRoZSBhY3RpdmUgbGlua1xuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW3VpU3JlZkFjdGl2ZV1dIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsuXG4gKlxuICogIyMjIE5vdGVzXG4gKlxuICogLSBZb3UgY2FuIHVzZSBgdWktcGFyYW1zYCB0byBjaGFuZ2UgKipvbmx5IHRoZSBwYXJhbWV0ZXIgdmFsdWVzKiogYnkgb21pdHRpbmcgdGhlIHN0YXRlIG5hbWUgYW5kIHN1cHBseWluZyBvbmx5IGB1aS1zdGF0ZS1wYXJhbXNgLlxuICogICBIb3dldmVyLCBpdCBtaWdodCBiZSBzaW1wbGVyIHRvIHVzZSBbW3VpU3JlZl1dIHBhcmFtZXRlci1vbmx5IGxpbmtzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFNldHMgdGhlIGBsYW5nYCBwYXJhbWV0ZXIgdG8gYGVuYCBhbmQgcmVtYWlucyBvbiB0aGUgc2FtZSBzdGF0ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zdGF0ZT1cIlwiIHVpLXN0YXRlLXBhcmFtcz1cInsgbGFuZzogJ2VuJyB9XCI+RW5nbGlzaDwvYT5cbiAqIGBgYFxuICpcbiAqIC0gQSBtaWRkbGUtY2xpY2ssIHJpZ2h0LWNsaWNrLCBvciBjdHJsLWNsaWNrIGlzIGhhbmRsZWQgKG5hdGl2ZWx5KSBieSB0aGUgYnJvd3NlciB0byBvcGVuIHRoZSBocmVmIGluIGEgbmV3IHdpbmRvdywgZm9yIGV4YW1wbGUuXG4gKiBgYGBcbiAqL1xudmFyIHVpU3RhdGU7XG51aVN0YXRlID0gWyckdWlSb3V0ZXInLCAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUoJHVpUm91dGVyLCAkdGltZW91dCkge1xuICAgICAgICB2YXIgJHN0YXRlID0gJHVpUm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICAgICAgICAgICAgdmFyIHVubGlua0luZm9GbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tGbjtcbiAgICAgICAgICAgICAgICB2YXIgcmF3RGVmID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGdldERlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2Nlc3NlZERlZigkc3RhdGUsIGVsZW1lbnQsIHJhd0RlZik7IH07XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0QXR0cnMgPSBbJ3VpU3RhdGUnLCAndWlTdGF0ZVBhcmFtcycsICd1aVN0YXRlT3B0cyddO1xuICAgICAgICAgICAgICAgIHZhciB3YXRjaERlcmVnRm5zID0gaW5wdXRBdHRycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikgeyByZXR1cm4gKGFjY1thdHRyXSA9IGNvcmVfMS5ub29wLCBhY2MpOyB9LCB7fSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmxpbmtJbmZvRm4pXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbiA9IGFjdGl2ZS4kJGFkZFN0YXRlSW5mbyhkZWYudWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmhyZWYgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0QXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IGF0dHJzW2ZpZWxkXSA/IHNjb3BlLiRldmFsKGF0dHJzW2ZpZWxkXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShmaWVsZCwgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoRGVyZWdGbnNbZmllbGRdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSA9IHNjb3BlLiR3YXRjaChleHByLCBmdW5jdGlvbiAobmV3dmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IG5ld3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dO1xuLyoqXG4gKiBgdWktc3JlZi1hY3RpdmVgIGFuZCBgdWktc3JlZi1hY3RpdmUtZXFgOiBBIGRpcmVjdGl2ZSB0aGF0IGFkZHMgYSBDU1MgY2xhc3Mgd2hlbiBhIGB1aS1zcmVmYCBpcyBhY3RpdmVcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3b3JraW5nIGFsb25nc2lkZSBbW3VpU3JlZl1dIGFuZCBbW3VpU3RhdGVdXSB0byBhZGQgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlXG4gKiByZWxhdGVkIGRpcmVjdGl2ZSdzIHN0YXRlIGlzIGFjdGl2ZSAoYW5kIHJlbW92ZSB0aGVtIHdoZW4gaXQgaXMgaW5hY3RpdmUpLlxuICpcbiAqIFRoZSBwcmltYXJ5IHVzZS1jYXNlIGlzIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsgaW4gbmF2aWdhdGlvbiBtZW51cyxcbiAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG4gKlxuICogIyMjIExpbmtpbmcgdG8gYSBgdWktc3JlZmAgb3IgYHVpLXN0YXRlYFxuICogYHVpLXNyZWYtYWN0aXZlYCBjYW4gbGl2ZSBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBvciBpdCBjYW4gYmUgb24gYSBwYXJlbnQgZWxlbWVudC5cbiAqIElmIGEgYHVpLXNyZWYtYWN0aXZlYCBpcyBhIHBhcmVudCB0byBtb3JlIHRoYW4gb25lIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBpdCB3aWxsIGFwcGx5IHRoZSBDU1MgY2xhc3Mgd2hlbiAqKmFueSBvZiB0aGUgbGlua3MgYXJlIGFjdGl2ZSoqLlxuICpcbiAqICMjIyBNYXRjaGluZ1xuICpcbiAqIFRoZSBgdWktc3JlZi1hY3RpdmVgIGRpcmVjdGl2ZSBhcHBsaWVzIHRoZSBDU1MgY2xhc3Mgd2hlbiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAncyB0YXJnZXQgc3RhdGUgKipvciBhbnkgY2hpbGQgc3RhdGUgaXMgYWN0aXZlKiouXG4gKiBUaGlzIGlzIGEgXCJmdXp6eSBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXS5cbiAqXG4gKiBUaGUgYHVpLXNyZWYtYWN0aXZlLWVxYCBkaXJlY3RpdmUgYXBwbGllcyB0aGUgQ1NTIGNsYXNzIHdoZW4gdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgJ3MgdGFyZ2V0IHN0YXRlIGlzIGRpcmVjdGx5IGFjdGl2ZSAobm90IHdoZW4gY2hpbGQgc3RhdGVzIGFyZSBhY3RpdmUpLlxuICogVGhpcyBpcyBhbiBcImV4YWN0IG1hdGNoXCIgd2hpY2ggdXNlcyBbW1N0YXRlU2VydmljZS5pc11dLlxuICpcbiAqICMjIyBQYXJhbWV0ZXIgdmFsdWVzXG4gKiBJZiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAgaW5jbHVkZXMgcGFyYW1ldGVyIHZhbHVlcywgdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyBtdXN0IG1hdGNoIHRoZSBsaW5rJ3MgdmFsdWVzIGZvciB0aGUgbGluayB0byBiZSBoaWdobGlnaHRlZC5cbiAqIFRoaXMgYWxsb3dzIGEgbGlzdCBvZiBsaW5rcyB0byB0aGUgc2FtZSBzdGF0ZSB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIHRvIGJlIHJlbmRlcmVkLCBhbmQgdGhlIGNvcnJlY3Qgb25lIGhpZ2hsaWdodGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCIgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIj5cbiAqICAgPGEgdWktc3JlZj1cInVzZXIuZGV0YWlscyh7IHVzZXJJZDogdXNlci5pZCB9KVwiPnt7IHVzZXIubGFzdE5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGVzXG4gKlxuICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtXCI+XG4gKiAgICAgPGEgaHJlZiB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGFwcCBzdGF0ZSBpcyBgYXBwLnVzZXJgIChvciBhbnkgY2hpbGQgc3RhdGUpLFxuICogYW5kIGNvbnRhaW5zIHRoZSBzdGF0ZSBwYXJhbWV0ZXIgXCJ1c2VyXCIgd2l0aCB2YWx1ZSBcImJpbGJvYmFnZ2luc1wiLFxuICogdGhlIHJlc3VsdGluZyBIVE1MIHdpbGwgYXBwZWFyIGFzIChub3RlIHRoZSAnYWN0aXZlJyBjbGFzcyk6XG4gKlxuICogYGBgaHRtbFxuICogPHVsPlxuICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCIgaHJlZj1cIi91c2Vycy9iaWxib2JhZ2dpbnNcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iIG1vZGVcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGB1aS1zcmVmLWFjdGl2ZWAgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0cyBrZXlzIHJlcHJlc2VudCBhY3RpdmUgY2xhc3MgbmFtZXMgYW5kIHZhbHVlcyByZXByZXNlbnQgdGhlIHJlc3BlY3RpdmUgc3RhdGUgbmFtZXMvZ2xvYnMuXG4gKiBgdWktc3JlZi1hY3RpdmVgIHdpbGwgbWF0Y2ggaWYgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlICoqaW5jbHVkZXMqKiBhbnkgb2ZcbiAqIHRoZSBzcGVjaWZpZWQgc3RhdGUgbmFtZXMvZ2xvYnMsIGV2ZW4gdGhlIGFic3RyYWN0IG9uZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSwgd2l0aCBcImFkbWluXCIgYmVpbmcgYW4gYWJzdHJhY3Qgc3RhdGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IHVpLXNyZWYtYWN0aXZlPVwieydhY3RpdmUnOiAnYWRtaW4uKionfVwiPlxuICogICA8YSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIHVpLXNyZWY9XCJhZG1pbi5yb2xlc1wiPlJvbGVzPC9hPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBjdXJyZW50IHN0YXRlIGlzIFwiYWRtaW4ucm9sZXNcIiB0aGUgXCJhY3RpdmVcIiBjbGFzcyB3aWxsIGJlIGFwcGxpZWQgdG8gYm90aCB0aGUgPGRpdj4gYW5kIDxhPiBlbGVtZW50cy5cbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlIHN0YXRlIG5hbWVzL2dsb2JzIHBhc3NlZCB0byBgdWktc3JlZi1hY3RpdmVgIG92ZXJyaWRlIGFueSBzdGF0ZSBwcm92aWRlZCBieSBhIGxpbmtlZCBgdWktc3JlZmAuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIC0gVGhlIGNsYXNzIG5hbWUgaXMgaW50ZXJwb2xhdGVkICoqb25jZSoqIGR1cmluZyB0aGUgZGlyZWN0aXZlcyBsaW5rIHRpbWUgKGFueSBmdXJ0aGVyIGNoYW5nZXMgdG8gdGhlXG4gKiBpbnRlcnBvbGF0ZWQgdmFsdWUgYXJlIGlnbm9yZWQpLlxuICpcbiAqIC0gTXVsdGlwbGUgY2xhc3NlcyBtYXkgYmUgc3BlY2lmaWVkIGluIGEgc3BhY2Utc2VwYXJhdGVkIGZvcm1hdDogYHVpLXNyZWYtYWN0aXZlPSdjbGFzczEgY2xhc3MyIGNsYXNzMydgXG4gKi9cbnZhciB1aVNyZWZBY3RpdmU7XG51aVNyZWZBY3RpdmUgPSBbJyRzdGF0ZScsICckc3RhdGVQYXJhbXMnLCAnJGludGVycG9sYXRlJywgJyR1aVJvdXRlcicsXG4gICAgZnVuY3Rpb24gJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKCRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkaW50ZXJwb2xhdGUsICR1aVJvdXRlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6IFwiQVwiLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBbXSwgYWN0aXZlRXFDbGFzcywgdWlTcmVmQWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBwcm9iYWJseSBpc24ndCBtdWNoIHBvaW50IGluICRvYnNlcnZpbmcgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyB1aVNyZWZBY3RpdmUgYW5kIHVpU3JlZkFjdGl2ZUVxIHNoYXJlIHRoZSBzYW1lIGRpcmVjdGl2ZSBvYmplY3Qgd2l0aCBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIHNsaWdodCBkaWZmZXJlbmNlIGluIGxvZ2ljIHJvdXRpbmdcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXFDbGFzcyA9ICRpbnRlcnBvbGF0ZSgkYXR0cnMudWlTcmVmQWN0aXZlRXEgfHwgJycsIGZhbHNlKSgkc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gJHNjb3BlLiRldmFsKCRhdHRycy51aVNyZWZBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLiB1aVNyZWZBY3RpdmUgaXMgbm90IGEgdmFsaWQgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyAkaW50ZXJwb2xhdGUgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1aVNyZWZBY3RpdmUgPSB1aVNyZWZBY3RpdmUgfHwgJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmUgfHwgJycsIGZhbHNlKSgkc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29yZV8xLmlzT2JqZWN0KHVpU3JlZkFjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS5mb3JFYWNoKHVpU3JlZkFjdGl2ZSwgZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBwYXJzZVN0YXRlUmVmKHN0YXRlT3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGUocmVmLnN0YXRlLCAkc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwciksIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB1aVNyZWYgdG8gY29tbXVuaWNhdGUgd2l0aCB1aVNyZWZBY3RpdmVbRXF1YWxzXVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQkYWRkU3RhdGVJbmZvID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBuZXdQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgZ290IGFuIGV4cGxpY2l0IHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYtYWN0aXZlLCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hhZG93IHRoZSBvbmUgdGhhdCBjb21lcyBmcm9tIHVpLXNyZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlXzEuaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXJlZ2lzdGVyID0gYWRkU3RhdGUobmV3U3RhdGUsIG5ld1BhcmFtcywgdWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbih0cmFucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMucHJvbWlzZS50aGVuKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKCR1aVJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMsIGFjdGl2ZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSwgc3RhdGVDb250ZXh0KCRlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSB8fCB7IG5hbWU6IHN0YXRlTmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogc3RhdGVQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGFjdGl2ZUNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVzLnB1c2goc3RhdGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEucmVtb3ZlRnJvbShzdGF0ZXMpKHN0YXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByb3V0ZSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRDbGFzc2VzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3BsaXQoL1xccy8pLmZpbHRlcihjb3JlXzEuaWRlbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRDbGFzc2VzID0gZnVuY3Rpb24gKHN0YXRlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZUxpc3QubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmFjdGl2ZUNsYXNzOyB9KS5tYXAoc3BsaXRDbGFzc2VzKS5yZWR1Y2UoY29yZV8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzKS5jb25jYXQoc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpKS5yZWR1Y2UoY29yZV8xLnVuaXFSLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnV6enlDbGFzc2VzID0gZ2V0Q2xhc3NlcyhzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAkc3RhdGUuaW5jbHVkZXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcyk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGFjdGx5TWF0Y2hlc0FueSA9ICEhc3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gJHN0YXRlLmlzKHguc3RhdGUubmFtZSwgeC5wYXJhbXMpOyB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhhY3RDbGFzc2VzID0gZXhhY3RseU1hdGNoZXNBbnkgPyBzcGxpdENsYXNzZXMoYWN0aXZlRXFDbGFzcykgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRDbGFzc2VzID0gZnV6enlDbGFzc2VzLmNvbmNhdChleGFjdENsYXNzZXMpLnJlZHVjZShjb3JlXzEudW5pcVIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVDbGFzc2VzID0gYWxsQ2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNscykgeyByZXR1cm4gIWNvcmVfMS5pbkFycmF5KGFkZENsYXNzZXMsIGNscyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiAkZWxlbWVudC5hZGRDbGFzcyhjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gJGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1dO1xuYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWYpXG4gICAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgdWlTcmVmQWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZUVxJywgdWlTcmVmQWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlRGlyZWN0aXZlcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/directives/stateDirectives.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/directives/viewDirective.js":
/*!************************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/directives/viewDirective.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\nvar angular_1 = __webpack_require__(/*! ../angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\nvar angular_2 = __webpack_require__(/*! angular */ \"./node_modules/angular/index.js\");\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nvar views_1 = __webpack_require__(/*! ../statebuilders/views */ \"./node_modules/angular-ui-router/lib/statebuilders/views.js\");\nvar services_1 = __webpack_require__(/*! ../services */ \"./node_modules/angular-ui-router/lib/services.js\");\nexports.uiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                }\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {}\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = core_1.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = core_1.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        }\n                    };\n                    core_1.trace.traceUIViewEvent(\"Linking\", activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof views_1.Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        core_1.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on(\"$destroy\", function () {\n                        core_1.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            core_1.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            core_1.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            core_1.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (core_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            }\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = core_1.parse('viewDecl.controllerAs');\n    var getResolveAs = core_1.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: angular_2.noop };\n                var resolveCtx = cfg.path && new core_1.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                core_1.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && services_1.getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, core_1.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (core_1.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = core_1.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && angular_1.ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        }\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof angular_1.ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (core_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = core_1.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (core_1.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new core_1.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params(\"to\");\n            var fromParams = $transition$.params(\"from\");\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = core_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (core_1.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val) { return ids[id_1] = (val !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nangular_1.ng.module('ui.router.state').directive('uiView', exports.uiView);\nangular_1.ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n//# sourceMappingURL=viewDirective.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2RpcmVjdGl2ZXMvdmlld0RpcmVjdGl2ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbmd1bGFyLXVpLXJvdXRlci9saWIvZGlyZWN0aXZlcy92aWV3RGlyZWN0aXZlLmpzP2JjN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBuZzFhcGlcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGFuZ3VsYXJfMSA9IHJlcXVpcmUoXCIuLi9hbmd1bGFyXCIpO1xudmFyIGFuZ3VsYXJfMiA9IHJlcXVpcmUoXCJhbmd1bGFyXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcbnZhciB2aWV3c18xID0gcmVxdWlyZShcIi4uL3N0YXRlYnVpbGRlcnMvdmlld3NcIik7XG52YXIgc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9zZXJ2aWNlc1wiKTtcbmV4cG9ydHMudWlWaWV3ID0gWyckdmlldycsICckYW5pbWF0ZScsICckdWlWaWV3U2Nyb2xsJywgJyRpbnRlcnBvbGF0ZScsICckcScsXG4gICAgZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmUoJHZpZXcsICRhbmltYXRlLCAkdWlWaWV3U2Nyb2xsLCAkaW50ZXJwb2xhdGUsICRxKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIHRhcmdldCwgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXJfMS5uZy52ZXJzaW9uLm1pbm9yID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyXzEubmcudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGVsZW1lbnQpLnRoZW4oY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25maWdzRXF1YWwoY29uZmlnMSwgY29uZmlnMikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZzEgPT09IGNvbmZpZzI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3REYXRhID0ge1xuICAgICAgICAgICAgJGNmZzogeyB2aWV3RGVjbDogeyAkY29udGV4dDogJHZpZXcuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KCkgfSB9LFxuICAgICAgICAgICAgJHVpVmlldzoge31cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHtcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgICAgICAgICAgdGVybWluYWw6IHRydWUsXG4gICAgICAgICAgICBwcmlvcml0eTogNDAwLFxuICAgICAgICAgICAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50LCB0QXR0cnMsICR0cmFuc2NsdWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0VsLCBjdXJyZW50RWwsIGN1cnJlbnRTY29wZSwgdW5yZWdpc3Rlciwgb25sb2FkRXhwID0gYXR0cnNbJ29ubG9hZCddIHx8ICcnLCBhdXRvU2Nyb2xsRXhwID0gYXR0cnNbJ2F1dG9zY3JvbGwnXSwgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpLCB2aWV3Q29uZmlnID0gdW5kZWZpbmVkLCBpbmhlcml0ZWQgPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCckdWlWaWV3JykgfHwgcm9vdERhdGEsIG5hbWUgPSAkaW50ZXJwb2xhdGUoYXR0cnNbJ3VpVmlldyddIHx8IGF0dHJzWyduYW1lJ10gfHwgJycpKHNjb3BlKSB8fCAnJGRlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlVUlWaWV3ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGU6ICduZzEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRpcmVjdGl2ZS5jb3VudCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZxbjogaW5oZXJpdGVkLiR1aVZpZXcuZnFuID8gaW5oZXJpdGVkLiR1aVZpZXcuZnFuICsgXCIuXCIgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1VwZGF0ZWQ6IGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjcmVhdGlvbkNvbnRleHQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21QYXJlbnRUYWdDb25maWcgPSBjb3JlXzEucGFyc2UoJyRjZmcudmlld0RlY2wuJGNvbnRleHQnKShpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IDx1aS12aWV3IG5hbWU9XCJmb29cIj48dWktdmlldyBuYW1lPVwiYmFyXCI+PC91aS12aWV3PjwvdWktdmlldz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8zMzU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21QYXJlbnRUYWcgPSBjb3JlXzEucGFyc2UoJyR1aVZpZXcuY3JlYXRpb25Db250ZXh0JykoaW5oZXJpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVBhcmVudFRhZ0NvbmZpZyB8fCBmcm9tUGFyZW50VGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkxpbmtpbmdcIiwgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uZmlnVXBkYXRlZENhbGxiYWNrKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAhKGNvbmZpZyBpbnN0YW5jZW9mIHZpZXdzXzEuTmcxVmlld0NvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS50cmFjZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQoYWN0aXZlVUlWaWV3LCBjb25maWcgJiYgY29uZmlnLnZpZXdEZWNsICYmIGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Q29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldyhjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmRhdGEoJyR1aVZpZXcnLCB7ICR1aVZpZXc6IGFjdGl2ZVVJVmlldyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldygpO1xuICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyID0gJHZpZXcucmVnaXN0ZXJVSVZpZXcoYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJG9uKFwiJGRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJEZXN0cm95aW5nL1VucmVnaXN0ZXJpbmdcIiwgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBMYXN0VmlldygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJSZW1vdmluZyAocHJldmlvdXMpIGVsXCIsIHByZXZpb3VzRWwuZGF0YSgnJHVpVmlldycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS50cmFjZS50cmFjZVVJVmlld0V2ZW50KFwiRGVzdHJveWluZyBzY29wZVwiLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92aWV3RGF0YV8xID0gY3VycmVudEVsLmRhdGEoJyR1aVZpZXdBbmltJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJBbmltYXRlIG91dFwiLCBfdmlld0RhdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIubGVhdmUoY3VycmVudEVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3RGF0YV8xLiQkYW5pbUxlYXZlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IGN1cnJlbnRFbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbUVudGVyID0gJHEuZGVmZXIoKSwgYW5pbUxlYXZlID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdWlWaWV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY2ZnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpVmlldzogYWN0aXZlVUlWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdWlWaWV3QW5pbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbUVudGVyOiBhbmltRW50ZXIucHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbUxlYXZlOiBhbmltTGVhdmUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkJGFuaW1MZWF2ZTogYW5pbUxlYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgKipiZWdpbnMgbG9hZGluZyoqLCAqYmVmb3JlKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRpbmcnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZWQgPSAkdHJhbnNjbHVkZShuZXdTY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGF0YSgnJHVpVmlld0FuaW0nLCAkdWlWaWV3QW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGF0YSgnJHVpVmlldycsICR1aVZpZXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5lbnRlcihjbG9uZSwgJGVsZW1lbnQsIGZ1bmN0aW9uIG9uVUlWaWV3RW50ZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1FbnRlci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudEFuaW1hdGlvbkVuZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlXzEuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWlWaWV3U2Nyb2xsKGNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWwgPSBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5nZG9jIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkZWQnLCBjb25maWcgfHwgdmlld0NvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGV2YWwob25sb2FkRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmU7XG4gICAgfV07XG4kVmlld0RpcmVjdGl2ZUZpbGwuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHRyYW5zaXRpb25zJywgJyR2aWV3JywgJyRxJywgJyR0aW1lb3V0J107XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmVGaWxsKCRjb21waWxlLCAkY29udHJvbGxlciwgJHRyYW5zaXRpb25zLCAkdmlldywgJHEsICR0aW1lb3V0KSB7XG4gICAgdmFyIGdldENvbnRyb2xsZXJBcyA9IGNvcmVfMS5wYXJzZSgndmlld0RlY2wuY29udHJvbGxlckFzJyk7XG4gICAgdmFyIGdldFJlc29sdmVBcyA9IGNvcmVfMS5wYXJzZSgndmlld0RlY2wucmVzb2x2ZUFzJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgICAgICBwcmlvcml0eTogLTQwMCxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbCA9IHRFbGVtZW50Lmh0bWwoKTtcbiAgICAgICAgICAgIHRFbGVtZW50LmVtcHR5KCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCAkZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YSgnJHVpVmlldycpO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5odG1sKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNmZyA9IGRhdGEuJGNmZyB8fCB7IHZpZXdEZWNsOiB7fSwgZ2V0VGVtcGxhdGU6IGFuZ3VsYXJfMi5ub29wIH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVDdHggPSBjZmcucGF0aCAmJiBuZXcgY29yZV8xLlJlc29sdmVDb250ZXh0KGNmZy5wYXRoKTtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5odG1sKGNmZy5nZXRUZW1wbGF0ZSgkZWxlbWVudCwgcmVzb2x2ZUN0eCkgfHwgaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RmlsbChkYXRhLiR1aVZpZXcsICRlbGVtZW50Lmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IGNmZy5jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyQXMgPSBnZXRDb250cm9sbGVyQXMoY2ZnKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUFzID0gZ2V0UmVzb2x2ZUFzKGNmZyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FscyA9IHJlc29sdmVDdHggJiYgc2VydmljZXNfMS5nZXRMb2NhbHMocmVzb2x2ZUN0eCk7XG4gICAgICAgICAgICAgICAgc2NvcGVbcmVzb2x2ZUFzXSA9IGxvY2FscztcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gJGNvbnRyb2xsZXIoY29udHJvbGxlciwgY29yZV8xLmV4dGVuZCh7fSwgbG9jYWxzLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlW2NvbnRyb2xsZXJBc10gPSBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdW3Jlc29sdmVBc10gPSBsb2NhbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVXNlICR2aWV3IHNlcnZpY2UgYXMgYSBjZW50cmFsIHBvaW50IGZvciByZWdpc3RlcmluZyBjb21wb25lbnQtbGV2ZWwgaG9va3NcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2hlbiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkLCB0ZWxsIHRoZSAkdmlldyBzZXJ2aWNlLCBzbyBpdCBjYW4gaW52b2tlIGhvb2tzXG4gICAgICAgICAgICAgICAgICAgIC8vICR2aWV3LmNvbXBvbmVudExvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzY29wZS4kb24oJyRkZXN0cm95JywgKCkgPT4gJHZpZXcuY29tcG9uZW50VW5sb2FkZWQoY29udHJvbGxlckluc3RhbmNlLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGFwcGVhciBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKGNvcmVfMS5pc1N0cmluZyhjZmcudmlld0RlY2wuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY21wXzEgPSBjZmcudmlld0RlY2wuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIga2Vib2JOYW1lID0gY29yZV8xLmtlYm9iU3RyaW5nKGNtcF8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ1JlZ2V4cF8xID0gbmV3IFJlZ0V4cChcIl4oeC18ZGF0YS0pP1wiICsga2Vib2JOYW1lICsgXCIkXCIsIFwiaVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldENvbXBvbmVudENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlRWwgPSBbXS5zbGljZS5jYWxsKCRlbGVtZW50WzBdLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIHRhZ1JlZ2V4cF8xLmV4ZWMoZWwudGFnTmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUVsICYmIGFuZ3VsYXJfMS5uZy5lbGVtZW50KGRpcmVjdGl2ZUVsKS5kYXRhKFwiJFwiICsgY21wXzEgKyBcIkNvbnRyb2xsZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXJlZ2lzdGVyV2F0Y2hfMSA9IHNjb3BlLiR3YXRjaChnZXRDb21wb25lbnRDb250cm9sbGVyLCBmdW5jdGlvbiAoY3RybEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmxJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY3RybEluc3RhbmNlLCBzY29wZSwgY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJXYXRjaF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rKHNjb3BlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBoYXNDb21wb25lbnRJbXBsID0gdHlwZW9mIGFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlcicpWydjb21wb25lbnQnXSA9PT0gJ2Z1bmN0aW9uJztcbi8qKiBAaGlkZGVuIGluY3JlbWVudGluZyBpZCAqL1xudmFyIF91aUNhbkV4aXRJZCA9IDA7XG4vKiogQGhpZGRlbiBUT0RPOiBtb3ZlIHRoZXNlIGNhbGxiYWNrcyB0byAkdmlldyBhbmQvb3IgYC9ob29rcy9jb21wb25lbnRzLnRzYCBvciBzb21ldGhpbmcgKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsICRzY29wZSwgY2ZnKSB7XG4gICAgLy8gQ2FsbCAkb25Jbml0KCkgQVNBUFxuICAgIGlmIChjb3JlXzEuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UuJG9uSW5pdCkgJiYgIShjZmcudmlld0RlY2wuY29tcG9uZW50ICYmIGhhc0NvbXBvbmVudEltcGwpKSB7XG4gICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZS4kb25Jbml0KCk7XG4gICAgfVxuICAgIHZhciB2aWV3U3RhdGUgPSBjb3JlXzEudGFpbChjZmcucGF0aCkuc3RhdGUuc2VsZjtcbiAgICB2YXIgaG9va09wdGlvbnMgPSB7IGJpbmQ6IGNvbnRyb2xsZXJJbnN0YW5jZSB9O1xuICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25QYXJhbXNDaGFuZ2VcbiAgICBpZiAoY29yZV8xLmlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKSkge1xuICAgICAgICB2YXIgcmVzb2x2ZUNvbnRleHQgPSBuZXcgY29yZV8xLlJlc29sdmVDb250ZXh0KGNmZy5wYXRoKTtcbiAgICAgICAgdmFyIHZpZXdDcmVhdGlvblRyYW5zXzEgPSByZXNvbHZlQ29udGV4dC5nZXRSZXNvbHZhYmxlKCckdHJhbnNpdGlvbiQnKS5kYXRhO1xuICAgICAgICAvLyBGaXJlIGNhbGxiYWNrIG9uIGFueSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAgICAgICAgdmFyIHBhcmFtc1VwZGF0ZWQgPSBmdW5jdGlvbiAoJHRyYW5zaXRpb24kKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSAkdHJhbnNpdGlvbiQgaXMgdGhlIHNhbWUgYXMgdGhlIHZpZXcgd2FzIGNyZWF0ZWQgd2l0aGluLlxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIHdpbGwgZXhpdCB0aGUgc3RhdGUgdGhlIHZpZXcgaXMgZm9yLlxuICAgICAgICAgICAgaWYgKCR0cmFuc2l0aW9uJCA9PT0gdmlld0NyZWF0aW9uVHJhbnNfMSB8fCAkdHJhbnNpdGlvbiQuZXhpdGluZygpLmluZGV4T2Yodmlld1N0YXRlKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRvUGFyYW1zID0gJHRyYW5zaXRpb24kLnBhcmFtcyhcInRvXCIpO1xuICAgICAgICAgICAgdmFyIGZyb21QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKFwiZnJvbVwiKTtcbiAgICAgICAgICAgIHZhciB0b1NjaGVtYSA9ICR0cmFuc2l0aW9uJC50cmVlQ2hhbmdlcygpLnRvLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSkucmVkdWNlKGNvcmVfMS51bm5lc3RSLCBbXSk7XG4gICAgICAgICAgICB2YXIgZnJvbVNjaGVtYSA9ICR0cmFuc2l0aW9uJC50cmVlQ2hhbmdlcygpLmZyb20ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KS5yZWR1Y2UoY29yZV8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvIHBhcmFtcyB0aGF0IGhhdmUgZGlmZmVyZW50IHZhbHVlcyB0aGFuIHRoZSBmcm9tIHBhcmFtc1xuICAgICAgICAgICAgdmFyIGNoYW5nZWRUb1BhcmFtcyA9IHRvU2NoZW1hLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZnJvbVNjaGVtYS5pbmRleE9mKHBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4ID09PSAtMSB8fCAhZnJvbVNjaGVtYVtpZHhdLnR5cGUuZXF1YWxzKHRvUGFyYW1zW3BhcmFtLmlkXSwgZnJvbVBhcmFtc1twYXJhbS5pZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2FsbGJhY2sgaWYgYSB0byBwYXJhbSBoYXMgY2hhbmdlZCBvciBpcyBuZXdcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkVG9QYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRLZXlzXzEgPSBjaGFuZ2VkVG9QYXJhbXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHBhcmFtcyB0byBvbmx5IGNoYW5nZWQvbmV3IHRvIHBhcmFtcy4gIGAkdHJhbnNpdGlvbiQucGFyYW1zKClgIG1heSBiZSB1c2VkIHRvIGdldCBhbGwgcGFyYW1zLlxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSBjb3JlXzEuZmlsdGVyKHRvUGFyYW1zLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIGNoYW5nZWRLZXlzXzEuaW5kZXhPZihrZXkpICE9PSAtMTsgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKG5ld1ZhbHVlcywgJHRyYW5zaXRpb24kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHt9LCBwYXJhbXNVcGRhdGVkLCBob29rT3B0aW9ucykpO1xuICAgIH1cbiAgICAvLyBBZGQgY29tcG9uZW50LWxldmVsIGhvb2sgZm9yIHVpQ2FuRXhpdFxuICAgIGlmIChjb3JlXzEuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UudWlDYW5FeGl0KSkge1xuICAgICAgICB2YXIgaWRfMSA9IF91aUNhbkV4aXRJZCsrO1xuICAgICAgICB2YXIgY2FjaGVQcm9wXzEgPSAnX3VpQ2FuRXhpdElkcyc7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHJlZGlyZWN0IHRyYW5zaXRpb24gYWxyZWFkeSBhbnN3ZXJlZCB0cnV0aHlcbiAgICAgICAgdmFyIHByZXZUcnV0aHlBbnN3ZXJfMSA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgcmV0dXJuICEhdHJhbnMgJiYgKHRyYW5zW2NhY2hlUHJvcF8xXSAmJiB0cmFuc1tjYWNoZVByb3BfMV1baWRfMV0gPT09IHRydWUgfHwgcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGFuc3dlcmVkIHllcywgYnV0IHRoZSB0cmFuc2l0aW9uIHdhcyBsYXRlciByZWRpcmVjdGVkLCBkb24ndCBhbHNvIGFzayBmb3IgdGhlIG5ldyByZWRpcmVjdCB0cmFuc2l0aW9uXG4gICAgICAgIHZhciB3cmFwcGVkSG9vayA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgdmFyIHByb21pc2UsIGlkcyA9IHRyYW5zW2NhY2hlUHJvcF8xXSA9IHRyYW5zW2NhY2hlUHJvcF8xXSB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQodHJhbnMpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gaWRzW2lkXzFdID0gKHZhbCAhPT0gZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSB7IGV4aXRpbmc6IHZpZXdTdGF0ZS5uYW1lIH07XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgJHRyYW5zaXRpb25zLm9uQmVmb3JlKGNyaXRlcmlhLCB3cmFwcGVkSG9vaywgaG9va09wdGlvbnMpKTtcbiAgICB9XG59XG5hbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIGV4cG9ydHMudWlWaWV3KTtcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgJFZpZXdEaXJlY3RpdmVGaWxsKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdEaXJlY3RpdmUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/directives/viewDirective.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nexports.core = core;\n__export(__webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\"));\n__export(__webpack_require__(/*! ./services */ \"./node_modules/angular-ui-router/lib/services.js\"));\n__export(__webpack_require__(/*! ./statebuilders/views */ \"./node_modules/angular-ui-router/lib/statebuilders/views.js\"));\n__export(__webpack_require__(/*! ./stateProvider */ \"./node_modules/angular-ui-router/lib/stateProvider.js\"));\n__export(__webpack_require__(/*! ./urlRouterProvider */ \"./node_modules/angular-ui-router/lib/urlRouterProvider.js\"));\n__webpack_require__(/*! ./injectables */ \"./node_modules/angular-ui-router/lib/injectables.js\");\n__webpack_require__(/*! ./directives/stateDirectives */ \"./node_modules/angular-ui-router/lib/directives/stateDirectives.js\");\n__webpack_require__(/*! ./stateFilters */ \"./node_modules/angular-ui-router/lib/stateFilters.js\");\n__webpack_require__(/*! ./directives/viewDirective */ \"./node_modules/angular-ui-router/lib/directives/viewDirective.js\");\n__webpack_require__(/*! ./viewScroll */ \"./node_modules/angular-ui-router/lib/viewScroll.js\");\nexports.default = \"ui.router\";\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktcm91dGVyL2xpYi9pbmRleC5qcz9mYTI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciBhbmd1bGFyIDEueCBidWlsZFxuICogQG1vZHVsZSBuZzFcbiAqLyAvKiogKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcbmV4cG9ydHMuY29yZSA9IGNvcmU7XG5fX2V4cG9ydChyZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc2VydmljZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVidWlsZGVycy92aWV3c1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVByb3ZpZGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJvdXRlclByb3ZpZGVyXCIpKTtcbnJlcXVpcmUoXCIuL2luamVjdGFibGVzXCIpO1xucmVxdWlyZShcIi4vZGlyZWN0aXZlcy9zdGF0ZURpcmVjdGl2ZXNcIik7XG5yZXF1aXJlKFwiLi9zdGF0ZUZpbHRlcnNcIik7XG5yZXF1aXJlKFwiLi9kaXJlY3RpdmVzL3ZpZXdEaXJlY3RpdmVcIik7XG5yZXF1aXJlKFwiLi92aWV3U2Nyb2xsXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gXCJ1aS5yb3V0ZXJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/index.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/injectables.js":
/*!***********************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/injectables.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * # Angular 1 injectable services\n *\n * This is a list of the objects which can be injected using angular's injector.\n *\n * There are three different kind of injectable objects:\n *\n * ## **Provider** objects\n * #### injectable into a `.config()` block during configtime\n *\n * - [[$uiRouterProvider]]: The UI-Router instance\n * - [[$stateProvider]]: State registration\n * - [[$transitionsProvider]]: Transition hooks\n * - [[$urlServiceProvider]]: All URL related public APIs\n *\n * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n *\n * ## **Service** objects\n * #### injectable globally during runtime\n *\n * - [[$uiRouter]]: The UI-Router instance\n * - [[$trace]]: Enable transition trace/debug\n * - [[$transitions]]: Transition hooks\n * - [[$state]]: Imperative state related APIs\n * - [[$stateRegistry]]: State registration\n * - [[$urlService]]: All URL related public APIs\n * - [[$uiRouterGlobals]]: Global variables\n * - [[$uiViewScroll]]: Scroll an element into view\n *\n * - [[$stateParams]]: (deprecated) Global state param values\n * - [[$urlRouter]]: (deprecated) URL synchronization\n * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n *\n * ## **Per-Transition** objects\n *\n * - These kind of objects are injectable into:\n *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n *   - Transition Hooks ([[TransitionService.onStart]], etc),\n *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n *\n * #### Different instances are injected based on the [[Transition]]\n *\n * - [[$transition$]]: The current Transition object\n * - [[$stateParams]]: State param values for pending Transition (deprecated)\n * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n *\n * @ng1api\n * @preferred\n * @module injectables\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\nvar $stateParams;\n/**\n * Global UI-Router variables\n *\n * The router global state as a **Service Object** (injectable during runtime).\n *\n * This object contains globals such as the current state and current parameter values.\n */\nvar $uiRouterGlobals;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Service Object** (injectable during runtime).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouterProvider]] for injection during angular config time.\n */\nvar $uiRouter;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Provider Object** (injectable during config phase).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouter]] for injection during runtime.\n */\nvar $uiRouterProvider;\n/**\n * Transition debug/tracing\n *\n * The [[Trace]] singleton as a **Service Object** (injectable during runtime).\n *\n * Enables or disables Transition tracing which can help to debug issues.\n */\nvar $trace;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitionsProvider]] for injection during the config phase.\n */\nvar $transitions;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Provider Object** (injectable during config phase)\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitions]] for injection during runtime.\n */\nvar $transitionsProvider;\n/**\n * The current [[Transition]] object\n *\n * The current [[Transition]] object as a **Per-Transition Object** (injectable into Resolve, Hooks, Controllers)\n *\n * This object returns information about the current transition, including:\n *\n * - To/from states\n * - To/from parameters\n * - Transition options\n * - States being entered, exited, and retained\n * - Resolve data\n * - A Promise for the transition\n * - Any transition failure information\n * - An injector for both Service and Per-Transition Objects\n */\nvar $transition$;\n/**\n * The State Service\n *\n * The [[StateService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service used to manage and query information on registered states.\n * It exposes state related APIs including:\n *\n * - Start a [[Transition]]\n * - Imperatively lazy load states\n * - Check if a state is currently active\n * - Look up states by name\n * - Build URLs for a state+parameters\n * - Configure the global Transition error handler\n *\n * This angular service exposes the [[StateService]] singleton.\n */\nvar $state;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistryProvider]] for injection during the config phase.\n */\nvar $stateRegistry;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistry]] for injection during runtime.\n */\nvar $stateRegistryProvider;\n/**\n * The View Scroll provider\n *\n * The [[UIViewScrollProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[UIViewScrollProvider]] singleton and is\n * used to disable UI-Router's scroll behavior.\n */\nvar $uiViewScrollProvider;\n/**\n * The View Scroll function\n *\n * The View Scroll function as a **Service Object** (injectable during runtime).\n *\n * This is a function that scrolls an element into view.\n * The element is scrolled after a `$timeout` so the DOM has time to refresh.\n *\n * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n * this can be enabled by calling [[UIViewScrollProvider.useAnchorScroll]].\n *\n * Note: this function is used by the [[directives.uiView]] when the `autoscroll` expression evaluates to true.\n */\nvar $uiViewScroll;\n/**\n * The StateProvider\n *\n * An angular1-only [[StateProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[StateProvider]] singleton.\n *\n * The `StateProvider` is primarily used to register states or add custom state decorators.\n *\n * ##### Note: This provider is a ng1 vestige.\n * It is a passthrough to [[$stateRegistry]] and [[$state]].\n */\nvar $stateProvider;\n/**\n * The URL Service Provider\n *\n * The [[UrlService]] singleton as a **Provider Object** (injectable during the angular config phase).\n *\n * A service used to configure and interact with the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during runtime as [[$urlService]].\n */\nvar $urlServiceProvider;\n/**\n * The URL Service\n *\n * The [[UrlService]] singleton as a **Service Object** (injectable during runtime).\n *\n * Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n *\n * Used to configure the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n */\nvar $urlService;\n/**\n * The URL Router Provider\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlServiceProvider]] instead.\n *\n * The [[UrlRouter]] singleton as a **Provider Object** (injectable during config time).\n *\n * #### Note: This object is also exposed as [[$urlRouter]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlRouterProvider;\n/**\n * The Url Router\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlRouter]] singleton as a **Service Object** (injectable during runtime).\n *\n * #### Note: This object is also exposed as [[$urlRouterProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlRouter;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactoryProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlMatcherFactory;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactory]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlMatcherFactoryProvider;\n//# sourceMappingURL=injectables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2luamVjdGFibGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktcm91dGVyL2xpYi9pbmplY3RhYmxlcy5qcz9jNTdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAjIEFuZ3VsYXIgMSBpbmplY3RhYmxlIHNlcnZpY2VzXG4gKlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgdGhlIG9iamVjdHMgd2hpY2ggY2FuIGJlIGluamVjdGVkIHVzaW5nIGFuZ3VsYXIncyBpbmplY3Rvci5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgZGlmZmVyZW50IGtpbmQgb2YgaW5qZWN0YWJsZSBvYmplY3RzOlxuICpcbiAqICMjICoqUHJvdmlkZXIqKiBvYmplY3RzXG4gKiAjIyMjIGluamVjdGFibGUgaW50byBhIGAuY29uZmlnKClgIGJsb2NrIGR1cmluZyBjb25maWd0aW1lXG4gKlxuICogLSBbWyR1aVJvdXRlclByb3ZpZGVyXV06IFRoZSBVSS1Sb3V0ZXIgaW5zdGFuY2VcbiAqIC0gW1skc3RhdGVQcm92aWRlcl1dOiBTdGF0ZSByZWdpc3RyYXRpb25cbiAqIC0gW1skdHJhbnNpdGlvbnNQcm92aWRlcl1dOiBUcmFuc2l0aW9uIGhvb2tzXG4gKiAtIFtbJHVybFNlcnZpY2VQcm92aWRlcl1dOiBBbGwgVVJMIHJlbGF0ZWQgcHVibGljIEFQSXNcbiAqXG4gKiAtIFtbJHVpVmlld1Njcm9sbFByb3ZpZGVyXV06IERpc2FibGUgdWktcm91dGVyIHZpZXcgc2Nyb2xsaW5nXG4gKiAtIFtbJHVybFJvdXRlclByb3ZpZGVyXV06IChkZXByZWNhdGVkKSBVcmwgbWF0Y2hpbmcgcnVsZXNcbiAqIC0gW1skdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcl1dOiAoZGVwcmVjYXRlZCkgVXJsIHBhcnNpbmcgY29uZmlnXG4gKlxuICogIyMgKipTZXJ2aWNlKiogb2JqZWN0c1xuICogIyMjIyBpbmplY3RhYmxlIGdsb2JhbGx5IGR1cmluZyBydW50aW1lXG4gKlxuICogLSBbWyR1aVJvdXRlcl1dOiBUaGUgVUktUm91dGVyIGluc3RhbmNlXG4gKiAtIFtbJHRyYWNlXV06IEVuYWJsZSB0cmFuc2l0aW9uIHRyYWNlL2RlYnVnXG4gKiAtIFtbJHRyYW5zaXRpb25zXV06IFRyYW5zaXRpb24gaG9va3NcbiAqIC0gW1skc3RhdGVdXTogSW1wZXJhdGl2ZSBzdGF0ZSByZWxhdGVkIEFQSXNcbiAqIC0gW1skc3RhdGVSZWdpc3RyeV1dOiBTdGF0ZSByZWdpc3RyYXRpb25cbiAqIC0gW1skdXJsU2VydmljZV1dOiBBbGwgVVJMIHJlbGF0ZWQgcHVibGljIEFQSXNcbiAqIC0gW1skdWlSb3V0ZXJHbG9iYWxzXV06IEdsb2JhbCB2YXJpYWJsZXNcbiAqIC0gW1skdWlWaWV3U2Nyb2xsXV06IFNjcm9sbCBhbiBlbGVtZW50IGludG8gdmlld1xuICpcbiAqIC0gW1skc3RhdGVQYXJhbXNdXTogKGRlcHJlY2F0ZWQpIEdsb2JhbCBzdGF0ZSBwYXJhbSB2YWx1ZXNcbiAqIC0gW1skdXJsUm91dGVyXV06IChkZXByZWNhdGVkKSBVUkwgc3luY2hyb25pemF0aW9uXG4gKiAtIFtbJHVybE1hdGNoZXJGYWN0b3J5XV06IChkZXByZWNhdGVkKSBVUkwgcGFyc2luZyBjb25maWdcbiAqXG4gKiAjIyAqKlBlci1UcmFuc2l0aW9uKiogb2JqZWN0c1xuICpcbiAqIC0gVGhlc2Uga2luZCBvZiBvYmplY3RzIGFyZSBpbmplY3RhYmxlIGludG86XG4gKiAgIC0gUmVzb2x2ZXMgKFtbTmcxU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0pLFxuICogICAtIFRyYW5zaXRpb24gSG9va3MgKFtbVHJhbnNpdGlvblNlcnZpY2Uub25TdGFydF1dLCBldGMpLFxuICogICAtIFJvdXRlZCBDb250cm9sbGVycyAoW1tOZzFWaWV3RGVjbGFyYXRpb24uY29udHJvbGxlcl1dKVxuICpcbiAqICMjIyMgRGlmZmVyZW50IGluc3RhbmNlcyBhcmUgaW5qZWN0ZWQgYmFzZWQgb24gdGhlIFtbVHJhbnNpdGlvbl1dXG4gKlxuICogLSBbWyR0cmFuc2l0aW9uJF1dOiBUaGUgY3VycmVudCBUcmFuc2l0aW9uIG9iamVjdFxuICogLSBbWyRzdGF0ZVBhcmFtc11dOiBTdGF0ZSBwYXJhbSB2YWx1ZXMgZm9yIHBlbmRpbmcgVHJhbnNpdGlvbiAoZGVwcmVjYXRlZClcbiAqIC0gQW55IHJlc29sdmUgZGF0YSBkZWZpbmVkIHVzaW5nIFtbTmcxU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqXG4gKiBAbmcxYXBpXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIGluamVjdGFibGVzXG4gKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRoZSBjdXJyZW50IChvciBwZW5kaW5nKSBTdGF0ZSBQYXJhbWV0ZXJzXG4gKlxuICogQW4gaW5qZWN0YWJsZSBnbG9iYWwgKipTZXJ2aWNlIE9iamVjdCoqIHdoaWNoIGhvbGRzIHRoZSBzdGF0ZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGF0ZXN0ICoqU1VDQ0VTU0ZVTCoqIHRyYW5zaXRpb24uXG4gKlxuICogVGhlIHZhbHVlcyBhcmUgbm90IHVwZGF0ZWQgdW50aWwgKmFmdGVyKiBhIGBUcmFuc2l0aW9uYCBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICpcbiAqICoqQWxzbzoqKiBhbiBpbmplY3RhYmxlICoqUGVyLVRyYW5zaXRpb24gT2JqZWN0Kiogb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSBwZW5kaW5nIHN0YXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBwZW5kaW5nIGBUcmFuc2l0aW9uYCBjdXJyZW50bHkgcnVubmluZy5cbiAqXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzpcbiAqXG4gKiBUaGUgdmFsdWUgaW5qZWN0ZWQgZm9yIGAkc3RhdGVQYXJhbXNgIGlzIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hlcmUgaXQgaXMgaW5qZWN0ZWQuXG4gKlxuICogLSBXaGVuIGluamVjdGVkIGludG8gYW4gYW5ndWxhciBzZXJ2aWNlLCB0aGUgb2JqZWN0IGluamVjdGVkIGlzIHRoZSBnbG9iYWwgKipTZXJ2aWNlIE9iamVjdCoqIHdpdGggdGhlIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCBgVHJhbnNpdGlvbmAuXG4gKiAtIFdoZW4gaW5qZWN0ZWQgaW50byB0cmFuc2l0aW9uIGhvb2tzLCByZXNvbHZlcywgb3IgdmlldyBjb250cm9sbGVycywgdGhlIG9iamVjdCBpcyB0aGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiB3aXRoIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgcnVubmluZyBgVHJhbnNpdGlvbmAuXG4gKlxuICogQmVjYXVzZSBvZiB0aGVzZSBjb25mdXNpbmcgZGV0YWlscywgdGhpcyBzZXJ2aWNlIGlzIGRlcHJlY2F0ZWQuXG4gKlxuICogIyMjIEluc3RlYWQgb2YgdXNpbmcgdGhlIGdsb2JhbCBgJHN0YXRlUGFyYW1zYCBzZXJ2aWNlIG9iamVjdCxcbiAqIGluamVjdCBbWyR1aVJvdXRlckdsb2JhbHNdXSBhbmQgdXNlIFtbVUlSb3V0ZXJHbG9iYWxzLnBhcmFtc11dXG4gKlxuICogYGBganNcbiAqIE15U2VydmljZS4kaW5qZWN0ID0gWyckdWlSb3V0ZXJHbG9iYWxzJ107XG4gKiBmdW5jdGlvbiBNeVNlcnZpY2UoJHVpUm91dGVyR2xvYmFscykge1xuICogICByZXR1cm4ge1xuICogICAgIHBhcmFtVmFsdWVzOiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gJHVpUm91dGVyR2xvYmFscy5wYXJhbXM7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgcGVyLXRyYW5zaXRpb24gYCRzdGF0ZVBhcmFtc2Agb2JqZWN0LFxuICogaW5qZWN0IHRoZSBjdXJyZW50IGBUcmFuc2l0aW9uYCAoYXMgW1skdHJhbnNpdGlvbiRdXSkgYW5kIHVzZSBbW1RyYW5zaXRpb24ucGFyYW1zXV1cbiAqXG4gKiBgYGBqc1xuICogTXlDb250cm9sbGVyLiRpbmplY3QgPSBbJyR0cmFuc2l0aW9uJCddO1xuICogZnVuY3Rpb24gTXlDb250cm9sbGVyKCR0cmFuc2l0aW9uJCkge1xuICogICB2YXIgdXNlcm5hbWUgPSAkdHJhbnNpdGlvbiQucGFyYW1zKCkudXNlcm5hbWU7XG4gKiAgIC8vIC4uIGRvIHNvbWV0aGluZyB3aXRoIHVzZXJuYW1lXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGlzIG9iamVjdCBjYW4gYmUgaW5qZWN0ZWQgaW50byBvdGhlciBzZXJ2aWNlcy5cbiAqXG4gKiAjIyMjIERlcHJlY2F0ZWQgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBTb21lU2VydmljZS4kaW5qZWN0ID0gWyckaHR0cCcsICckc3RhdGVQYXJhbXMnXTtcbiAqIGZ1bmN0aW9uIFNvbWVTZXJ2aWNlKCRodHRwLCAkc3RhdGVQYXJhbXMpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBnZXRVc2VyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAkaHR0cC5nZXQoJy9hcGkvdXNlcnMvJyArICRzdGF0ZVBhcmFtcy51c2VybmFtZSk7XG4gKiAgICAgfVxuICogICB9XG4gKiB9O1xuICogYW5ndWxhci5zZXJ2aWNlKCdTb21lU2VydmljZScsIFNvbWVTZXJ2aWNlKTtcbiAqIGBgYFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyICRzdGF0ZVBhcmFtcztcbi8qKlxuICogR2xvYmFsIFVJLVJvdXRlciB2YXJpYWJsZXNcbiAqXG4gKiBUaGUgcm91dGVyIGdsb2JhbCBzdGF0ZSBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXG4gKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgZ2xvYmFscyBzdWNoIGFzIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMuXG4gKi9cbnZhciAkdWlSb3V0ZXJHbG9iYWxzO1xuLyoqXG4gKiBUaGUgVUktUm91dGVyIGluc3RhbmNlXG4gKlxuICogVGhlIFtbVUlSb3V0ZXJdXSBzaW5nbGV0b24gKHRoZSByb3V0ZXIgaW5zdGFuY2UpIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cbiAqXG4gKiBUaGlzIG9iamVjdCBpcyB0aGUgVUktUm91dGVyIHNpbmdsZXRvbiBpbnN0YW5jZSwgY3JlYXRlZCBieSBhbmd1bGFyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGR1cmluZyBhcHBsaWNhdGlvbiBib290c3RyYXAuXG4gKiBJdCBoYXMgcmVmZXJlbmNlcyB0byB0aGUgb3RoZXIgVUktUm91dGVyIHNlcnZpY2VzXG4gKlxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdWlSb3V0ZXJQcm92aWRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIGFuZ3VsYXIgY29uZmlnIHRpbWUuXG4gKi9cbnZhciAkdWlSb3V0ZXI7XG4vKipcbiAqIFRoZSBVSS1Sb3V0ZXIgaW5zdGFuY2VcbiAqXG4gKiBUaGUgW1tVSVJvdXRlcl1dIHNpbmdsZXRvbiAodGhlIHJvdXRlciBpbnN0YW5jZSkgYXMgYSAqKlByb3ZpZGVyIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBjb25maWcgcGhhc2UpLlxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIHRoZSBVSS1Sb3V0ZXIgc2luZ2xldG9uIGluc3RhbmNlLCBjcmVhdGVkIGJ5IGFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gZHVyaW5nIGFwcGxpY2F0aW9uIGJvb3RzdHJhcC5cbiAqIEl0IGhhcyByZWZlcmVuY2VzIHRvIHRoZSBvdGhlciBVSS1Sb3V0ZXIgc2VydmljZXNcbiAqXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR1aVJvdXRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIHJ1bnRpbWUuXG4gKi9cbnZhciAkdWlSb3V0ZXJQcm92aWRlcjtcbi8qKlxuICogVHJhbnNpdGlvbiBkZWJ1Zy90cmFjaW5nXG4gKlxuICogVGhlIFtbVHJhY2VdXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxuICpcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgVHJhbnNpdGlvbiB0cmFjaW5nIHdoaWNoIGNhbiBoZWxwIHRvIGRlYnVnIGlzc3Vlcy5cbiAqL1xudmFyICR0cmFjZTtcbi8qKlxuICogVGhlIFRyYW5zaXRpb24gU2VydmljZVxuICpcbiAqIFRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gc2luZ2xldG9uIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cbiAqXG4gKiBUaGlzIGFuZ3VsYXIgc2VydmljZSBleHBvc2VzIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gc2luZ2xldG9uLCB3aGljaCBpcyBwcmltYXJpbHlcbiAqIHVzZWQgdG8gcmVnaXN0ZXIgZ2xvYmFsIHRyYW5zaXRpb24gaG9va3MuXG4gKlxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdHJhbnNpdGlvbnNQcm92aWRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIHRoZSBjb25maWcgcGhhc2UuXG4gKi9cbnZhciAkdHJhbnNpdGlvbnM7XG4vKipcbiAqIFRoZSBUcmFuc2l0aW9uIFNlcnZpY2VcbiAqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU2VydmljZV1dIHNpbmdsZXRvbiBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIGNvbmZpZyBwaGFzZSlcbiAqXG4gKiBUaGlzIGFuZ3VsYXIgc2VydmljZSBleHBvc2VzIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gc2luZ2xldG9uLCB3aGljaCBpcyBwcmltYXJpbHlcbiAqIHVzZWQgdG8gcmVnaXN0ZXIgZ2xvYmFsIHRyYW5zaXRpb24gaG9va3MuXG4gKlxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdHJhbnNpdGlvbnNdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxuICovXG52YXIgJHRyYW5zaXRpb25zUHJvdmlkZXI7XG4vKipcbiAqIFRoZSBjdXJyZW50IFtbVHJhbnNpdGlvbl1dIG9iamVjdFxuICpcbiAqIFRoZSBjdXJyZW50IFtbVHJhbnNpdGlvbl1dIG9iamVjdCBhcyBhICoqUGVyLVRyYW5zaXRpb24gT2JqZWN0KiogKGluamVjdGFibGUgaW50byBSZXNvbHZlLCBIb29rcywgQ29udHJvbGxlcnMpXG4gKlxuICogVGhpcyBvYmplY3QgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCB0cmFuc2l0aW9uLCBpbmNsdWRpbmc6XG4gKlxuICogLSBUby9mcm9tIHN0YXRlc1xuICogLSBUby9mcm9tIHBhcmFtZXRlcnNcbiAqIC0gVHJhbnNpdGlvbiBvcHRpb25zXG4gKiAtIFN0YXRlcyBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIGFuZCByZXRhaW5lZFxuICogLSBSZXNvbHZlIGRhdGFcbiAqIC0gQSBQcm9taXNlIGZvciB0aGUgdHJhbnNpdGlvblxuICogLSBBbnkgdHJhbnNpdGlvbiBmYWlsdXJlIGluZm9ybWF0aW9uXG4gKiAtIEFuIGluamVjdG9yIGZvciBib3RoIFNlcnZpY2UgYW5kIFBlci1UcmFuc2l0aW9uIE9iamVjdHNcbiAqL1xudmFyICR0cmFuc2l0aW9uJDtcbi8qKlxuICogVGhlIFN0YXRlIFNlcnZpY2VcbiAqXG4gKiBUaGUgW1tTdGF0ZVNlcnZpY2VdXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxuICpcbiAqIFRoaXMgc2VydmljZSB1c2VkIHRvIG1hbmFnZSBhbmQgcXVlcnkgaW5mb3JtYXRpb24gb24gcmVnaXN0ZXJlZCBzdGF0ZXMuXG4gKiBJdCBleHBvc2VzIHN0YXRlIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSBTdGFydCBhIFtbVHJhbnNpdGlvbl1dXG4gKiAtIEltcGVyYXRpdmVseSBsYXp5IGxvYWQgc3RhdGVzXG4gKiAtIENoZWNrIGlmIGEgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZVxuICogLSBMb29rIHVwIHN0YXRlcyBieSBuYW1lXG4gKiAtIEJ1aWxkIFVSTHMgZm9yIGEgc3RhdGUrcGFyYW1ldGVyc1xuICogLSBDb25maWd1cmUgdGhlIGdsb2JhbCBUcmFuc2l0aW9uIGVycm9yIGhhbmRsZXJcbiAqXG4gKiBUaGlzIGFuZ3VsYXIgc2VydmljZSBleHBvc2VzIHRoZSBbW1N0YXRlU2VydmljZV1dIHNpbmdsZXRvbi5cbiAqL1xudmFyICRzdGF0ZTtcbi8qKlxuICogVGhlIFN0YXRlIFJlZ2lzdHJ5XG4gKlxuICogVGhlIFtbU3RhdGVSZWdpc3RyeV1dIHNpbmdsZXRvbiBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGlzIHVzZWQgdG8gcmVnaXN0ZXIvZGVyZWdpc3RlciBzdGF0ZXMuXG4gKiBJdCBoYXMgc3RhdGUgcmVnaXN0cmF0aW9uIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSBSZWdpc3Rlci9kZXJlZ2lzdGVyIHN0YXRlc1xuICogLSBMaXN0ZW4gZm9yIHN0YXRlIHJlZ2lzdHJhdGlvbi9kZXJlZ2lzdHJhdGlvblxuICogLSBHZXQgc3RhdGVzIGJ5IG5hbWVcbiAqIC0gQWRkIHN0YXRlIGRlY29yYXRvcnMgKHRvIGN1c3RvbWl6ZSB0aGUgc3RhdGUgY3JlYXRpb24gcHJvY2VzcylcbiAqXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyRzdGF0ZVJlZ2lzdHJ5UHJvdmlkZXJdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyB0aGUgY29uZmlnIHBoYXNlLlxuICovXG52YXIgJHN0YXRlUmVnaXN0cnk7XG4vKipcbiAqIFRoZSBTdGF0ZSBSZWdpc3RyeVxuICpcbiAqIFRoZSBbW1N0YXRlUmVnaXN0cnldXSBzaW5nbGV0b24gYXMgYSAqKlByb3ZpZGVyIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBjb25maWcgdGltZSkuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGlzIHVzZWQgdG8gcmVnaXN0ZXIvZGVyZWdpc3RlciBzdGF0ZXMuXG4gKiBJdCBoYXMgc3RhdGUgcmVnaXN0cmF0aW9uIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSBSZWdpc3Rlci9kZXJlZ2lzdGVyIHN0YXRlc1xuICogLSBMaXN0ZW4gZm9yIHN0YXRlIHJlZ2lzdHJhdGlvbi9kZXJlZ2lzdHJhdGlvblxuICogLSBHZXQgc3RhdGVzIGJ5IG5hbWVcbiAqIC0gQWRkIHN0YXRlIGRlY29yYXRvcnMgKHRvIGN1c3RvbWl6ZSB0aGUgc3RhdGUgY3JlYXRpb24gcHJvY2VzcylcbiAqXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyRzdGF0ZVJlZ2lzdHJ5XV0gZm9yIGluamVjdGlvbiBkdXJpbmcgcnVudGltZS5cbiAqL1xudmFyICRzdGF0ZVJlZ2lzdHJ5UHJvdmlkZXI7XG4vKipcbiAqIFRoZSBWaWV3IFNjcm9sbCBwcm92aWRlclxuICpcbiAqIFRoZSBbW1VJVmlld1Njcm9sbFByb3ZpZGVyXV0gYXMgYSAqKlByb3ZpZGVyIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBjb25maWcgdGltZSkuXG4gKlxuICogVGhpcyBhbmd1bGFyIHNlcnZpY2UgZXhwb3NlcyB0aGUgW1tVSVZpZXdTY3JvbGxQcm92aWRlcl1dIHNpbmdsZXRvbiBhbmQgaXNcbiAqIHVzZWQgdG8gZGlzYWJsZSBVSS1Sb3V0ZXIncyBzY3JvbGwgYmVoYXZpb3IuXG4gKi9cbnZhciAkdWlWaWV3U2Nyb2xsUHJvdmlkZXI7XG4vKipcbiAqIFRoZSBWaWV3IFNjcm9sbCBmdW5jdGlvblxuICpcbiAqIFRoZSBWaWV3IFNjcm9sbCBmdW5jdGlvbiBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXG4gKlxuICogVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgc2Nyb2xscyBhbiBlbGVtZW50IGludG8gdmlldy5cbiAqIFRoZSBlbGVtZW50IGlzIHNjcm9sbGVkIGFmdGVyIGEgYCR0aW1lb3V0YCBzbyB0aGUgRE9NIGhhcyB0aW1lIHRvIHJlZnJlc2guXG4gKlxuICogSWYgeW91IHByZWZlciB0byByZWx5IG9uIGAkYW5jaG9yU2Nyb2xsYCB0byBzY3JvbGwgdGhlIHZpZXcgdG8gdGhlIGFuY2hvcixcbiAqIHRoaXMgY2FuIGJlIGVuYWJsZWQgYnkgY2FsbGluZyBbW1VJVmlld1Njcm9sbFByb3ZpZGVyLnVzZUFuY2hvclNjcm9sbF1dLlxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgW1tkaXJlY3RpdmVzLnVpVmlld11dIHdoZW4gdGhlIGBhdXRvc2Nyb2xsYCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLlxuICovXG52YXIgJHVpVmlld1Njcm9sbDtcbi8qKlxuICogVGhlIFN0YXRlUHJvdmlkZXJcbiAqXG4gKiBBbiBhbmd1bGFyMS1vbmx5IFtbU3RhdGVQcm92aWRlcl1dIGFzIGEgKipQcm92aWRlciBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgY29uZmlnIHRpbWUpLlxuICpcbiAqIFRoaXMgYW5ndWxhciBzZXJ2aWNlIGV4cG9zZXMgdGhlIFtbU3RhdGVQcm92aWRlcl1dIHNpbmdsZXRvbi5cbiAqXG4gKiBUaGUgYFN0YXRlUHJvdmlkZXJgIGlzIHByaW1hcmlseSB1c2VkIHRvIHJlZ2lzdGVyIHN0YXRlcyBvciBhZGQgY3VzdG9tIHN0YXRlIGRlY29yYXRvcnMuXG4gKlxuICogIyMjIyMgTm90ZTogVGhpcyBwcm92aWRlciBpcyBhIG5nMSB2ZXN0aWdlLlxuICogSXQgaXMgYSBwYXNzdGhyb3VnaCB0byBbWyRzdGF0ZVJlZ2lzdHJ5XV0gYW5kIFtbJHN0YXRlXV0uXG4gKi9cbnZhciAkc3RhdGVQcm92aWRlcjtcbi8qKlxuICogVGhlIFVSTCBTZXJ2aWNlIFByb3ZpZGVyXG4gKlxuICogVGhlIFtbVXJsU2VydmljZV1dIHNpbmdsZXRvbiBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHRoZSBhbmd1bGFyIGNvbmZpZyBwaGFzZSkuXG4gKlxuICogQSBzZXJ2aWNlIHVzZWQgdG8gY29uZmlndXJlIGFuZCBpbnRlcmFjdCB3aXRoIHRoZSBVUkwuXG4gKiBJdCBoYXMgVVJMIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSByZWdpc3RlciBjdXN0b20gUGFyYW1ldGVyIHR5cGVzIGBVcmxTZXJ2aWNlLmNvbmZpZy50eXBlYCAoW1tVcmxDb25maWdBcGkudHlwZV1dKVxuICogLSBhZGQgVVJMIHJ1bGVzOiBgVXJsU2VydmljZS5ydWxlcy53aGVuYCAoW1tVcmxSdWxlc0FwaS53aGVuXV0pXG4gKiAtIGNvbmZpZ3VyZSBiZWhhdmlvciB3aGVuIG5vIHVybCBtYXRjaGVzOiBgVXJsU2VydmljZS5ydWxlcy5vdGhlcndpc2VgIChbW1VybFJ1bGVzQXBpLm90aGVyd2lzZV1dKVxuICogLSBkZWxheSBpbml0aWFsIFVSTCBzeW5jaHJvbml6YXRpb24gW1tVcmxTZXJ2aWNlLmRlZmVySW50ZXJjZXB0XV0uXG4gKiAtIGdldCBvciBzZXQgdGhlIGN1cnJlbnQgdXJsOiBbW1VybFNlcnZpY2UudXJsXV1cbiAqXG4gKiAjIyMjIyBOb3RlOiBUaGlzIHNlcnZpY2UgY2FuIGFsc28gYmUgaW5qZWN0ZWQgZHVyaW5nIHJ1bnRpbWUgYXMgW1skdXJsU2VydmljZV1dLlxuICovXG52YXIgJHVybFNlcnZpY2VQcm92aWRlcjtcbi8qKlxuICogVGhlIFVSTCBTZXJ2aWNlXG4gKlxuICogVGhlIFtbVXJsU2VydmljZV1dIHNpbmdsZXRvbiBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXG4gKlxuICogTm90ZTogVGhpcyBzZXJ2aWNlIGNhbiBhbHNvIGJlIGluamVjdGVkIGR1cmluZyB0aGUgY29uZmlnIHBoYXNlIGFzIFtbJHVybFNlcnZpY2VQcm92aWRlcl1dLlxuICpcbiAqIFVzZWQgdG8gY29uZmlndXJlIHRoZSBVUkwuXG4gKiBJdCBoYXMgVVJMIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSByZWdpc3RlciBjdXN0b20gUGFyYW1ldGVyIHR5cGVzIGBVcmxTZXJ2aWNlLmNvbmZpZy50eXBlYCAoW1tVcmxDb25maWdBcGkudHlwZV1dKVxuICogLSBhZGQgVVJMIHJ1bGVzOiBgVXJsU2VydmljZS5ydWxlcy53aGVuYCAoW1tVcmxSdWxlc0FwaS53aGVuXV0pXG4gKiAtIGNvbmZpZ3VyZSBiZWhhdmlvciB3aGVuIG5vIHVybCBtYXRjaGVzOiBgVXJsU2VydmljZS5ydWxlcy5vdGhlcndpc2VgIChbW1VybFJ1bGVzQXBpLm90aGVyd2lzZV1dKVxuICogLSBkZWxheSBpbml0aWFsIFVSTCBzeW5jaHJvbml6YXRpb24gW1tVcmxTZXJ2aWNlLmRlZmVySW50ZXJjZXB0XV0uXG4gKiAtIGdldCBvciBzZXQgdGhlIGN1cnJlbnQgdXJsOiBbW1VybFNlcnZpY2UudXJsXV1cbiAqXG4gKiAjIyMjIyBOb3RlOiBUaGlzIHNlcnZpY2UgY2FuIGFsc28gYmUgaW5qZWN0ZWQgZHVyaW5nIHRoZSBjb25maWcgcGhhc2UgYXMgW1skdXJsU2VydmljZVByb3ZpZGVyXV0uXG4gKi9cbnZhciAkdXJsU2VydmljZTtcbi8qKlxuICogVGhlIFVSTCBSb3V0ZXIgUHJvdmlkZXJcbiAqXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzogVGhpcyBvYmplY3QgaXMgbm93IGNvbnNpZGVyZWQgaW50ZXJuYWwuIFVzZSBbWyR1cmxTZXJ2aWNlUHJvdmlkZXJdXSBpbnN0ZWFkLlxuICpcbiAqIFRoZSBbW1VybFJvdXRlcl1dIHNpbmdsZXRvbiBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIGNvbmZpZyB0aW1lKS5cbiAqXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR1cmxSb3V0ZXJdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciAkdXJsUm91dGVyUHJvdmlkZXI7XG4vKipcbiAqIFRoZSBVcmwgUm91dGVyXG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6IFRoaXMgb2JqZWN0IGlzIG5vdyBjb25zaWRlcmVkIGludGVybmFsLiBVc2UgW1skdXJsU2VydmljZV1dIGluc3RlYWQuXG4gKlxuICogVGhlIFtbVXJsUm91dGVyXV0gc2luZ2xldG9uIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cbiAqXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR1cmxSb3V0ZXJQcm92aWRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIGFuZ3VsYXIgY29uZmlnIHRpbWUuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyICR1cmxSb3V0ZXI7XG4vKipcbiAqIFRoZSBVUkwgTWF0Y2hlciBGYWN0b3J5XG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6IFRoaXMgb2JqZWN0IGlzIG5vdyBjb25zaWRlcmVkIGludGVybmFsLiBVc2UgW1skdXJsU2VydmljZV1dIGluc3RlYWQuXG4gKlxuICogVGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxuICpcbiAqIFRoaXMgc2VydmljZSBpcyB1c2VkIHRvIHNldCB1cmwgbWFwcGluZyBvcHRpb25zLCBkZWZpbmUgY3VzdG9tIHBhcmFtZXRlciB0eXBlcywgYW5kIGNyZWF0ZSBbW1VybE1hdGNoZXJdXSBvYmplY3RzLlxuICpcbiAqICMjIyMgTm90ZTogVGhpcyBvYmplY3QgaXMgYWxzbyBleHBvc2VkIGFzIFtbJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBhbmd1bGFyIGNvbmZpZyB0aW1lLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciAkdXJsTWF0Y2hlckZhY3Rvcnk7XG4vKipcbiAqIFRoZSBVUkwgTWF0Y2hlciBGYWN0b3J5XG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6IFRoaXMgb2JqZWN0IGlzIG5vdyBjb25zaWRlcmVkIGludGVybmFsLiBVc2UgW1skdXJsU2VydmljZV1dIGluc3RlYWQuXG4gKlxuICogVGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXSBzaW5nbGV0b24gYXMgYSAqKlByb3ZpZGVyIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBjb25maWcgdGltZSkuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGlzIHVzZWQgdG8gc2V0IHVybCBtYXBwaW5nIG9wdGlvbnMsIGRlZmluZSBjdXN0b20gcGFyYW1ldGVyIHR5cGVzLCBhbmQgY3JlYXRlIFtbVXJsTWF0Y2hlcl1dIG9iamVjdHMuXG4gKlxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdXJsTWF0Y2hlckZhY3RvcnldXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdGFibGVzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/injectables.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/locationServices.js":
/*!****************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/locationServices.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = core_1.val($locationProvider);\n        core_1.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return core_1.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = core_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (newUrl)\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = core_1.val($location);\n        var _browser = core_1.val($browser);\n        // Bind these LocationService functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n        // Bind these LocationConfig functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        core_1.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (val) {\n            return val != null ? val.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val;\n        };\n        pathType.decode = function (val) {\n            return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val;\n        };\n    };\n    return Ng1LocationServices;\n}());\nexports.Ng1LocationServices = Ng1LocationServices;\n//# sourceMappingURL=locationServices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2xvY2F0aW9uU2VydmljZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL2xvY2F0aW9uU2VydmljZXMuanM/ZDFlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG4vKipcbiAqIEltcGxlbWVudHMgVUktUm91dGVyIExvY2F0aW9uU2VydmljZXMgYW5kIExvY2F0aW9uQ29uZmlnIHVzaW5nIEFuZ3VsYXIgMSdzICRsb2NhdGlvbiBzZXJ2aWNlXG4gKi9cbnZhciBOZzFMb2NhdGlvblNlcnZpY2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZzFMb2NhdGlvblNlcnZpY2VzKCRsb2NhdGlvblByb3ZpZGVyKSB7XG4gICAgICAgIC8vIC5vbkNoYW5nZSgpIHJlZ2lzdHJ5XG4gICAgICAgIHRoaXMuX3VybExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLiRsb2NhdGlvblByb3ZpZGVyID0gJGxvY2F0aW9uUHJvdmlkZXI7XG4gICAgICAgIHZhciBfbHAgPSBjb3JlXzEudmFsKCRsb2NhdGlvblByb3ZpZGVyKTtcbiAgICAgICAgY29yZV8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9scCwgdGhpcywgX2xwLCBbJ2hhc2hQcmVmaXgnXSk7XG4gICAgfVxuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdXJsTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLnJlbW92ZUZyb20oX3RoaXMuX3VybExpc3RlbmVycykoY2FsbGJhY2spOyB9O1xuICAgIH07XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHRtbDVNb2RlID0gdGhpcy4kbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUoKTtcbiAgICAgICAgaHRtbDVNb2RlID0gY29yZV8xLmlzT2JqZWN0KGh0bWw1TW9kZSkgPyBodG1sNU1vZGUuZW5hYmxlZCA6IGh0bWw1TW9kZTtcbiAgICAgICAgcmV0dXJuIGh0bWw1TW9kZSAmJiB0aGlzLiRzbmlmZmVyLmhpc3Rvcnk7XG4gICAgfTtcbiAgICBOZzFMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3VXJsLCByZXBsYWNlLCBzdGF0ZSkge1xuICAgICAgICBpZiAocmVwbGFjZSA9PT0gdm9pZCAwKSB7IHJlcGxhY2UgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobmV3VXJsKVxuICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24udXJsKG5ld1VybCk7XG4gICAgICAgIGlmIChyZXBsYWNlKVxuICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgICAgICBpZiAoc3RhdGUpXG4gICAgICAgICAgICB0aGlzLiRsb2NhdGlvbi5zdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRsb2NhdGlvbi51cmwoKTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLl9ydW50aW1lU2VydmljZXMgPSBmdW5jdGlvbiAoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgICAgIHRoaXMuJHNuaWZmZXIgPSAkc25pZmZlcjtcbiAgICAgICAgLy8gQmluZCAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzIHRvIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiBMb2NhdGlvblNlcnZpY2Uub25DaGFuZ2VcbiAgICAgICAgJHJvb3RTY29wZS4kb24oXCIkbG9jYXRpb25DaGFuZ2VTdWNjZXNzXCIsIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLl91cmxMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKGV2dCk7IH0pOyB9KTtcbiAgICAgICAgdmFyIF9sb2MgPSBjb3JlXzEudmFsKCRsb2NhdGlvbik7XG4gICAgICAgIHZhciBfYnJvd3NlciA9IGNvcmVfMS52YWwoJGJyb3dzZXIpO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uU2VydmljZSBmdW5jdGlvbnMgdG8gJGxvY2F0aW9uXG4gICAgICAgIGNvcmVfMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhfbG9jLCB0aGlzLCBfbG9jLCBbXCJyZXBsYWNlXCIsIFwicGF0aFwiLCBcInNlYXJjaFwiLCBcImhhc2hcIl0pO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkbG9jYXRpb25cbiAgICAgICAgY29yZV8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0J10pO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkYnJvd3NlclxuICAgICAgICBjb3JlXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoX2Jyb3dzZXIsIHRoaXMsIF9icm93c2VyLCBbJ2Jhc2VIcmVmJ10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHlzIG5nMS1zcGVjaWZpYyBwYXRoIHBhcmFtZXRlciBlbmNvZGluZ1xuICAgICAqXG4gICAgICogVGhlIEFuZ3VsYXIgMSBgJGxvY2F0aW9uYCBzZXJ2aWNlIGlzIGEgYml0IHdlaXJkLlxuICAgICAqIEl0IGRvZXNuJ3QgYWxsb3cgc2xhc2hlcyB0byBiZSBlbmNvZGVkL2RlY29kZWQgYmktZGlyZWN0aW9uYWxseS5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUgd3JpdGV1cCBhdCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzI1OThcbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBwYXRjaGVzIHRoZSBgcGF0aGAgcGFyYW1ldGVyIHR5cGUgc28gaXQgZW5jb2RlZC9kZWNvZGVzIHNsYXNoZXMgYXMgfjJGXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm91dGVyXG4gICAgICovXG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICB2YXIgcGF0aFR5cGUgPSByb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkudHlwZSgncGF0aCcpO1xuICAgICAgICBwYXRoVHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwudG9TdHJpbmcoKS5yZXBsYWNlKC8ofnxcXC8pL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyAnfic6ICd+ficsICcvJzogJ34yRicgfVttXSk7IH0pIDogdmFsO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoVHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwudG9TdHJpbmcoKS5yZXBsYWNlKC8ofn58fjJGKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gKHsgJ35+JzogJ34nLCAnfjJGJzogJy8nIH1bbV0pOyB9KSA6IHZhbDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBOZzFMb2NhdGlvblNlcnZpY2VzO1xufSgpKTtcbmV4cG9ydHMuTmcxTG9jYXRpb25TZXJ2aWNlcyA9IE5nMUxvY2F0aW9uU2VydmljZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhdGlvblNlcnZpY2VzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/locationServices.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/services.js":
/*!********************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/services.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nvar angular_1 = __webpack_require__(/*! ./angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nvar views_1 = __webpack_require__(/*! ./statebuilders/views */ \"./node_modules/angular-ui-router/lib/statebuilders/views.js\");\nvar templateFactory_1 = __webpack_require__(/*! ./templateFactory */ \"./node_modules/angular-ui-router/lib/templateFactory.js\");\nvar stateProvider_1 = __webpack_require__(/*! ./stateProvider */ \"./node_modules/angular-ui-router/lib/stateProvider.js\");\nvar onEnterExitRetain_1 = __webpack_require__(/*! ./statebuilders/onEnterExitRetain */ \"./node_modules/angular-ui-router/lib/statebuilders/onEnterExitRetain.js\");\nvar locationServices_1 = __webpack_require__(/*! ./locationServices */ \"./node_modules/angular-ui-router/lib/locationServices.js\");\nvar urlRouterProvider_1 = __webpack_require__(/*! ./urlRouterProvider */ \"./node_modules/angular-ui-router/lib/urlRouterProvider.js\");\nangular_1.ng.module(\"ui.router.angular1\", []);\nvar mod_init = angular_1.ng.module('ui.router.init', []);\nvar mod_util = angular_1.ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = angular_1.ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = angular_1.ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = angular_1.ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = angular_1.ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new core_1.UIRouter();\n    router.stateProvider = new stateProvider_1.StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator(\"views\", views_1.ng1ViewsBuilder);\n    router.stateRegistry.decorator(\"onExit\", onEnterExitRetain_1.getStateHookBuilder(\"onExit\"));\n    router.stateRegistry.decorator(\"onRetain\", onEnterExitRetain_1.getStateHookBuilder(\"onRetain\"));\n    router.stateRegistry.decorator(\"onEnter\", onEnterExitRetain_1.getStateHookBuilder(\"onEnter\"));\n    router.viewService._pluginapi._viewConfigFactory('ng1', views_1.getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new locationServices_1.Ng1LocationServices($locationProvider);\n    locationServices_1.Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service[\"$get\"] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    core_1.services.$injector = $injector;\n    core_1.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(core_1.unnestR, [])\n        .filter(function (x) { return x.deps === \"deferred\"; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new urlRouterProvider_1.UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return core_1.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { core_1.trace.approximateDigests++; });\n}\nexports.watchDigests = watchDigests;\nmod_init.provider(\"$uiRouter\", $uiRouter);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new templateFactory_1.TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service(\"$trace\", function () { return core_1.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nexports.getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(core_1.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(core_1.applyPairs, {});\n};\n//# sourceMappingURL=services.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3NlcnZpY2VzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktcm91dGVyL2xpYi9zZXJ2aWNlcy5qcz85YmMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIEFuZ3VsYXIgMSB0eXBlc1xuICpcbiAqIFVJLVJvdXRlciBjb3JlIHByb3ZpZGVzIHZhcmlvdXMgVHlwZXNjcmlwdCB0eXBlcyB3aGljaCB5b3UgY2FuIHVzZSBmb3IgY29kZSBjb21wbGV0aW9uIGFuZCB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMsIGV0Yy5cbiAqIFRoZSBjdXN0b21pemF0aW9ucyB0byB0aGUgY29yZSB0eXBlcyBmb3IgQW5ndWxhciBVSS1Sb3V0ZXIgYXJlIGRvY3VtZW50ZWQgaGVyZS5cbiAqXG4gKiBUaGUgb3B0aW9uYWwgW1skcmVzb2x2ZV1dIHNlcnZpY2UgaXMgYWxzbyBkb2N1bWVudGVkIGhlcmUuXG4gKlxuICogQG1vZHVsZSBuZzFcbiAqIEBwcmVmZXJyZWRcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4vYW5ndWxhclwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG52YXIgdmlld3NfMSA9IHJlcXVpcmUoXCIuL3N0YXRlYnVpbGRlcnMvdmlld3NcIik7XG52YXIgdGVtcGxhdGVGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi90ZW1wbGF0ZUZhY3RvcnlcIik7XG52YXIgc3RhdGVQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVQcm92aWRlclwiKTtcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4vc3RhdGVidWlsZGVycy9vbkVudGVyRXhpdFJldGFpblwiKTtcbnZhciBsb2NhdGlvblNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi9sb2NhdGlvblNlcnZpY2VzXCIpO1xudmFyIHVybFJvdXRlclByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi91cmxSb3V0ZXJQcm92aWRlclwiKTtcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoXCJ1aS5yb3V0ZXIuYW5ndWxhcjFcIiwgW10pO1xudmFyIG1vZF9pbml0ID0gYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyLmluaXQnLCBbXSk7XG52YXIgbW9kX3V0aWwgPSBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcsIFsnbmcnLCAndWkucm91dGVyLmluaXQnXSk7XG52YXIgbW9kX3J0ciA9IGFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xudmFyIG1vZF9zdGF0ZSA9IGFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScsIFsndWkucm91dGVyLnJvdXRlcicsICd1aS5yb3V0ZXIudXRpbCcsICd1aS5yb3V0ZXIuYW5ndWxhcjEnXSk7XG52YXIgbW9kX21haW4gPSBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXInLCBbJ3VpLnJvdXRlci5pbml0JywgJ3VpLnJvdXRlci5zdGF0ZScsICd1aS5yb3V0ZXIuYW5ndWxhcjEnXSk7XG52YXIgbW9kX2NtcHQgPSBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbnZhciByb3V0ZXIgPSBudWxsO1xuJHVpUm91dGVyLiRpbmplY3QgPSBbJyRsb2NhdGlvblByb3ZpZGVyJ107XG4vKiogVGhpcyBhbmd1bGFyIDEgcHJvdmlkZXIgaW5zdGFudGlhdGVzIGEgUm91dGVyIGFuZCBleHBvc2VzIGl0cyBzZXJ2aWNlcyB2aWEgdGhlIGFuZ3VsYXIgaW5qZWN0b3IgKi9cbmZ1bmN0aW9uICR1aVJvdXRlcigkbG9jYXRpb25Qcm92aWRlcikge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUm91dGVyIHdoZW4gdGhlICR1aVJvdXRlclByb3ZpZGVyIGlzIGluaXRpYWxpemVkXG4gICAgcm91dGVyID0gdGhpcy5yb3V0ZXIgPSBuZXcgY29yZV8xLlVJUm91dGVyKCk7XG4gICAgcm91dGVyLnN0YXRlUHJvdmlkZXIgPSBuZXcgc3RhdGVQcm92aWRlcl8xLlN0YXRlUHJvdmlkZXIocm91dGVyLnN0YXRlUmVnaXN0cnksIHJvdXRlci5zdGF0ZVNlcnZpY2UpO1xuICAgIC8vIEFwcGx5IG5nMSBzcGVjaWZpYyBTdGF0ZUJ1aWxkZXIgY29kZSBmb3IgYHZpZXdzYCwgYHJlc29sdmVgLCBhbmQgYG9uRXhpdC9SZXRhaW4vRW50ZXJgIHByb3BlcnRpZXNcbiAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJ2aWV3c1wiLCB2aWV3c18xLm5nMVZpZXdzQnVpbGRlcik7XG4gICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKFwib25FeGl0XCIsIG9uRW50ZXJFeGl0UmV0YWluXzEuZ2V0U3RhdGVIb29rQnVpbGRlcihcIm9uRXhpdFwiKSk7XG4gICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKFwib25SZXRhaW5cIiwgb25FbnRlckV4aXRSZXRhaW5fMS5nZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25SZXRhaW5cIikpO1xuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihcIm9uRW50ZXJcIiwgb25FbnRlckV4aXRSZXRhaW5fMS5nZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25FbnRlclwiKSk7XG4gICAgcm91dGVyLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3ZpZXdDb25maWdGYWN0b3J5KCduZzEnLCB2aWV3c18xLmdldE5nMVZpZXdDb25maWdGYWN0b3J5KCkpO1xuICAgIHZhciBuZzFMb2NhdGlvblNlcnZpY2UgPSByb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IGxvY2F0aW9uU2VydmljZXNfMS5OZzFMb2NhdGlvblNlcnZpY2VzKCRsb2NhdGlvblByb3ZpZGVyKTtcbiAgICBsb2NhdGlvblNlcnZpY2VzXzEuTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcik7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdDogYWxzbyBleHBvc2Ugcm91dGVyIGluc3RhbmNlIGFzICR1aVJvdXRlclByb3ZpZGVyLnJvdXRlclxuICAgIHJvdXRlclsncm91dGVyJ10gPSByb3V0ZXI7XG4gICAgcm91dGVyWyckZ2V0J10gPSAkZ2V0O1xuICAgICRnZXQuJGluamVjdCA9IFsnJGxvY2F0aW9uJywgJyRicm93c2VyJywgJyRzbmlmZmVyJywgJyRyb290U2NvcGUnLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnXTtcbiAgICBmdW5jdGlvbiAkZ2V0KCRsb2NhdGlvbiwgJGJyb3dzZXIsICRzbmlmZmVyLCAkcm9vdFNjb3BlLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICAgbmcxTG9jYXRpb25TZXJ2aWNlLl9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpO1xuICAgICAgICBkZWxldGUgcm91dGVyWydyb3V0ZXInXTtcbiAgICAgICAgZGVsZXRlIHJvdXRlclsnJGdldCddO1xuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xufVxudmFyIGdldFByb3ZpZGVyRm9yID0gZnVuY3Rpb24gKHNlcnZpY2VOYW1lKSB7IHJldHVybiBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCR1cnApIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSAkdXJwLnJvdXRlcltzZXJ2aWNlTmFtZV07XG4gICAgICAgIHNlcnZpY2VbXCIkZ2V0XCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmljZTsgfTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfV07IH07XG4vLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcbnJ1bkJsb2NrLiRpbmplY3QgPSBbJyRpbmplY3RvcicsICckcScsICckdWlSb3V0ZXInXTtcbmZ1bmN0aW9uIHJ1bkJsb2NrKCRpbmplY3RvciwgJHEsICR1aVJvdXRlcikge1xuICAgIGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XG4gICAgY29yZV8xLnNlcnZpY2VzLiRxID0gJHE7XG4gICAgLy8gVGhlICRpbmplY3RvciBpcyBub3cgYXZhaWxhYmxlLlxuICAgIC8vIEZpbmQgYW55IHJlc29sdmFibGVzIHRoYXQgaGFkIGRlcGVuZGVuY3kgYW5ub3RhdGlvbiBkZWZlcnJlZFxuICAgICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmdldCgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguJCRzdGF0ZSgpLnJlc29sdmFibGVzOyB9KVxuICAgICAgICAucmVkdWNlKGNvcmVfMS51bm5lc3RSLCBbXSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXBzID09PSBcImRlZmVycmVkXCI7IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7IHJldHVybiByZXNvbHZhYmxlLmRlcHMgPSAkaW5qZWN0b3IuYW5ub3RhdGUocmVzb2x2YWJsZS5yZXNvbHZlRm4pOyB9KTtcbn1cbi8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG52YXIgZ2V0VXJsUm91dGVyUHJvdmlkZXIgPSBmdW5jdGlvbiAodWlSb3V0ZXIpIHtcbiAgICByZXR1cm4gdWlSb3V0ZXIudXJsUm91dGVyUHJvdmlkZXIgPSBuZXcgdXJsUm91dGVyUHJvdmlkZXJfMS5VcmxSb3V0ZXJQcm92aWRlcih1aVJvdXRlcik7XG59O1xuLy8gJHN0YXRlIHNlcnZpY2UgYW5kICRzdGF0ZVByb3ZpZGVyXG4vLyAkdXJsUm91dGVyIHNlcnZpY2UgYW5kICR1cmxSb3V0ZXJQcm92aWRlclxudmFyIGdldFN0YXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvcmVfMS5leHRlbmQocm91dGVyLnN0YXRlUHJvdmlkZXIsIHsgJGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZTsgfSB9KTtcbn07XG53YXRjaERpZ2VzdHMuJGluamVjdCA9IFsnJHJvb3RTY29wZSddO1xuZnVuY3Rpb24gd2F0Y2hEaWdlc3RzKCRyb290U2NvcGUpIHtcbiAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IGNvcmVfMS50cmFjZS5hcHByb3hpbWF0ZURpZ2VzdHMrKzsgfSk7XG59XG5leHBvcnRzLndhdGNoRGlnZXN0cyA9IHdhdGNoRGlnZXN0cztcbm1vZF9pbml0LnByb3ZpZGVyKFwiJHVpUm91dGVyXCIsICR1aVJvdXRlcik7XG5tb2RfcnRyLnByb3ZpZGVyKCckdXJsUm91dGVyJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFVybFJvdXRlclByb3ZpZGVyXSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHVybFNlcnZpY2UnLCBnZXRQcm92aWRlckZvcigndXJsU2VydmljZScpKTtcbm1vZF91dGlsLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9XSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHRlbXBsYXRlRmFjdG9yeScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB0ZW1wbGF0ZUZhY3RvcnlfMS5UZW1wbGF0ZUZhY3RvcnkoKTsgfSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyRzdGF0ZVJlZ2lzdHJ5JywgZ2V0UHJvdmlkZXJGb3IoJ3N0YXRlUmVnaXN0cnknKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR1aVJvdXRlckdsb2JhbHMnLCBnZXRQcm92aWRlckZvcignZ2xvYmFscycpKTtcbm1vZF9zdGF0ZS5wcm92aWRlcignJHRyYW5zaXRpb25zJywgZ2V0UHJvdmlkZXJGb3IoJ3RyYW5zaXRpb25TZXJ2aWNlJykpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGUnLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZ2V0U3RhdGVQcm92aWRlcl0pO1xubW9kX3N0YXRlLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnJHVpUm91dGVyJywgZnVuY3Rpb24gKCR1aVJvdXRlcikgeyByZXR1cm4gJHVpUm91dGVyLmdsb2JhbHMucGFyYW1zOyB9XSk7XG5tb2RfbWFpbi5mYWN0b3J5KCckdmlldycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci52aWV3U2VydmljZTsgfSk7XG5tb2RfbWFpbi5zZXJ2aWNlKFwiJHRyYWNlXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS50cmFjZTsgfSk7XG5tb2RfbWFpbi5ydW4od2F0Y2hEaWdlc3RzKTtcbm1vZF91dGlsLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnkpIHsgfV0pO1xubW9kX3N0YXRlLnJ1bihbJyRzdGF0ZScsIGZ1bmN0aW9uICgkc3RhdGUpIHsgfV0pO1xubW9kX3J0ci5ydW4oWyckdXJsUm91dGVyJywgZnVuY3Rpb24gKCR1cmxSb3V0ZXIpIHsgfV0pO1xubW9kX2luaXQucnVuKHJ1bkJsb2NrKTtcbi8qKiBAaGlkZGVuIFRPRE86IGZpbmQgYSBwbGFjZSB0byBtb3ZlIHRoaXMgKi9cbmV4cG9ydHMuZ2V0TG9jYWxzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciB0b2tlbnMgPSBjdHguZ2V0VG9rZW5zKCkuZmlsdGVyKGNvcmVfMS5pc1N0cmluZyk7XG4gICAgdmFyIHR1cGxlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IGN0eC5nZXRSZXNvbHZhYmxlKGtleSk7XG4gICAgICAgIHZhciB3YWl0UG9saWN5ID0gY3R4LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYztcbiAgICAgICAgcmV0dXJuIFtrZXksIHdhaXRQb2xpY3kgPT09ICdOT1dBSVQnID8gcmVzb2x2YWJsZS5wcm9taXNlIDogcmVzb2x2YWJsZS5kYXRhXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShjb3JlXzEuYXBwbHlQYWlycywge30pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2VzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/services.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/stateFilters.js":
/*!************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/stateFilters.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/** @module ng1 */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar angular_1 = __webpack_require__(/*! ./angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\nexports.$IsStateFilter = $IsStateFilter;\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nexports.$IncludedByStateFilter = $IncludedByStateFilter;\nangular_1.ng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n//# sourceMappingURL=stateFilters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlRmlsdGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbmd1bGFyLXVpLXJvdXRlci9saWIvc3RhdGVGaWx0ZXJzLmpzP2E5OTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4vYW5ndWxhclwiKTtcbi8qKlxuICogYGlzU3RhdGVgIEZpbHRlcjogdHJ1dGh5IGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHRoZSBwYXJhbWV0ZXJcbiAqXG4gKiBUcmFuc2xhdGVzIHRvIFtbU3RhdGVTZXJ2aWNlLmlzXV0gYCRzdGF0ZS5pcyhcInN0YXRlTmFtZVwiKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1pZj1cIidzdGF0ZU5hbWUnIHwgaXNTdGF0ZVwiPnNob3cgaWYgc3RhdGUgaXMgJ3N0YXRlTmFtZSc8L2Rpdj5cbiAqIGBgYFxuICovXG4kSXNTdGF0ZUZpbHRlci4kaW5qZWN0ID0gWyckc3RhdGUnXTtcbmZ1bmN0aW9uICRJc1N0YXRlRmlsdGVyKCRzdGF0ZSkge1xuICAgIHZhciBpc0ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAkc3RhdGUuaXMoc3RhdGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBpc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xuICAgIHJldHVybiBpc0ZpbHRlcjtcbn1cbmV4cG9ydHMuJElzU3RhdGVGaWx0ZXIgPSAkSXNTdGF0ZUZpbHRlcjtcbi8qKlxuICogYGluY2x1ZGVkQnlTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaW5jbHVkZXMgdGhlIHBhcmFtZXRlclxuICpcbiAqIFRyYW5zbGF0ZXMgdG8gW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXWAgJHN0YXRlLmlzKFwiZnVsbE9yUGFydGlhbFN0YXRlTmFtZVwiKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1pZj1cIidmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lJyB8IGluY2x1ZGVkQnlTdGF0ZVwiPnNob3cgaWYgc3RhdGUgaW5jbHVkZXMgJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnPC9kaXY+XG4gKiBgYGBcbiAqL1xuJEluY2x1ZGVkQnlTdGF0ZUZpbHRlci4kaW5qZWN0ID0gWyckc3RhdGUnXTtcbmZ1bmN0aW9uICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gICAgdmFyIGluY2x1ZGVzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICRzdGF0ZS5pbmNsdWRlcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGluY2x1ZGVzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG4gICAgcmV0dXJuIGluY2x1ZGVzRmlsdGVyO1xufVxuZXhwb3J0cy4kSW5jbHVkZWRCeVN0YXRlRmlsdGVyID0gJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcjtcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gICAgLmZpbHRlcignaXNTdGF0ZScsICRJc1N0YXRlRmlsdGVyKVxuICAgIC5maWx0ZXIoJ2luY2x1ZGVkQnlTdGF0ZScsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVGaWx0ZXJzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/stateFilters.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/stateProvider.js":
/*!*************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/stateProvider.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** for typedoc */\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        core_1.createProxyFunctions(core_1.val(StateProvider.prototype), this, core_1.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (core_1.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\nexports.StateProvider = StateProvider;\n//# sourceMappingURL=stateProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlUHJvdmlkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlUHJvdmlkZXIuanM/N2ZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIG5nMSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG4vKipcbiAqIFRoZSBBbmd1bGFyIDEgYFN0YXRlUHJvdmlkZXJgXG4gKlxuICogVGhlIGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAqIG9uIHN0YXRlLlxuICpcbiAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICogbmF2aWdhdGlvbi4gQSBzdGF0ZSBkZXNjcmliZXMgKHZpYSB0aGUgY29udHJvbGxlciAvIHRlbXBsYXRlIC8gdmlldyBwcm9wZXJ0aWVzKSB3aGF0XG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuICpcbiAqIFN0YXRlcyBvZnRlbiBoYXZlIHRoaW5ncyBpbiBjb21tb24sIGFuZCB0aGUgcHJpbWFyeSB3YXkgb2YgZmFjdG9yaW5nIG91dCB0aGVzZVxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG4gKiBuZXN0ZWQgc3RhdGVzLlxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuICovXG52YXIgU3RhdGVQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVQcm92aWRlcihzdGF0ZVJlZ2lzdHJ5LCBzdGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVJlZ2lzdHJ5ID0gc3RhdGVSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5zdGF0ZVNlcnZpY2UgPSBzdGF0ZVNlcnZpY2U7XG4gICAgICAgIGNvcmVfMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhjb3JlXzEudmFsKFN0YXRlUHJvdmlkZXIucHJvdG90eXBlKSwgdGhpcywgY29yZV8xLnZhbCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29yYXRlcyBzdGF0ZXMgd2hlbiB0aGV5IGFyZSByZWdpc3RlcmVkXG4gICAgICpcbiAgICAgKiBBbGxvd3MgeW91IHRvIGV4dGVuZCAoY2FyZWZ1bGx5KSBvciBvdmVycmlkZSAoYXQgeW91ciBvd24gcGVyaWwpIHRoZVxuICAgICAqIGBzdGF0ZUJ1aWxkZXJgIG9iamVjdCB1c2VkIGludGVybmFsbHkgYnkgW1tTdGF0ZVJlZ2lzdHJ5XV0uXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGQgY3VzdG9tIGZ1bmN0aW9uYWxpdHkgdG8gdWktcm91dGVyLFxuICAgICAqIGZvciBleGFtcGxlIGluZmVycmluZyB0ZW1wbGF0ZVVybCBiYXNlZCBvbiB0aGUgc3RhdGUgbmFtZS5cbiAgICAgKlxuICAgICAqIFdoZW4gcGFzc2luZyBvbmx5IGEgbmFtZSwgaXQgcmV0dXJucyB0aGUgY3VycmVudCAob3JpZ2luYWwgb3IgZGVjb3JhdGVkKSBidWlsZGVyXG4gICAgICogZnVuY3Rpb24gdGhhdCBtYXRjaGVzIGBuYW1lYC5cbiAgICAgKlxuICAgICAqIFRoZSBidWlsZGVyIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBkZWNvcmF0ZWQgYXJlIGxpc3RlZCBiZWxvdy4gVGhvdWdoIG5vdCBhbGxcbiAgICAgKiBuZWNlc3NhcmlseSBoYXZlIGEgZ29vZCB1c2UgY2FzZSBmb3IgZGVjb3JhdGlvbiwgdGhhdCBpcyB1cCB0byB5b3UgdG8gZGVjaWRlLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIHVzZXJzIGNhbiBhdHRhY2ggY3VzdG9tIGRlY29yYXRvcnMsIHdoaWNoIHdpbGwgZ2VuZXJhdGUgbmV3XG4gICAgICogcHJvcGVydGllcyB3aXRoaW4gdGhlIHN0YXRlJ3MgaW50ZXJuYWwgZGVmaW5pdGlvbi4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGNsZWFyXG4gICAgICogdXNlLWNhc2UgZm9yIHRoaXMgYmV5b25kIGFjY2Vzc2luZyBpbnRlcm5hbCBzdGF0ZXMgKGkuZS4gJHN0YXRlLiRjdXJyZW50KSxcbiAgICAgKiBob3dldmVyLCBleHBlY3QgdGhpcyB0byBiZWNvbWUgaW5jcmVhc2luZ2x5IHJlbGV2YW50IGFzIHdlIGludHJvZHVjZSBhZGRpdGlvbmFsXG4gICAgICogbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqICoqV2FybmluZyoqOiBEZWNvcmF0b3JzIHNob3VsZCBub3QgYmUgaW50ZXJkZXBlbmRlbnQgYmVjYXVzZSB0aGUgb3JkZXIgb2ZcbiAgICAgKiBleGVjdXRpb24gb2YgdGhlIGJ1aWxkZXIgZnVuY3Rpb25zIGluIG5vbi1kZXRlcm1pbmlzdGljLiBCdWlsZGVyIGZ1bmN0aW9uc1xuICAgICAqIHNob3VsZCBvbmx5IGJlIGRlcGVuZGVudCBvbiB0aGUgc3RhdGUgZGVmaW5pdGlvbiBvYmplY3QgYW5kIHN1cGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBFeGlzdGluZyBidWlsZGVyIGZ1bmN0aW9ucyBhbmQgY3VycmVudCByZXR1cm4gdmFsdWVzOlxuICAgICAqXG4gICAgICogLSAqKnBhcmVudCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIHRoZSBwYXJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAqIC0gKipkYXRhKiogYHtvYmplY3R9YCAtIHJldHVybnMgc3RhdGUgZGF0YSwgaW5jbHVkaW5nIGFueSBpbmhlcml0ZWQgZGF0YSB0aGF0IGlzIG5vdFxuICAgICAqICAgb3ZlcnJpZGRlbiBieSBvd24gdmFsdWVzIChpZiBhbnkpLlxuICAgICAqIC0gKip1cmwqKiBge29iamVjdH1gIC0gcmV0dXJucyBhIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgVXJsTWF0Y2hlcn1cbiAgICAgKiAgIG9yIGBudWxsYC5cbiAgICAgKiAtICoqbmF2aWdhYmxlKiogYHtvYmplY3R9YCAtIHJldHVybnMgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoYWthIGlzXG4gICAgICogICBuYXZpZ2FibGUpLlxuICAgICAqIC0gKipwYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBwYXJhbXMgdGhhdCBhcmUgZW5zdXJlZCB0b1xuICAgICAqICAgYmUgYSBzdXBlci1zZXQgb2YgcGFyZW50J3MgcGFyYW1zLlxuICAgICAqIC0gKip2aWV3cyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEgdmlld3Mgb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGFuIGFic29sdXRlIHZpZXdcbiAgICAgKiAgIG5hbWUgKGkuZS4gXCJ2aWV3TmFtZUBzdGF0ZU5hbWVcIikgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIGNvbmZpZyBvYmplY3RcbiAgICAgKiAgICh0ZW1wbGF0ZSwgY29udHJvbGxlcikgZm9yIHRoZSB2aWV3LiBFdmVuIHdoZW4geW91IGRvbid0IHVzZSB0aGUgdmlld3Mgb2JqZWN0XG4gICAgICogICBleHBsaWNpdGx5IG9uIGEgc3RhdGUgY29uZmlnLCBvbmUgaXMgc3RpbGwgY3JlYXRlZCBmb3IgeW91IGludGVybmFsbHkuXG4gICAgICogICBTbyBieSBkZWNvcmF0aW5nIHRoaXMgYnVpbGRlciBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gZGVjb3JhdGluZyB0ZW1wbGF0ZVxuICAgICAqICAgYW5kIGNvbnRyb2xsZXIgcHJvcGVydGllcy5cbiAgICAgKiAtICoqb3duUGFyYW1zKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gYXJyYXkgb2YgcGFyYW1zIHRoYXQgYmVsb25nIHRvIHRoZSBzdGF0ZSxcbiAgICAgKiAgIG5vdCBpbmNsdWRpbmcgYW55IHBhcmFtcyBkZWZpbmVkIGJ5IGFuY2VzdG9yIHN0YXRlcy5cbiAgICAgKiAtICoqcGF0aCoqIGB7c3RyaW5nfWAgLSByZXR1cm5zIHRoZSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUuXG4gICAgICogICBOZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgICogLSAqKmluY2x1ZGVzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgZXZlcnkgc3RhdGUgdGhhdFxuICAgICAqICAgd291bGQgcGFzcyBhIGAkc3RhdGUuaW5jbHVkZXMoKWAgdGVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBPdmVycmlkZSB0aGUgaW50ZXJuYWwgJ3ZpZXdzJyBidWlsZGVyIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzdGF0ZVxuICAgICAqIGRlZmluaXRpb24sIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgZnVuY3Rpb24gYmVpbmcgb3ZlcnJpZGRlbjpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZVByb3ZpZGVyLmRlY29yYXRvcigndmlld3MnLCBmdW5jdGlvbiAoc3RhdGUsIHBhcmVudCkge1xuICAgICAqICAgbGV0IHJlc3VsdCA9IHt9LFxuICAgICAqICAgICAgIHZpZXdzID0gcGFyZW50KHN0YXRlKTtcbiAgICAgKlxuICAgICAqICAgYW5ndWxhci5mb3JFYWNoKHZpZXdzLCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgICogICAgIGxldCBhdXRvTmFtZSA9IChzdGF0ZS5uYW1lICsgJy4nICsgbmFtZSkucmVwbGFjZSgnLicsICcvJyk7XG4gICAgICogICAgIGNvbmZpZy50ZW1wbGF0ZVVybCA9IGNvbmZpZy50ZW1wbGF0ZVVybCB8fCAnL3BhcnRpYWxzLycgKyBhdXRvTmFtZSArICcuaHRtbCc7XG4gICAgICogICAgIHJlc3VsdFtuYW1lXSA9IGNvbmZpZztcbiAgICAgKiAgIH0pO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdob21lJywge1xuICAgICAqICAgdmlld3M6IHtcbiAgICAgKiAgICAgJ2NvbnRhY3QubGlzdCc6IHsgY29udHJvbGxlcjogJ0xpc3RDb250cm9sbGVyJyB9LFxuICAgICAqICAgICAnY29udGFjdC5pdGVtJzogeyBjb250cm9sbGVyOiAnSXRlbUNvbnRyb2xsZXInIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAvLyBBdXRvLXBvcHVsYXRlcyBsaXN0IGFuZCBpdGVtIHZpZXdzIHdpdGggL3BhcnRpYWxzL2hvbWUvY29udGFjdC9saXN0Lmh0bWwsXG4gICAgICogLy8gYW5kIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvaXRlbS5odG1sLCByZXNwZWN0aXZlbHkuXG4gICAgICogJHN0YXRlLmdvKCdob21lJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbiB0byBkZWNvcmF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyBBIGZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGRlY29yYXRpbmcgdGhlIG9yaWdpbmFsXG4gICAgICogYnVpbGRlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICAtIGB7b2JqZWN0fWAgLSBzdGF0ZSAtIFRoZSBzdGF0ZSBjb25maWcgb2JqZWN0LlxuICAgICAqICAgLSBge29iamVjdH1gIC0gc3VwZXIgLSBUaGUgb3JpZ2luYWwgYnVpbGRlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gJHN0YXRlUHJvdmlkZXIgLSAkc3RhdGVQcm92aWRlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLmRlY29yYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKG5hbWUsIGZ1bmMpIHx8IHRoaXM7XG4gICAgfTtcbiAgICBTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChjb3JlXzEuaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoZGVmaW5pdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGludmFsaWQgc3RhdGUgaGFuZGxlclxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRvIFtbU3RhdGVTZXJ2aWNlLm9uSW52YWxpZF1dIGZvciBuZzEuXG4gICAgICovXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlU2VydmljZS5vbkludmFsaWQoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZVByb3ZpZGVyID0gU3RhdGVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUHJvdmlkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/stateProvider.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/statebuilders/onEnterExitRetain.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/statebuilders/onEnterExitRetain.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nvar services_1 = __webpack_require__(/*! ../services */ \"./node_modules/angular-ui-router/lib/services.js\");\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nexports.getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(state, parentFn) {\n        var hook = state[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new core_1.ResolveContext(trans.treeChanges(pathname));\n            var locals = core_1.extend(services_1.getLocals(resolveContext), { $state$: state, $transition$: trans });\n            return core_1.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n//# sourceMappingURL=onEnterExitRetain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlYnVpbGRlcnMvb25FbnRlckV4aXRSZXRhaW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlYnVpbGRlcnMvb25FbnRlckV4aXRSZXRhaW4uanM/ZWI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIG5nMSAqLyAvKiogKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG52YXIgc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9zZXJ2aWNlc1wiKTtcbi8qKlxuICogVGhpcyBpcyBhIFtbU3RhdGVCdWlsZGVyLmJ1aWxkZXJdXSBmdW5jdGlvbiBmb3IgYW5ndWxhcjEgYG9uRW50ZXJgLCBgb25FeGl0YCxcbiAqIGBvblJldGFpbmAgY2FsbGJhY2sgaG9va3Mgb24gYSBbW05nMVN0YXRlRGVjbGFyYXRpb25dXS5cbiAqXG4gKiBXaGVuIHRoZSBbW1N0YXRlQnVpbGRlcl1dIGJ1aWxkcyBhIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgZnJvbSBhIHJhdyBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhpcyBidWlsZGVyXG4gKiBlbnN1cmVzIHRoYXQgdGhvc2UgaG9va3MgYXJlIGluamVjdGFibGUgZm9yIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXG4gKi9cbmV4cG9ydHMuZ2V0U3RhdGVIb29rQnVpbGRlciA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZUhvb2tCdWlsZGVyKHN0YXRlLCBwYXJlbnRGbikge1xuICAgICAgICB2YXIgaG9vayA9IHN0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgdmFyIHBhdGhuYW1lID0gaG9va05hbWUgPT09ICdvbkV4aXQnID8gJ2Zyb20nIDogJ3RvJztcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGVkTmcxSG9vayh0cmFucywgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyBjb3JlXzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMocGF0aG5hbWUpKTtcbiAgICAgICAgICAgIHZhciBsb2NhbHMgPSBjb3JlXzEuZXh0ZW5kKHNlcnZpY2VzXzEuZ2V0TG9jYWxzKHJlc29sdmVDb250ZXh0KSwgeyAkc3RhdGUkOiBzdGF0ZSwgJHRyYW5zaXRpb24kOiB0cmFucyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShob29rLCB0aGlzLCBsb2NhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob29rID8gZGVjb3JhdGVkTmcxSG9vayA6IHVuZGVmaW5lZDtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRW50ZXJFeGl0UmV0YWluLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/statebuilders/onEnterExitRetain.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/statebuilders/views.js":
/*!*******************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/statebuilders/views.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || core_1.services.$injector.get(\"$templateFactory\");\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || core_1.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (core_1.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return core_1.isDefined(state[key]); }).join(\", \")));\n    }\n    var views = {}, viewsObject = state.views || { \"$default\": core_1.pick(state, allViewKeys) };\n    core_1.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || \"$default\";\n        // Account for views: { header: \"headerComponent\" }\n        if (core_1.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = core_1.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = \"ng1\";\n        config.$context = state;\n        config.$name = name;\n        var normalized = core_1.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nvar id = 0;\nvar Ng1ViewConfig = (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = core_1.services.$q;\n        var context = new core_1.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return core_1.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context))\n        };\n        return $q.all(promises).then(function (results) {\n            core_1.trace.traceViewServiceEvent(\"Loaded\", _this);\n            _this.controller = results.controller;\n            core_1.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!core_1.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\nexports.Ng1ViewConfig = Ng1ViewConfig;\n//# sourceMappingURL=views.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlYnVpbGRlcnMvdmlld3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlYnVpbGRlcnMvdmlld3MuanM/ZWM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG5mdW5jdGlvbiBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpIHtcbiAgICB2YXIgdGVtcGxhdGVGYWN0b3J5ID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGgsIHZpZXcpIHtcbiAgICAgICAgdGVtcGxhdGVGYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5IHx8IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KFwiJHRlbXBsYXRlRmFjdG9yeVwiKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgTmcxVmlld0NvbmZpZyhwYXRoLCB2aWV3LCB0ZW1wbGF0ZUZhY3RvcnkpXTtcbiAgICB9O1xufVxuZXhwb3J0cy5nZXROZzFWaWV3Q29uZmlnRmFjdG9yeSA9IGdldE5nMVZpZXdDb25maWdGYWN0b3J5O1xudmFyIGhhc0FueUtleSA9IGZ1bmN0aW9uIChrZXlzLCBvYmopIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiBhY2MgfHwgY29yZV8xLmlzRGVmaW5lZChvYmpba2V5XSk7IH0sIGZhbHNlKTtcbn07XG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGB2aWV3c2AuXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogaGFuZGxlcyB0aGUgYHZpZXdzYCBwcm9wZXJ0eSB3aXRoIGxvZ2ljIHNwZWNpZmljIHRvIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXG4gKlxuICogSWYgbm8gYHZpZXdzOiB7fWAgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhlbiBpdCBjcmVhdGVzIHRoZSBgdmlld3NgIG9iamVjdFxuICogYW5kIGFwcGxpZXMgdGhlIHN0YXRlLWxldmVsIGNvbmZpZ3VyYXRpb24gdG8gYSB2aWV3IG5hbWVkIGAkZGVmYXVsdGAuXG4gKi9cbmZ1bmN0aW9uIG5nMVZpZXdzQnVpbGRlcihzdGF0ZSkge1xuICAgIC8vIERvIG5vdCBwcm9jZXNzIHJvb3Qgc3RhdGVcbiAgICBpZiAoIXN0YXRlLnBhcmVudClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciB0cGxLZXlzID0gWyd0ZW1wbGF0ZVByb3ZpZGVyJywgJ3RlbXBsYXRlVXJsJywgJ3RlbXBsYXRlJywgJ25vdGlmeScsICdhc3luYyddLCBjdHJsS2V5cyA9IFsnY29udHJvbGxlcicsICdjb250cm9sbGVyUHJvdmlkZXInLCAnY29udHJvbGxlckFzJywgJ3Jlc29sdmVBcyddLCBjb21wS2V5cyA9IFsnY29tcG9uZW50JywgJ2JpbmRpbmdzJywgJ2NvbXBvbmVudFByb3ZpZGVyJ10sIG5vbkNvbXBLZXlzID0gdHBsS2V5cy5jb25jYXQoY3RybEtleXMpLCBhbGxWaWV3S2V5cyA9IGNvbXBLZXlzLmNvbmNhdChub25Db21wS2V5cyk7XG4gICAgLy8gRG8gbm90IGFsbG93IGEgc3RhdGUgdG8gaGF2ZSBib3RoIHN0YXRlLWxldmVsIHByb3BzIGFuZCBhbHNvIGEgYHZpZXdzOiB7fWAgcHJvcGVydHkuXG4gICAgLy8gQSBzdGF0ZSB3aXRob3V0IGEgYHZpZXdzOiB7fWAgcHJvcGVydHkgY2FuIGRlY2xhcmUgcHJvcGVydGllcyBmb3IgdGhlIGAkZGVmYXVsdGAgdmlldyBhcyBwcm9wZXJ0aWVzIG9mIHRoZSBzdGF0ZS5cbiAgICAvLyBIb3dldmVyLCB0aGUgYCRkZWZhdWx0YCBhcHByb2FjaCBzaG91bGQgbm90IGJlIG1peGVkIHdpdGggYSBzZXBhcmF0ZSBgdmlld3M6IGAgYmxvY2suXG4gICAgaWYgKGNvcmVfMS5pc0RlZmluZWQoc3RhdGUudmlld3MpICYmIGhhc0FueUtleShhbGxWaWV3S2V5cywgc3RhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIHN0YXRlLm5hbWUgKyBcIicgaGFzIGEgJ3ZpZXdzJyBvYmplY3QuIFwiICtcbiAgICAgICAgICAgIFwiSXQgY2Fubm90IGFsc28gaGF2ZSBcXFwidmlldyBwcm9wZXJ0aWVzXFxcIiBhdCB0aGUgc3RhdGUgbGV2ZWwuICBcIiArXG4gICAgICAgICAgICBcIk1vdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGludG8gYSB2aWV3IChpbiB0aGUgJ3ZpZXdzJyBvYmplY3QpOiBcIiArXG4gICAgICAgICAgICAoXCIgXCIgKyBhbGxWaWV3S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29yZV8xLmlzRGVmaW5lZChzdGF0ZVtrZXldKTsgfSkuam9pbihcIiwgXCIpKSk7XG4gICAgfVxuICAgIHZhciB2aWV3cyA9IHt9LCB2aWV3c09iamVjdCA9IHN0YXRlLnZpZXdzIHx8IHsgXCIkZGVmYXVsdFwiOiBjb3JlXzEucGljayhzdGF0ZSwgYWxsVmlld0tleXMpIH07XG4gICAgY29yZV8xLmZvckVhY2godmlld3NPYmplY3QsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICAgICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgXCJcIjogeyB0ZW1wbGF0ZS4uLiB9IH1cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgXCIkZGVmYXVsdFwiO1xuICAgICAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBoZWFkZXI6IFwiaGVhZGVyQ29tcG9uZW50XCIgfVxuICAgICAgICBpZiAoY29yZV8xLmlzU3RyaW5nKGNvbmZpZykpXG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbXBvbmVudDogY29uZmlnIH07XG4gICAgICAgIC8vIE1ha2UgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGNvbmZpZyBvYmplY3RcbiAgICAgICAgY29uZmlnID0gY29yZV8xLmV4dGVuZCh7fSwgY29uZmlnKTtcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IGEgdmlldyB0byBtaXggcHJvcHMgZm9yIGNvbXBvbmVudC1zdHlsZSB2aWV3IHdpdGggcHJvcHMgZm9yIHRlbXBsYXRlL2NvbnRyb2xsZXItc3R5bGUgdmlld1xuICAgICAgICBpZiAoaGFzQW55S2V5KGNvbXBLZXlzLCBjb25maWcpICYmIGhhc0FueUtleShub25Db21wS2V5cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmU6IFwiICsgY29tcEtleXMuam9pbihcInxcIikgKyBcIiB3aXRoOiBcIiArIG5vbkNvbXBLZXlzLmpvaW4oXCJ8XCIpICsgXCIgaW4gc3RhdGV2aWV3OiAnXCIgKyBuYW1lICsgXCJAXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5yZXNvbHZlQXMgPSBjb25maWcucmVzb2x2ZUFzIHx8ICckcmVzb2x2ZSc7XG4gICAgICAgIGNvbmZpZy4kdHlwZSA9IFwibmcxXCI7XG4gICAgICAgIGNvbmZpZy4kY29udGV4dCA9IHN0YXRlO1xuICAgICAgICBjb25maWcuJG5hbWUgPSBuYW1lO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGNvcmVfMS5WaWV3U2VydmljZS5ub3JtYWxpemVVSVZpZXdUYXJnZXQoY29uZmlnLiRjb250ZXh0LCBjb25maWcuJG5hbWUpO1xuICAgICAgICBjb25maWcuJHVpVmlld05hbWUgPSBub3JtYWxpemVkLnVpVmlld05hbWU7XG4gICAgICAgIGNvbmZpZy4kdWlWaWV3Q29udGV4dEFuY2hvciA9IG5vcm1hbGl6ZWQudWlWaWV3Q29udGV4dEFuY2hvcjtcbiAgICAgICAgdmlld3NbbmFtZV0gPSBjb25maWc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpZXdzO1xufVxuZXhwb3J0cy5uZzFWaWV3c0J1aWxkZXIgPSBuZzFWaWV3c0J1aWxkZXI7XG52YXIgaWQgPSAwO1xudmFyIE5nMVZpZXdDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nMVZpZXdDb25maWcocGF0aCwgdmlld0RlY2wsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy52aWV3RGVjbCA9IHZpZXdEZWNsO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLiRpZCA9IGlkKys7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAodWlWaWV3LCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcG9uZW50ID8gX3RoaXMuZmFjdG9yeS5tYWtlQ29tcG9uZW50VGVtcGxhdGUodWlWaWV3LCBjb250ZXh0LCBfdGhpcy5jb21wb25lbnQsIF90aGlzLnZpZXdEZWNsLmJpbmRpbmdzKSA6IF90aGlzLnRlbXBsYXRlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBOZzFWaWV3Q29uZmlnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHEgPSBjb3JlXzEuc2VydmljZXMuJHE7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IGNvcmVfMS5SZXNvbHZlQ29udGV4dCh0aGlzLnBhdGgpO1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBjb3JlXzEuZXh0ZW5kKGFjYywgbm9kZS5wYXJhbVZhbHVlcyk7IH0sIHt9KTtcbiAgICAgICAgdmFyIHByb21pc2VzID0ge1xuICAgICAgICAgICAgdGVtcGxhdGU6ICRxLndoZW4odGhpcy5mYWN0b3J5LmZyb21Db25maWcodGhpcy52aWV3RGVjbCwgcGFyYW1zLCBjb250ZXh0KSksXG4gICAgICAgICAgICBjb250cm9sbGVyOiAkcS53aGVuKHRoaXMuZ2V0Q29udHJvbGxlcihjb250ZXh0KSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudChcIkxvYWRlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5jb250cm9sbGVyID0gcmVzdWx0cy5jb250cm9sbGVyO1xuICAgICAgICAgICAgY29yZV8xLmV4dGVuZChfdGhpcywgcmVzdWx0cy50ZW1wbGF0ZSk7IC8vIEVpdGhlciB7IHRlbXBsYXRlOiBcInRwbFwiIH0gb3IgeyBjb21wb25lbnQ6IFwiY21wTmFtZVwiIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250cm9sbGVyIGZvciBhIHZpZXcgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxQcm9taXNlLjxGdW5jdGlvbj59IFJldHVybnMgYSBjb250cm9sbGVyLCBvciBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMudmlld0RlY2wuY29udHJvbGxlclByb3ZpZGVyO1xuICAgICAgICBpZiAoIWNvcmVfMS5pc0luamVjdGFibGUocHJvdmlkZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0RlY2wuY29udHJvbGxlcjtcbiAgICAgICAgdmFyIGRlcHMgPSBjb3JlXzEuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyRm4gPSBjb3JlXzEuaXNBcnJheShwcm92aWRlcikgPyBjb3JlXzEudGFpbChwcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSBuZXcgY29yZV8xLlJlc29sdmFibGUoXCJcIiwgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZzFWaWV3Q29uZmlnO1xufSgpKTtcbmV4cG9ydHMuTmcxVmlld0NvbmZpZyA9IE5nMVZpZXdDb25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/statebuilders/views.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/templateFactory.js":
/*!***************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/templateFactory.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module view */\n/** for typedoc */\nvar angular_1 = __webpack_require__(/*! ./angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = angular_1.ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    ;\n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = \"<ui-view></ui-view>\";\n        var asTemplate = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (core_1.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            core_1.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                core_1.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    core_1.isDefined(config.component) ? asComponent(config.component) :\n                        core_1.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    ;\n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return core_1.isFunction(template) ? template(params) : template;\n    };\n    ;\n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (core_1.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    ;\n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = angular_1.ng.version.minor >= 3 ? \"::\" : \"\";\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = core_1.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && core_1.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = core_1.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    ;\n    return TemplateFactory;\n}());\nexports.TemplateFactory = TemplateFactory;\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = core_1.services.$injector.get(name + \"Directive\"); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(core_1.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (core_1.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return core_1.isDefined(tuple) && core_1.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n//# sourceMappingURL=templateFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3RlbXBsYXRlRmFjdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbmd1bGFyLXVpLXJvdXRlci9saWIvdGVtcGxhdGVGYWN0b3J5LmpzPzVhNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSB2aWV3ICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBhbmd1bGFyXzEgPSByZXF1aXJlKFwiLi9hbmd1bGFyXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcbi8qKlxuICogU2VydmljZSB3aGljaCBtYW5hZ2VzIGxvYWRpbmcgb2YgdGVtcGxhdGVzIGZyb20gYSBWaWV3Q29uZmlnLlxuICovXG52YXIgVGVtcGxhdGVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3VzZUh0dHAgPSBhbmd1bGFyXzEubmcudmVyc2lvbi5taW5vciA8IDM7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuJGdldCA9IFsnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGluamVjdG9yJywgZnVuY3Rpb24gKCRodHRwLCAkdGVtcGxhdGVDYWNoZSwgJGluamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuJHRlbXBsYXRlUmVxdWVzdCA9ICRpbmplY3Rvci5oYXMgJiYgJGluamVjdG9yLmhhcygnJHRlbXBsYXRlUmVxdWVzdCcpICYmICRpbmplY3Rvci5nZXQoJyR0ZW1wbGF0ZVJlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy4kaHR0cCA9ICRodHRwO1xuICAgICAgICAgICAgICAgIF90aGlzLiR0ZW1wbGF0ZUNhY2hlID0gJHRlbXBsYXRlQ2FjaGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS51c2VIdHRwU2VydmljZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl91c2VIdHRwID0gdmFsdWU7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS5cbiAgICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNlYXJjaCBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZVxuICAgICAqIHRoYXQgaXMgZGVmaW5lZCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSByZXNvbHZlIGNvbnRleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZW1wbGF0ZSdzIHZpZXdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvclxuICAgICAqIHRoYXQgc3RyaW5nLG9yIGBudWxsYCBpZiBubyB0ZW1wbGF0ZSBpcyBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVmYXVsdFRlbXBsYXRlID0gXCI8dWktdmlldz48L3VpLXZpZXc+XCI7XG4gICAgICAgIHZhciBhc1RlbXBsYXRlID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gY29yZV8xLnNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuICh7IHRlbXBsYXRlOiBzdHIgfSk7IH0pOyB9O1xuICAgICAgICB2YXIgYXNDb21wb25lbnQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjb3JlXzEuc2VydmljZXMuJHEud2hlbihyZXN1bHQpLnRoZW4oZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gKHsgY29tcG9uZW50OiBzdHIgfSk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gKGNvcmVfMS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlKSA/IGFzVGVtcGxhdGUodGhpcy5mcm9tU3RyaW5nKGNvbmZpZy50ZW1wbGF0ZSwgcGFyYW1zKSkgOlxuICAgICAgICAgICAgY29yZV8xLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGVVcmwpID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpKSA6XG4gICAgICAgICAgICAgICAgY29yZV8xLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGVQcm92aWRlcikgPyBhc1RlbXBsYXRlKHRoaXMuZnJvbVByb3ZpZGVyKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpKSA6XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5pc0RlZmluZWQoY29uZmlnLmNvbXBvbmVudCkgPyBhc0NvbXBvbmVudChjb25maWcuY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEuaXNEZWZpbmVkKGNvbmZpZy5jb21wb25lbnRQcm92aWRlcikgPyBhc0NvbXBvbmVudCh0aGlzLmZyb21Db21wb25lbnRQcm92aWRlcihjb25maWcuY29tcG9uZW50UHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1RlbXBsYXRlKGRlZmF1bHRUZW1wbGF0ZSkpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdFxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gY29yZV8xLmlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgdGVtcGxhdGUgZnJvbSB0aGUgYSBVUkwgdmlhIGAkaHR0cGAgYW5kIGAkdGVtcGxhdGVDYWNoZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdXJsIHVybCBvZiB0aGUgdGVtcGxhdGUgdG8gbG9hZCwgb3IgYSBmdW5jdGlvblxuICAgICAqIHRoYXQgcmV0dXJucyBhIHVybC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdXJsIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXG4gICAgICogZm9yIHRoYXQgc3RyaW5nLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29yZV8xLmlzRnVuY3Rpb24odXJsKSlcbiAgICAgICAgICAgIHVybCA9IHVybChwYXJhbXMpO1xuICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUh0dHApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwLmdldCh1cmwsIHsgY2FjaGU6IHRoaXMuJHRlbXBsYXRlQ2FjaGUsIGhlYWRlcnM6IHsgQWNjZXB0OiAndGV4dC9odG1sJyB9IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kdGVtcGxhdGVSZXF1ZXN0KHVybCk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgbG9jYWxzYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZuIGEgZnVuY3Rpb24gdXNlZCB0byBpbnZva2UgdGhlIHRlbXBsYXRlIHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2VcbiAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVwcyA9IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmVfMS5pc0FycmF5KHByb3ZpZGVyKSA/IGNvcmVfMS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlXzEuUmVzb2x2YWJsZShcIlwiLCBwcm92aWRlckZuLCBkZXBzKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb25lbnQncyB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tQ29tcG9uZW50UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVwcyA9IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmVfMS5pc0FycmF5KHByb3ZpZGVyKSA/IGNvcmVfMS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlXzEuUmVzb2x2YWJsZShcIlwiLCBwcm92aWRlckZuLCBkZXBzKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29tcG9uZW50J3MgbmFtZVxuICAgICAqXG4gICAgICogVGhpcyBpbXBsZW1lbnRzIHJvdXRlLXRvLWNvbXBvbmVudC5cbiAgICAgKiBJdCB3b3JrcyBieSByZXRyaWV2aW5nIHRoZSBjb21wb25lbnQgKGRpcmVjdGl2ZSkgbWV0YWRhdGEgZnJvbSB0aGUgaW5qZWN0b3IuXG4gICAgICogSXQgYW5hbHlzZXMgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzLCB0aGVuIGNvbnN0cnVjdHMgYSB0ZW1wbGF0ZSB0aGF0IGluc3RhbnRpYXRlcyB0aGUgY29tcG9uZW50LlxuICAgICAqIFRoZSB0ZW1wbGF0ZSB3aXJlcyBpbnB1dCBhbmQgb3V0cHV0IGJpbmRpbmdzIHRvIHJlc29sdmVzIG9yIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlWaWV3IHtvYmplY3R9IFRoZSBwYXJlbnQgdWktdmlldyAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIFJlc29sdmVDb250ZXh0IChmb3IgYmluZGluZyBvdXRwdXRzIHRvIGNhbGxiYWNrcyByZXR1cm5lZCBmcm9tIHJlc29sdmVzKVxuICAgICAqIEBwYXJhbSBjb21wb25lbnQge3N0cmluZ30gQ29tcG9uZW50J3MgbmFtZSBpbiBjYW1lbCBjYXNlLlxuICAgICAqIEBwYXJhbSBiaW5kaW5ncyBBbiBvYmplY3QgZGVmaW5pbmcgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzOiB7Zm9vOiAnPCd9XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGVtcGxhdGUgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5tYWtlQ29tcG9uZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAodWlWaWV3LCBjb250ZXh0LCBjb21wb25lbnQsIGJpbmRpbmdzKSB7XG4gICAgICAgIGJpbmRpbmdzID0gYmluZGluZ3MgfHwge307XG4gICAgICAgIC8vIEJpbmQgb25jZSBwcmVmaXhcbiAgICAgICAgdmFyIHByZWZpeCA9IGFuZ3VsYXJfMS5uZy52ZXJzaW9uLm1pbm9yID49IDMgPyBcIjo6XCIgOiBcIlwiO1xuICAgICAgICAvLyBDb252ZXJ0IHRvIGtlYm9iIG5hbWUuIEFkZCB4LSBwcmVmaXggaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBgeC1gIG9yIGBkYXRhLWBcbiAgICAgICAgdmFyIGtlYm9iID0gZnVuY3Rpb24gKGNhbWVsQ2FzZSkge1xuICAgICAgICAgICAgdmFyIGtlYm9iZWQgPSBjb3JlXzEua2Vib2JTdHJpbmcoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgIHJldHVybiAvXih4fGRhdGEpLS8uZXhlYyhrZWJvYmVkKSA/IFwieC1cIiArIGtlYm9iZWQgOiBrZWJvYmVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlVHBsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWUsIHR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0ga2Vib2IobmFtZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdWktdmlldyBoYXMgYW4gYXR0cmlidXRlIHdoaWNoIG1hdGNoZXMgYSBiaW5kaW5nIG9uIHRoZSByb3V0ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAvLyB0aGVuIHBhc3MgdGhhdCBhdHRyaWJ1dGUgdGhyb3VnaCB0byB0aGUgcm91dGVkIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIC8vIFByZWZlciB1aS12aWV3IHdpcmVkIG1hcHBpbmdzIHRvIHJlc29sdmUgZGF0YSwgdW5sZXNzIHRoZSByZXNvbHZlIHdhcyBleHBsaWNpdGx5IGJvdW5kIHVzaW5nIGBiaW5kaW5nczpgXG4gICAgICAgICAgICBpZiAodWlWaWV3LmF0dHIoYXR0ck5hbWUpICYmICFiaW5kaW5nc1tuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0nXCIgKyB1aVZpZXcuYXR0cihhdHRyTmFtZSkgKyBcIidcIjtcbiAgICAgICAgICAgIHZhciByZXNvbHZlTmFtZSA9IGJpbmRpbmdzW25hbWVdIHx8IG5hbWU7XG4gICAgICAgICAgICAvLyBQcmUtZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gZm9yIFwiQFwiIGJpbmRpbmdzIGJ5IGVuY2xvc2luZyBpbiB7eyB9fVxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwie3sgOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWUgfX1cIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdAJylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0ne3tcIiArIHByZWZpeCArIFwiJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIFwifX0nXCI7XG4gICAgICAgICAgICAvLyBXaXJlIFwiJlwiIGNhbGxiYWNrcyB0byByZXNvbHZlcyB0aGF0IHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZSAoc2hvdWxkIGJlIGEgZnVuY3Rpb24pIGFuZCBhbm5vdGF0ZSBpdCB0byBnZXQgaXRzIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cIiRyZXNvbHZlLnNvbWVSZXNvbHZlUmVzdWx0TmFtZShmb28sIGJhcilcIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICcmJykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb250ZXh0LmdldFJlc29sdmFibGUocmVzb2x2ZU5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IHJlcyAmJiByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZuICYmIGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4pIHx8IFtdO1xuICAgICAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIGFycmF5IHN0eWxlIGluamVjdGlvbiwgaS5lLiwgWydmb28nLCBmdW5jdGlvbihmb28pIHt9XVxuICAgICAgICAgICAgICAgIHZhciBhcnJheUlkeFN0ciA9IGNvcmVfMS5pc0FycmF5KGZuKSA/IFwiW1wiICsgKGZuLmxlbmd0aCAtIDEpICsgXCJdXCIgOiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0nJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIGFycmF5SWR4U3RyICsgXCIoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwiOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9J1wiICsgcHJlZml4ICsgXCIkcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgXCInXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdHRycyA9IGdldENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudCkubWFwKGF0dHJpYnV0ZVRwbCkuam9pbihcIiBcIik7XG4gICAgICAgIHZhciBrZWJvYk5hbWUgPSBrZWJvYihjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyBrZWJvYk5hbWUgKyBcIiBcIiArIGF0dHJzICsgXCI+PC9cIiArIGtlYm9iTmFtZSArIFwiPlwiO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBUZW1wbGF0ZUZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5UZW1wbGF0ZUZhY3RvcnkgPSBUZW1wbGF0ZUZhY3Rvcnk7XG4vLyBHZXRzIGFsbCB0aGUgZGlyZWN0aXZlKHMpJyBpbnB1dHMgKCdAJywgJz0nLCBhbmQgJzwnKSBhbmQgb3V0cHV0cyAoJyYnKVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QmluZGluZ3MobmFtZSkge1xuICAgIHZhciBjbXBEZWZzID0gY29yZV8xLnNlcnZpY2VzLiRpbmplY3Rvci5nZXQobmFtZSArIFwiRGlyZWN0aXZlXCIpOyAvLyBjb3VsZCBiZSBtdWx0aXBsZVxuICAgIGlmICghY21wRGVmcyB8fCAhY21wRGVmcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgIHJldHVybiBjbXBEZWZzLm1hcChnZXRCaW5kaW5ncykucmVkdWNlKGNvcmVfMS51bm5lc3RSLCBbXSk7XG59XG4vLyBHaXZlbiBhIGRpcmVjdGl2ZSBkZWZpbml0aW9uLCBmaW5kIGl0cyBvYmplY3QgaW5wdXQgYXR0cmlidXRlc1xuLy8gVXNlIGRpZmZlcmVudCBwcm9wZXJ0aWVzLCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZGlyZWN0aXZlIChjb21wb25lbnQsIGJpbmRUb0NvbnRyb2xsZXIsIG5vcm1hbClcbnZhciBnZXRCaW5kaW5ncyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICBpZiAoY29yZV8xLmlzT2JqZWN0KGRlZi5iaW5kVG9Db250cm9sbGVyKSlcbiAgICAgICAgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLmJpbmRUb0NvbnRyb2xsZXIpO1xuICAgIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5zY29wZSk7XG59O1xuLy8gZm9yIG5nIDEuMiBzdHlsZSwgcHJvY2VzcyB0aGUgc2NvcGU6IHsgaW5wdXQ6IFwiPWZvb1wiIH1cbi8vIGZvciBuZyAxLjMgdGhyb3VnaCBuZyAxLjUsIHByb2Nlc3MgdGhlIGNvbXBvbmVudCdzIGJpbmRUb0NvbnRyb2xsZXI6IHsgaW5wdXQ6IFwiPWZvb1wiIH0gb2JqZWN0XG52YXIgc2NvcGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChiaW5kaW5nc09iaikgeyByZXR1cm4gT2JqZWN0LmtleXMoYmluZGluZ3NPYmogfHwge30pXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBba2V5LCAvXihbPTxAJl0pWz9dPyguKikvLmV4ZWMoYmluZGluZ3NPYmpba2V5XSldOyB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBjb3JlXzEuaXNEZWZpbmVkKHR1cGxlKSAmJiBjb3JlXzEuaXNBcnJheSh0dXBsZVsxXSk7IH0pXG4gICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuICh7IG5hbWU6IHR1cGxlWzFdWzJdIHx8IHR1cGxlWzBdLCB0eXBlOiB0dXBsZVsxXVsxXSB9KTsgfSk7IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZUZhY3RvcnkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/templateFactory.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/urlRouterProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/urlRouterProvider.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module url */ /** */\nvar core_1 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\nvar core_2 = __webpack_require__(/*! @uirouter/core */ \"./node_modules/@uirouter/core/lib/index.js\");\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!core_2.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(core_2.services.$injector, _this._router.locationService);\n        };\n        var rule = new core_1.BaseUrlRule(match, core_2.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    ;\n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (core_2.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (core_2.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(core_2.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    ;\n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (core_2.isArray(handler) || core_2.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    ;\n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return core_2.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    ;\n    return UrlRouterProvider;\n}());\nexports.UrlRouterProvider = UrlRouterProvider;\n//# sourceMappingURL=urlRouterProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3VybFJvdXRlclByb3ZpZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktcm91dGVyL2xpYi91cmxSb3V0ZXJQcm92aWRlci5qcz8zNDYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgdXJsICovIC8qKiAqL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcbnZhciBjb3JlXzIgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XG4vKipcbiAqIE1hbmFnZXMgcnVsZXMgZm9yIGNsaWVudC1zaWRlIFVSTFxuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc0FwaV1dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAqXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIHJvdXRlciBydWxlcyBmb3Igd2hhdCB0byBkbyB3aGVuIHRoZSBVUkwgY2hhbmdlcy5cbiAqXG4gKiBUaGlzIHByb3ZpZGVyIHJlbWFpbnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBVcmxSb3V0ZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBVcmxSb3V0ZXJQcm92aWRlcihyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLl91cmxSb3V0ZXIgPSByb3V0ZXIudXJsUm91dGVyO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gdGhpcy5fdXJsUm91dGVyO1xuICAgICAgICB1cmxSb3V0ZXIudXBkYXRlKHRydWUpO1xuICAgICAgICBpZiAoIXVybFJvdXRlci5pbnRlcmNlcHREZWZlcnJlZClcbiAgICAgICAgICAgIHVybFJvdXRlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIHVybFJvdXRlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHVybCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgbG93IGxldmVsIHVybCBoYW5kbGVyIChhIGBydWxlYCkuXG4gICAgICogQSBydWxlIGRldGVjdHMgc3BlY2lmaWMgVVJMIHBhdHRlcm5zIGFuZCByZXR1cm5zIGEgcmVkaXJlY3QsIG9yIHBlcmZvcm1zIHNvbWUgYWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBydWxlIHJldHVybnMgYSBzdHJpbmcsIHRoZSBVUkwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgc3RyaW5nLCBhbmQgYWxsIHJ1bGVzIGFyZSBmaXJlZCBhZ2Fpbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAgICogICAvLyBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgeW91IG1pZ2h0IGFsbG93IGNhc2UgaW5zZW5zaXRpdmUgdXJsc1xuICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLnJ1bGUoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAgICogICAgIHZhciBwYXRoID0gJGxvY2F0aW9uLnBhdGgoKSxcbiAgICAgKiAgICAgICAgIG5vcm1hbGl6ZWQgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICpcbiAgICAgKiAgICAgaWYgKHBhdGggIT09IG5vcm1hbGl6ZWQpIHtcbiAgICAgKiAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVsZUZuXG4gICAgICogSGFuZGxlciBmdW5jdGlvbiB0aGF0IHRha2VzIGAkaW5qZWN0b3JgIGFuZCBgJGxvY2F0aW9uYCBzZXJ2aWNlcyBhcyBhcmd1bWVudHMuXG4gICAgICogWW91IGNhbiB1c2UgdGhlbSB0byBkZXRlY3QgYSB1cmwgYW5kIHJldHVybiBhIGRpZmZlcmVudCB1cmwgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFtbVXJsUm91dGVyUHJvdmlkZXJdXSAoYHRoaXNgKVxuICAgICAqL1xuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGVGbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNvcmVfMi5pc0Z1bmN0aW9uKHJ1bGVGbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZUZuKGNvcmVfMi5zZXJ2aWNlcy4kaW5qZWN0b3IsIF90aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1bGUgPSBuZXcgY29yZV8xLkJhc2VVcmxSdWxlKG1hdGNoLCBjb3JlXzIuaWRlbnRpdHkpO1xuICAgICAgICB0aGlzLl91cmxSb3V0ZXIucnVsZShydWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgcGF0aCBvciBiZWhhdmlvciB0byB1c2Ugd2hlbiBubyB1cmwgY2FuIGJlIG1hdGNoZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAqICAgLy8gaWYgdGhlIHBhdGggZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIHVybHMgeW91IGNvbmZpZ3VyZWRcbiAgICAgKiAgIC8vIG90aGVyd2lzZSB3aWxsIHRha2UgY2FyZSBvZiByb3V0aW5nIHRoZSB1c2VyIHRvIHRoZVxuICAgICAqICAgLy8gc3BlY2lmaWVkIHVybFxuICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2luZGV4Jyk7XG4gICAgICpcbiAgICAgKiAgIC8vIEV4YW1wbGUgb2YgdXNpbmcgZnVuY3Rpb24gcnVsZSBhcyBwYXJhbVxuICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuICcvYS92YWxpZC91cmwnO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVsZVxuICAgICAqIFRoZSB1cmwgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB0byBvciBhIGZ1bmN0aW9uIHJ1bGUgdGhhdCByZXR1cm5zIHRoZSB1cmwgcGF0aCBvciBwZXJmb3JtcyBhIGAkc3RhdGUuZ28oKWAuXG4gICAgICogVGhlIGZ1bmN0aW9uIHZlcnNpb24gaXMgcGFzc2VkIHR3byBwYXJhbXM6IGAkaW5qZWN0b3JgIGFuZCBgJGxvY2F0aW9uYCBzZXJ2aWNlcywgYW5kIHNob3VsZCByZXR1cm4gYSB1cmwgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXG4gICAgICovXG4gICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cmxSb3V0ZXIgPSB0aGlzLl91cmxSb3V0ZXI7XG4gICAgICAgIGlmIChjb3JlXzIuaXNTdHJpbmcocnVsZSkpIHtcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV8yLmlzRnVuY3Rpb24ocnVsZSkpIHtcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gcnVsZShjb3JlXzIuc2VydmljZXMuJGluamVjdG9yLCBfdGhpcy5fcm91dGVyLmxvY2F0aW9uU2VydmljZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICAgKiB0cmVhdGVkIGFzIGEgcmVkaXJlY3QsIGFuZCBpcyBpbnRlcnBvbGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggb2YgbWF0Y2hcbiAgICAgKiAoaS5lLiBsaWtlIGBTdHJpbmcucmVwbGFjZSgpYCBmb3IgYFJlZ0V4cGAsIG9yIGxpa2UgYSBgVXJsTWF0Y2hlcmAgcGF0dGVybiBvdGhlcndpc2UpLlxuICAgICAqXG4gICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW5qZWN0YWJsZS5cbiAgICAgKiBJdCBnZXRzIGludm9rZWQgaWYgYCRsb2NhdGlvbmAgbWF0Y2hlcy5cbiAgICAgKiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgICAqXG4gICAgICogVGhlIGhhbmRsZXIgY2FuIHJldHVyblxuICAgICAqXG4gICAgICogLSAqKmZhbHN5KiogdG8gaW5kaWNhdGUgdGhhdCB0aGUgcnVsZSBkaWRuJ3QgbWF0Y2ggYWZ0ZXIgYWxsLCB0aGVuIGAkdXJsUm91dGVyYFxuICAgICAqICAgd2lsbCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhbm90aGVyIG9uZSB0aGF0IG1hdGNoZXMuXG4gICAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAgICogLSAqKnZvaWQqKiBvciBhbnkgKip0cnV0aHkqKiB2YWx1ZSB0ZWxscyBgJHVybFJvdXRlcmAgdGhhdCB0aGUgdXJsIHdhcyBoYW5kbGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKCRzdGF0ZS51cmwsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgICAqICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPT0gc3RhdGUgfHxcbiAgICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcbiAgICAgKiAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aGF0IEEgcGF0dGVybiBzdHJpbmcgdG8gbWF0Y2gsIGNvbXBpbGVkIGFzIGEgW1tVcmxNYXRjaGVyXV0uXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHBhdGggKG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGgpIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgICAqIEBwYXJhbSBydWxlQ2FsbGJhY2sgW29wdGlvbmFsXSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGBydWxlYCByZWdpc3RlcmVkIHdpdGggW1tVcmxNYXRjaGVyLnJ1bGVdXVxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGhhbmRsZXIgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChjb3JlXzIuaXNBcnJheShoYW5kbGVyKSB8fCBjb3JlXzIuaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyKHRoaXMuX3JvdXRlciwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXJsUm91dGVyLndoZW4od2hhdCwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgO1xuICAgIFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyID0gZnVuY3Rpb24gKHJvdXRlciwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZV8yLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoaGFuZGxlciwgbnVsbCwgeyAkbWF0Y2g6IG1hdGNoLCAkc3RhdGVQYXJhbXM6IHJvdXRlci5nbG9iYWxzLnBhcmFtcyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIG1vbml0b3Jpbmcgb2YgdGhlIFVSTC5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIFVJLVJvdXRlciBoYXMgYm9vdHN0cmFwcGVkLlxuICAgICAqIEl0IHdpbGwgc3RvcCBVSS1Sb3V0ZXIgZnJvbSBwZXJmb3JtaW5nIHRoZSBpbml0aWFsIHVybCBzeW5jLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHBlcmZvcm0gc29tZSBhc3luY2hyb25vdXMgaW5pdGlhbGl6YXRpb24gYmVmb3JlIHRoZSByb3V0ZXIgc3RhcnRzLlxuICAgICAqIE9uY2UgdGhlIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlLCBjYWxsIFtbbGlzdGVuXV0gdG8gdGVsbCBVSS1Sb3V0ZXIgdG8gc3RhcnQgd2F0Y2hpbmcgYW5kIHN5bmNocm9uaXppbmcgdGhlIFVSTC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgIC8vIFByZXZlbnQgJHVybFJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzO1xuICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLmRlZmVySW50ZXJjZXB0KCk7XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGFwcC5ydW4oZnVuY3Rpb24gKE15U2VydmljZSwgJHVybFJvdXRlciwgJGh0dHApIHtcbiAgICAgKiAgICRodHRwLmdldChcIi9zdHVmZlwiKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgKiAgICAgTXlTZXJ2aWNlLmRvU3R1ZmYocmVzcC5kYXRhKTtcbiAgICAgKiAgICAgJHVybFJvdXRlci5saXN0ZW4oKTtcbiAgICAgKiAgICAgJHVybFJvdXRlci5zeW5jKCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWZlciBJbmRpY2F0ZXMgd2hldGhlciB0byBkZWZlciBsb2NhdGlvbiBjaGFuZ2UgaW50ZXJjZXB0aW9uLlxuICAgICAqICAgICAgICBQYXNzaW5nIG5vIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIGB0cnVlYC5cbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHtcbiAgICAgICAgdGhpcy5fdXJsUm91dGVyLmRlZmVySW50ZXJjZXB0KGRlZmVyKTtcbiAgICB9O1xuICAgIDtcbiAgICByZXR1cm4gVXJsUm91dGVyUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5VcmxSb3V0ZXJQcm92aWRlciA9IFVybFJvdXRlclByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyUHJvdmlkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/urlRouterProvider.js\n");

/***/ }),

/***/ "./node_modules/angular-ui-router/lib/viewScroll.js":
/*!**********************************************************!*\
  !*** ./node_modules/angular-ui-router/lib/viewScroll.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar angular_1 = __webpack_require__(/*! ./angular */ \"./node_modules/angular-ui-router/lib/angular.js\");\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nangular_1.ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n//# sourceMappingURL=viewScroll.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3ZpZXdTY3JvbGwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvbGliL3ZpZXdTY3JvbGwuanM/YTM5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIG5nMSAqLyAvKiogKi9cbnZhciBhbmd1bGFyXzEgPSByZXF1aXJlKFwiLi9hbmd1bGFyXCIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uICRWaWV3U2Nyb2xsUHJvdmlkZXIoKSB7XG4gICAgdmFyIHVzZUFuY2hvclNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMudXNlQW5jaG9yU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1c2VBbmNob3JTY3JvbGwgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy4kZ2V0ID0gWyckYW5jaG9yU2Nyb2xsJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRhbmNob3JTY3JvbGwsICR0aW1lb3V0KSB7XG4gICAgICAgICAgICBpZiAodXNlQW5jaG9yU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRhbmNob3JTY3JvbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnRbMF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XTtcbn1cbmFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdWlWaWV3U2Nyb2xsJywgJFZpZXdTY3JvbGxQcm92aWRlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3U2Nyb2xsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/angular-ui-router/lib/viewScroll.js\n");

/***/ })

}]);