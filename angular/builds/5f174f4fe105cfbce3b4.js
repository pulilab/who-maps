(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[607],{

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzPzZhYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_arrayReduce.js\n");

/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlZHVjZS5qcz81OGY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseReduce.js\n");

/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ \"./node_modules/lodash/_arrayReduce.js\"),\n    baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/lodash/_baseEach.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/lodash/_baseIteratee.js\"),\n    baseReduce = __webpack_require__(/*! ./_baseReduce */ \"./node_modules/lodash/_baseReduce.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\");\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzP2M1YTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVJlZHVjZSA9IHJlcXVpcmUoJy4vX2Jhc2VSZWR1Y2UnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/reduce.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/browserify.js":
/*!*****************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/browserify.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SvgPanZoom = __webpack_require__(/*! ./svg-pan-zoom.js */ \"./node_modules/svg-pan-zoom/src/svg-pan-zoom.js\");\n\nmodule.exports = SvgPanZoom;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9icm93c2VyaWZ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N2Zy1wYW4tem9vbS9zcmMvYnJvd3NlcmlmeS5qcz9mOGY5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTdmdQYW5ab29tID0gcmVxdWlyZSgnLi9zdmctcGFuLXpvb20uanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdmdQYW5ab29tO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/browserify.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/control-icons.js":
/*!********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/control-icons.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\");\n\nmodule.exports = {\n  enable: function(instance) {\n    // Select (and create if necessary) defs\n    var defs = instance.svg.querySelector('defs')\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils.svgNS, 'defs')\n      instance.svg.appendChild(defs)\n    }\n\n    // Check for style element, and create it if it doesn't exist\n    var styleEl = defs.querySelector('style#svg-pan-zoom-controls-styles');\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils.svgNS, 'style')\n      style.setAttribute('id', 'svg-pan-zoom-controls-styles')\n      style.setAttribute('type', 'text/css')\n      style.textContent = '.svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }'\n      defs.appendChild(style)\n    }\n\n    // Zoom Group\n    var zoomGroup = document.createElementNS(SvgUtils.svgNS, 'g');\n    zoomGroup.setAttribute('id', 'svg-pan-zoom-controls');\n    zoomGroup.setAttribute('transform', 'translate(' + ( instance.width - 70 ) + ' ' + ( instance.height - 76 ) + ') scale(0.75)');\n    zoomGroup.setAttribute('class', 'svg-pan-zoom-control');\n\n    // Control elements\n    zoomGroup.appendChild(this._createZoomIn(instance))\n    zoomGroup.appendChild(this._createZoomReset(instance))\n    zoomGroup.appendChild(this._createZoomOut(instance))\n\n    // Finally append created element\n    instance.svg.appendChild(zoomGroup)\n\n    // Cache control instance\n    instance.controlIcons = zoomGroup\n  }\n\n, _createZoomIn: function(instance) {\n    var zoomIn = document.createElementNS(SvgUtils.svgNS, 'g');\n    zoomIn.setAttribute('id', 'svg-pan-zoom-zoom-in');\n    zoomIn.setAttribute('transform', 'translate(30.5 5) scale(0.015)');\n    zoomIn.setAttribute('class', 'svg-pan-zoom-control');\n    zoomIn.addEventListener('click', function() {instance.getPublicInstance().zoomIn()}, false)\n    zoomIn.addEventListener('touchstart', function() {instance.getPublicInstance().zoomIn()}, false)\n\n    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomInBackground.setAttribute('x', '0');\n    zoomInBackground.setAttribute('y', '0');\n    zoomInBackground.setAttribute('width', '1500'); // larger than expected because the whole group is transformed to scale down\n    zoomInBackground.setAttribute('height', '1400');\n    zoomInBackground.setAttribute('class', 'svg-pan-zoom-control-background');\n    zoomIn.appendChild(zoomInBackground);\n\n    var zoomInShape = document.createElementNS(SvgUtils.svgNS, 'path');\n    zoomInShape.setAttribute('d', 'M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z');\n    zoomInShape.setAttribute('class', 'svg-pan-zoom-control-element');\n    zoomIn.appendChild(zoomInShape);\n\n    return zoomIn\n  }\n\n, _createZoomReset: function(instance){\n    // reset\n    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, 'g');\n    resetPanZoomControl.setAttribute('id', 'svg-pan-zoom-reset-pan-zoom');\n    resetPanZoomControl.setAttribute('transform', 'translate(5 35) scale(0.4)');\n    resetPanZoomControl.setAttribute('class', 'svg-pan-zoom-control');\n    resetPanZoomControl.addEventListener('click', function() {instance.getPublicInstance().reset()}, false);\n    resetPanZoomControl.addEventListener('touchstart', function() {instance.getPublicInstance().reset()}, false);\n\n    var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier\n    resetPanZoomControlBackground.setAttribute('x', '2');\n    resetPanZoomControlBackground.setAttribute('y', '2');\n    resetPanZoomControlBackground.setAttribute('width', '182'); // larger than expected because the whole group is transformed to scale down\n    resetPanZoomControlBackground.setAttribute('height', '58');\n    resetPanZoomControlBackground.setAttribute('class', 'svg-pan-zoom-control-background');\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n\n    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, 'path');\n    resetPanZoomControlShape1.setAttribute('d', 'M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z');\n    resetPanZoomControlShape1.setAttribute('class', 'svg-pan-zoom-control-element');\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n\n    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, 'path');\n    resetPanZoomControlShape2.setAttribute('d', 'M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z');\n    resetPanZoomControlShape2.setAttribute('class', 'svg-pan-zoom-control-element');\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n\n    return resetPanZoomControl\n  }\n\n, _createZoomOut: function(instance){\n    // zoom out\n    var zoomOut = document.createElementNS(SvgUtils.svgNS, 'g');\n    zoomOut.setAttribute('id', 'svg-pan-zoom-zoom-out');\n    zoomOut.setAttribute('transform', 'translate(30.5 70) scale(0.015)');\n    zoomOut.setAttribute('class', 'svg-pan-zoom-control');\n    zoomOut.addEventListener('click', function() {instance.getPublicInstance().zoomOut()}, false);\n    zoomOut.addEventListener('touchstart', function() {instance.getPublicInstance().zoomOut()}, false);\n\n    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomOutBackground.setAttribute('x', '0');\n    zoomOutBackground.setAttribute('y', '0');\n    zoomOutBackground.setAttribute('width', '1500'); // larger than expected because the whole group is transformed to scale down\n    zoomOutBackground.setAttribute('height', '1400');\n    zoomOutBackground.setAttribute('class', 'svg-pan-zoom-control-background');\n    zoomOut.appendChild(zoomOutBackground);\n\n    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, 'path');\n    zoomOutShape.setAttribute('d', 'M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z');\n    zoomOutShape.setAttribute('class', 'svg-pan-zoom-control-element');\n    zoomOut.appendChild(zoomOutShape);\n\n    return zoomOut\n  }\n\n, disable: function(instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons)\n      instance.controlIcons = null\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9jb250cm9sLWljb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N2Zy1wYW4tem9vbS9zcmMvY29udHJvbC1pY29ucy5qcz9lMGVkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTdmdVdGlscyA9IHJlcXVpcmUoJy4vc3ZnLXV0aWxpdGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5hYmxlOiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgIC8vIFNlbGVjdCAoYW5kIGNyZWF0ZSBpZiBuZWNlc3NhcnkpIGRlZnNcbiAgICB2YXIgZGVmcyA9IGluc3RhbmNlLnN2Zy5xdWVyeVNlbGVjdG9yKCdkZWZzJylcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgIGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdkZWZzJylcbiAgICAgIGluc3RhbmNlLnN2Zy5hcHBlbmRDaGlsZChkZWZzKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzdHlsZSBlbGVtZW50LCBhbmQgY3JlYXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICB2YXIgc3R5bGVFbCA9IGRlZnMucXVlcnlTZWxlY3Rvcignc3R5bGUjc3ZnLXBhbi16b29tLWNvbnRyb2xzLXN0eWxlcycpO1xuICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAnc3R5bGUnKVxuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdzdmctcGFuLXpvb20tY29udHJvbHMtc3R5bGVzJylcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpXG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICcuc3ZnLXBhbi16b29tLWNvbnRyb2wgeyBjdXJzb3I6IHBvaW50ZXI7IGZpbGw6IGJsYWNrOyBmaWxsLW9wYWNpdHk6IDAuMzMzOyB9IC5zdmctcGFuLXpvb20tY29udHJvbDpob3ZlciB7IGZpbGwtb3BhY2l0eTogMC44OyB9IC5zdmctcGFuLXpvb20tY29udHJvbC1iYWNrZ3JvdW5kIHsgZmlsbDogd2hpdGU7IGZpbGwtb3BhY2l0eTogMC41OyB9IC5zdmctcGFuLXpvb20tY29udHJvbC1iYWNrZ3JvdW5kIHsgZmlsbC1vcGFjaXR5OiAwLjg7IH0nXG4gICAgICBkZWZzLmFwcGVuZENoaWxkKHN0eWxlKVxuICAgIH1cblxuICAgIC8vIFpvb20gR3JvdXBcbiAgICB2YXIgem9vbUdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAnZycpO1xuICAgIHpvb21Hcm91cC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3N2Zy1wYW4tem9vbS1jb250cm9scycpO1xuICAgIHpvb21Hcm91cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICggaW5zdGFuY2Uud2lkdGggLSA3MCApICsgJyAnICsgKCBpbnN0YW5jZS5oZWlnaHQgLSA3NiApICsgJykgc2NhbGUoMC43NSknKTtcbiAgICB6b29tR3JvdXAuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbCcpO1xuXG4gICAgLy8gQ29udHJvbCBlbGVtZW50c1xuICAgIHpvb21Hcm91cC5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVab29tSW4oaW5zdGFuY2UpKVxuICAgIHpvb21Hcm91cC5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVab29tUmVzZXQoaW5zdGFuY2UpKVxuICAgIHpvb21Hcm91cC5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVab29tT3V0KGluc3RhbmNlKSlcblxuICAgIC8vIEZpbmFsbHkgYXBwZW5kIGNyZWF0ZWQgZWxlbWVudFxuICAgIGluc3RhbmNlLnN2Zy5hcHBlbmRDaGlsZCh6b29tR3JvdXApXG5cbiAgICAvLyBDYWNoZSBjb250cm9sIGluc3RhbmNlXG4gICAgaW5zdGFuY2UuY29udHJvbEljb25zID0gem9vbUdyb3VwXG4gIH1cblxuLCBfY3JlYXRlWm9vbUluOiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgIHZhciB6b29tSW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdnJyk7XG4gICAgem9vbUluLnNldEF0dHJpYnV0ZSgnaWQnLCAnc3ZnLXBhbi16b29tLXpvb20taW4nKTtcbiAgICB6b29tSW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDMwLjUgNSkgc2NhbGUoMC4wMTUpJyk7XG4gICAgem9vbUluLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wnKTtcbiAgICB6b29tSW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnpvb21JbigpfSwgZmFsc2UpXG4gICAgem9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnpvb21JbigpfSwgZmFsc2UpXG5cbiAgICB2YXIgem9vbUluQmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ3JlY3QnKTsgLy8gVE9ETyBjaGFuZ2UgdGhlc2UgYmFja2dyb3VuZCBzcGFjZSBmaWxsZXJzIHRvIHJvdW5kZWQgcmVjdGFuZ2xlcyBzbyB0aGV5IGxvb2sgcHJldHRpZXJcbiAgICB6b29tSW5CYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgneCcsICcwJyk7XG4gICAgem9vbUluQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCcpO1xuICAgIHpvb21JbkJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxNTAwJyk7IC8vIGxhcmdlciB0aGFuIGV4cGVjdGVkIGJlY2F1c2UgdGhlIHdob2xlIGdyb3VwIGlzIHRyYW5zZm9ybWVkIHRvIHNjYWxlIGRvd25cbiAgICB6b29tSW5CYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzE0MDAnKTtcbiAgICB6b29tSW5CYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wtYmFja2dyb3VuZCcpO1xuICAgIHpvb21Jbi5hcHBlbmRDaGlsZCh6b29tSW5CYWNrZ3JvdW5kKTtcblxuICAgIHZhciB6b29tSW5TaGFwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ3BhdGgnKTtcbiAgICB6b29tSW5TaGFwZS5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTEyODAgNTc2djEyOHEwIDI2IC0xOSA0NXQtNDUgMTloLTMyMHYzMjBxMCAyNiAtMTkgNDV0LTQ1IDE5aC0xMjhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0zMjBoLTMyMHEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTEyOHEwIC0yNiAxOSAtNDV0NDUgLTE5aDMyMHYtMzIwcTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV2MzIwaDMyMHEyNiAwIDQ1IDE5dDE5IDQ1ek0xNTM2IDExMjB2LTk2MCBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6Jyk7XG4gICAgem9vbUluU2hhcGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbC1lbGVtZW50Jyk7XG4gICAgem9vbUluLmFwcGVuZENoaWxkKHpvb21JblNoYXBlKTtcblxuICAgIHJldHVybiB6b29tSW5cbiAgfVxuXG4sIF9jcmVhdGVab29tUmVzZXQ6IGZ1bmN0aW9uKGluc3RhbmNlKXtcbiAgICAvLyByZXNldFxuICAgIHZhciByZXNldFBhblpvb21Db250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAnZycpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2wuc2V0QXR0cmlidXRlKCdpZCcsICdzdmctcGFuLXpvb20tcmVzZXQtcGFuLXpvb20nKTtcbiAgICByZXNldFBhblpvb21Db250cm9sLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSg1IDM1KSBzY2FsZSgwLjQpJyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sJyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge2luc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKCkucmVzZXQoKX0sIGZhbHNlKTtcbiAgICByZXNldFBhblpvb21Db250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlc2V0KCl9LCBmYWxzZSk7XG5cbiAgICB2YXIgcmVzZXRQYW5ab29tQ29udHJvbEJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdyZWN0Jyk7IC8vIFRPRE8gY2hhbmdlIHRoZXNlIGJhY2tncm91bmQgc3BhY2UgZmlsbGVycyB0byByb3VuZGVkIHJlY3RhbmdsZXMgc28gdGhleSBsb29rIHByZXR0aWVyXG4gICAgcmVzZXRQYW5ab29tQ29udHJvbEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd4JywgJzInKTtcbiAgICByZXNldFBhblpvb21Db250cm9sQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3knLCAnMicpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTgyJyk7IC8vIGxhcmdlciB0aGFuIGV4cGVjdGVkIGJlY2F1c2UgdGhlIHdob2xlIGdyb3VwIGlzIHRyYW5zZm9ybWVkIHRvIHNjYWxlIGRvd25cbiAgICByZXNldFBhblpvb21Db250cm9sQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICc1OCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wtYmFja2dyb3VuZCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2wuYXBwZW5kQ2hpbGQocmVzZXRQYW5ab29tQ29udHJvbEJhY2tncm91bmQpO1xuXG4gICAgdmFyIHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdwYXRoJyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbFNoYXBlMS5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTMzLjA1MSwyMC42MzJjLTAuNzQyLTAuNDA2LTEuODU0LTAuNjA5LTMuMzM4LTAuNjA5aC03Ljk2OXY5LjI4MWg3Ljc2OWMxLjU0MywwLDIuNzAxLTAuMTg4LDMuNDczLTAuNTYyYzEuMzY1LTAuNjU2LDIuMDQ4LTEuOTUzLDIuMDQ4LTMuODkxQzM1LjAzMiwyMi43NTcsMzQuMzcyLDIxLjM1MSwzMy4wNTEsMjAuNjMyeicpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTEuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbC1lbGVtZW50Jyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5hcHBlbmRDaGlsZChyZXNldFBhblpvb21Db250cm9sU2hhcGUxKTtcblxuICAgIHZhciByZXNldFBhblpvb21Db250cm9sU2hhcGUyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAncGF0aCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTIuc2V0QXR0cmlidXRlKCdkJywgJ00xNzAuMjMxLDAuNUgxNS44NDdDNy4xMDIsMC41LDAuNSw1LjcwOCwwLjUsMTEuODR2MzguODYxQzAuNSw1Ni44MzMsNy4xMDIsNjEuNSwxNS44NDcsNjEuNWgxNTQuMzg0YzguNzQ1LDAsMTUuMjY5LTQuNjY3LDE1LjI2OS0xMC43OThWMTEuODRDMTg1LjUsNS43MDgsMTc4Ljk3NiwwLjUsMTcwLjIzMSwwLjV6IE00Mi44MzcsNDguNTY5aC03Ljk2OWMtMC4yMTktMC43NjYtMC4zNzUtMS4zODMtMC40NjktMS44NTJjLTAuMTg4LTAuOTY5LTAuMjg5LTEuOTYxLTAuMzA1LTIuOTc3bC0wLjA0Ny0zLjIxMWMtMC4wMy0yLjIwMy0wLjQxLTMuNjcyLTEuMTQyLTQuNDA2Yy0wLjczMi0wLjczNC0yLjEwMy0xLjEwMi00LjExMy0xLjEwMmgtNy4wNXYxMy41NDdoLTcuMDU1VjE0LjAyMmgxNi41MjRjMi4zNjEsMC4wNDcsNC4xNzgsMC4zNDQsNS40NSwwLjg5MWMxLjI3MiwwLjU0NywyLjM1MSwxLjM1MiwzLjIzNCwyLjQxNGMwLjczMSwwLjg3NSwxLjMxLDEuODQ0LDEuNzM3LDIuOTA2czAuNjQsMi4yNzMsMC42NCwzLjYzM2MwLDEuNjQxLTAuNDE0LDMuMjU0LTEuMjQyLDQuODRzLTIuMTk1LDIuNzA3LTQuMTAyLDMuMzYzYzEuNTk0LDAuNjQxLDIuNzIzLDEuNTUxLDMuMzg3LDIuNzNzMC45OTYsMi45OCwwLjk5Niw1LjQwMnYyLjMyYzAsMS41NzgsMC4wNjMsMi42NDgsMC4xOSwzLjIxMWMwLjE5LDAuODkxLDAuNjM1LDEuNTQ3LDEuMzMzLDEuOTY5VjQ4LjU2OXogTTc1LjU3OSw0OC41NjloLTI2LjE4VjE0LjAyMmgyNS4zMzZ2Ni4xMTdINTYuNDU0djcuMzM2aDE2Ljc4MXY2SDU2LjQ1NHY4Ljg4M2gxOS4xMjVWNDguNTY5eiBNMTA0LjQ5Nyw0Ni4zMzFjLTIuNDQsMi4wODYtNS44ODcsMy4xMjktMTAuMzQsMy4xMjljLTQuNTQ4LDAtOC4xMjUtMS4wMjctMTAuNzMxLTMuMDgycy0zLjkwOS00Ljg3OS0zLjkwOS04LjQ3M2g2Ljg5MWMwLjIyNCwxLjU3OCwwLjY2MiwyLjc1OCwxLjMxNiwzLjUzOWMxLjE5NiwxLjQyMiwzLjI0NiwyLjEzMyw2LjE1LDIuMTMzYzEuNzM5LDAsMy4xNTEtMC4xODgsNC4yMzYtMC41NjJjMi4wNTgtMC43MTksMy4wODctMi4wNTUsMy4wODctNC4wMDhjMC0xLjE0MS0wLjUwNC0yLjAyMy0xLjUxMi0yLjY0OGMtMS4wMDgtMC42MDktMi42MDctMS4xNDgtNC43OTYtMS42MTdsLTMuNzQtMC44MmMtMy42NzYtMC44MTItNi4yMDEtMS42OTUtNy41NzYtMi42NDhjLTIuMzI4LTEuNTk0LTMuNDkyLTQuMDg2LTMuNDkyLTcuNDc3YzAtMy4wOTQsMS4xMzktNS42NjQsMy40MTctNy43MTFzNS42MjMtMy4wNywxMC4wMzYtMy4wN2MzLjY4NSwwLDYuODI5LDAuOTY1LDkuNDMxLDIuODk1YzIuNjAyLDEuOTMsMy45NjYsNC43Myw0LjA5Myw4LjQwMmgtNi45MzhjLTAuMTI4LTIuMDc4LTEuMDU3LTMuNTU1LTIuNzg3LTQuNDNjLTEuMTU0LTAuNTc4LTIuNTg3LTAuODY3LTQuMzAxLTAuODY3Yy0xLjkwNywwLTMuNDI4LDAuMzc1LTQuNTY1LDEuMTI1Yy0xLjEzOCwwLjc1LTEuNzA2LDEuNzk3LTEuNzA2LDMuMTQxYzAsMS4yMzQsMC41NjEsMi4xNTYsMS42ODIsMi43NjZjMC43MjEsMC40MDYsMi4yNSwwLjg4Myw0LjU4OSwxLjQzbDYuMDYzLDEuNDNjMi42NTcsMC42MjUsNC42NDgsMS40NjEsNS45NzUsMi41MDhjMi4wNTksMS42MjUsMy4wODksMy45NzcsMy4wODksNy4wNTVDMTA4LjE1Nyw0MS42MjQsMTA2LjkzNyw0NC4yNDUsMTA0LjQ5Nyw0Ni4zMzF6IE0xMzkuNjEsNDguNTY5aC0yNi4xOFYxNC4wMjJoMjUuMzM2djYuMTE3aC0xOC4yODF2Ny4zMzZoMTYuNzgxdjZoLTE2Ljc4MXY4Ljg4M2gxOS4xMjVWNDguNTY5eiBNMTcwLjMzNywyMC4xNGgtMTAuMzM2djI4LjQzaC03LjI2NlYyMC4xNGgtMTAuMzgzdi02LjExN2gyNy45ODRWMjAuMTR6Jyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbFNoYXBlMi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sLWVsZW1lbnQnKTtcbiAgICByZXNldFBhblpvb21Db250cm9sLmFwcGVuZENoaWxkKHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTIpO1xuXG4gICAgcmV0dXJuIHJlc2V0UGFuWm9vbUNvbnRyb2xcbiAgfVxuXG4sIF9jcmVhdGVab29tT3V0OiBmdW5jdGlvbihpbnN0YW5jZSl7XG4gICAgLy8gem9vbSBvdXRcbiAgICB2YXIgem9vbU91dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ2cnKTtcbiAgICB6b29tT3V0LnNldEF0dHJpYnV0ZSgnaWQnLCAnc3ZnLXBhbi16b29tLXpvb20tb3V0Jyk7XG4gICAgem9vbU91dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMzAuNSA3MCkgc2NhbGUoMC4wMTUpJyk7XG4gICAgem9vbU91dC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sJyk7XG4gICAgem9vbU91dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge2luc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKCkuem9vbU91dCgpfSwgZmFsc2UpO1xuICAgIHpvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge2luc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKCkuem9vbU91dCgpfSwgZmFsc2UpO1xuXG4gICAgdmFyIHpvb21PdXRCYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAncmVjdCcpOyAvLyBUT0RPIGNoYW5nZSB0aGVzZSBiYWNrZ3JvdW5kIHNwYWNlIGZpbGxlcnMgdG8gcm91bmRlZCByZWN0YW5nbGVzIHNvIHRoZXkgbG9vayBwcmV0dGllclxuICAgIHpvb21PdXRCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgneCcsICcwJyk7XG4gICAgem9vbU91dEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICB6b29tT3V0QmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzE1MDAnKTsgLy8gbGFyZ2VyIHRoYW4gZXhwZWN0ZWQgYmVjYXVzZSB0aGUgd2hvbGUgZ3JvdXAgaXMgdHJhbnNmb3JtZWQgdG8gc2NhbGUgZG93blxuICAgIHpvb21PdXRCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzE0MDAnKTtcbiAgICB6b29tT3V0QmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sLWJhY2tncm91bmQnKTtcbiAgICB6b29tT3V0LmFwcGVuZENoaWxkKHpvb21PdXRCYWNrZ3JvdW5kKTtcblxuICAgIHZhciB6b29tT3V0U2hhcGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdwYXRoJyk7XG4gICAgem9vbU91dFNoYXBlLnNldEF0dHJpYnV0ZSgnZCcsICdNMTI4MCA1NzZ2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtODk2cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloODk2cTI2IDAgNDUgMTl0MTkgNDV6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41IHQ4NC41IC0yMDMuNXonKTtcbiAgICB6b29tT3V0U2hhcGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbC1lbGVtZW50Jyk7XG4gICAgem9vbU91dC5hcHBlbmRDaGlsZCh6b29tT3V0U2hhcGUpO1xuXG4gICAgcmV0dXJuIHpvb21PdXRcbiAgfVxuXG4sIGRpc2FibGU6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLmNvbnRyb2xJY29ucykge1xuICAgICAgaW5zdGFuY2UuY29udHJvbEljb25zLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5zdGFuY2UuY29udHJvbEljb25zKVxuICAgICAgaW5zdGFuY2UuY29udHJvbEljb25zID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/control-icons.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/shadow-viewport.js":
/*!**********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/shadow-viewport.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\")\n  , Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\")\n  ;\n\nvar ShadowViewport = function(viewport, options){\n  this.init(viewport, options)\n}\n\n/**\n * Initialization\n *\n * @param  {SVGElement} viewport\n * @param  {Object} options\n */\nShadowViewport.prototype.init = function(viewport, options) {\n  // DOM Elements\n  this.viewport = viewport\n  this.options = options\n\n  // State cache\n  this.originalState = {zoom: 1, x: 0, y: 0}\n  this.activeState = {zoom: 1, x: 0, y: 0}\n\n  this.updateCTMCached = Utils.proxy(this.updateCTM, this)\n\n  // Create a custom requestAnimationFrame taking in account refreshRate\n  this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate)\n\n  // ViewBox\n  this.viewBox = {x: 0, y: 0, width: 0, height: 0}\n  this.cacheViewBox()\n\n  // Process CTM\n  var newCTM = this.processCTM()\n\n  // Update viewport CTM and cache zoom and pan\n  this.setCTM(newCTM)\n\n  // Update CTM in this frame\n  this.updateCTM()\n}\n\n/**\n * Cache initial viewBox value\n * If no viewBox is defined, then use viewport size/position instead for viewBox values\n */\nShadowViewport.prototype.cacheViewBox = function() {\n  var svgViewBox = this.options.svg.getAttribute('viewBox')\n\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox.split(/[\\s\\,]/).filter(function(v){return v}).map(parseFloat)\n\n    // Cache viewbox x and y offset\n    this.viewBox.x = viewBoxValues[0]\n    this.viewBox.y = viewBoxValues[1]\n    this.viewBox.width = viewBoxValues[2]\n    this.viewBox.height = viewBoxValues[3]\n\n    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height)\n\n    // Update active state\n    this.activeState.zoom = zoom\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2\n\n    // Force updating CTM\n    this.updateCTMOnNextFrame()\n\n    this.options.svg.removeAttribute('viewBox')\n  } else {\n    this.simpleViewBoxCache()\n  }\n}\n\n/**\n * Recalculate viewport sizes and update viewBox cache\n */\nShadowViewport.prototype.simpleViewBoxCache = function() {\n  var bBox = this.viewport.getBBox()\n\n  this.viewBox.x = bBox.x\n  this.viewBox.y = bBox.y\n  this.viewBox.width = bBox.width\n  this.viewBox.height = bBox.height\n}\n\n/**\n * Returns a viewbox object. Safe to alter\n *\n * @return {Object} viewbox object\n */\nShadowViewport.prototype.getViewBox = function() {\n  return Utils.extend({}, this.viewBox)\n}\n\n/**\n * Get initial zoom and pan values. Save them into originalState\n * Parses viewBox attribute to alter initial sizes\n *\n * @return {CTM} CTM object based on options\n */\nShadowViewport.prototype.processCTM = function() {\n  var newCTM = this.getCTM()\n\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n    if (this.options.fit) {\n      newScale = Math.min(this.options.width/this.viewBox.width, this.options.height/this.viewBox.height);\n    } else {\n      newScale = Math.max(this.options.width/this.viewBox.width, this.options.height/this.viewBox.height);\n    }\n\n    newCTM.a = newScale; //x-scale\n    newCTM.d = newScale; //y-scale\n    newCTM.e = -this.viewBox.x * newScale; //x-transform\n    newCTM.f = -this.viewBox.y * newScale; //y-transform\n  }\n\n  if (this.options.center) {\n    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5\n      , offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5\n\n    newCTM.e = offsetX\n    newCTM.f = offsetY\n  }\n\n  // Cache initial values. Based on activeState and fix+center opitons\n  this.originalState.zoom = newCTM.a\n  this.originalState.x = newCTM.e\n  this.originalState.y = newCTM.f\n\n  return newCTM\n}\n\n/**\n * Return originalState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getOriginalState = function() {\n  return Utils.extend({}, this.originalState)\n}\n\n/**\n * Return actualState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getState = function() {\n  return Utils.extend({}, this.activeState)\n}\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getZoom = function() {\n  return this.activeState.zoom\n}\n\n/**\n * Get zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getRelativeZoom = function() {\n  return this.activeState.zoom / this.originalState.zoom\n}\n\n/**\n * Compute zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.computeRelativeZoom = function(scale) {\n  return scale / this.originalState.zoom\n}\n\n/**\n * Get pan\n *\n * @return {Object}\n */\nShadowViewport.prototype.getPan = function() {\n  return {x: this.activeState.x, y: this.activeState.y}\n}\n\n/**\n * Return cached viewport CTM value that can be safely modified\n *\n * @return {SVGMatrix}\n */\nShadowViewport.prototype.getCTM = function() {\n  var safeCTM = this.options.svg.createSVGMatrix()\n\n  // Copy values manually as in FF they are not itterable\n  safeCTM.a = this.activeState.zoom\n  safeCTM.b = 0\n  safeCTM.c = 0\n  safeCTM.d = this.activeState.zoom\n  safeCTM.e = this.activeState.x\n  safeCTM.f = this.activeState.y\n\n  return safeCTM\n}\n\n/**\n * Set a new CTM\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.setCTM = function(newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM)\n    , willPan = this.isPanDifferent(newCTM)\n\n  if (willZoom || willPan) {\n    // Before zoom\n    if (willZoom) {\n      // If returns false then cancel zooming\n      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {\n        newCTM.a = newCTM.d = this.activeState.zoom\n        willZoom = false\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom())\n      }\n    }\n\n    // Before pan\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {x: newCTM.e, y: newCTM.f})\n          // If prevent pan is an object\n        , preventPanX = false\n        , preventPanY = false\n\n      // If prevent pan is Boolean false\n      if (preventPan === false) {\n        // Set x and y same as before\n        newCTM.e = this.getPan().x\n        newCTM.f = this.getPan().y\n\n        preventPanX = preventPanY = true\n      } else if (Utils.isObject(preventPan)) {\n        // Check for X axes attribute\n        if (preventPan.x === false) {\n          // Prevent panning on x axes\n          newCTM.e = this.getPan().x\n          preventPanX = true\n        } else if (Utils.isNumber(preventPan.x)) {\n          // Set a custom pan value\n          newCTM.e = preventPan.x\n        }\n\n        // Check for Y axes attribute\n        if (preventPan.y === false) {\n          // Prevent panning on x axes\n          newCTM.f = this.getPan().y\n          preventPanY = true\n        } else if (Utils.isNumber(preventPan.y)) {\n          // Set a custom pan value\n          newCTM.f = preventPan.y\n        }\n      }\n\n      // Update willPan flag\n      // Check if newCTM is still different\n      if ((preventPanX && preventPanY) || !this.isPanDifferent(newCTM)) {\n        willPan = false\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    // Check again if should zoom or pan\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame()\n    }\n  }\n}\n\nShadowViewport.prototype.isZoomDifferent = function(newCTM) {\n  return this.activeState.zoom !== newCTM.a\n}\n\nShadowViewport.prototype.isPanDifferent = function(newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f\n}\n\n\n/**\n * Update cached CTM and active state\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.updateCache = function(newCTM) {\n  this.activeState.zoom = newCTM.a\n  this.activeState.x = newCTM.e\n  this.activeState.y = newCTM.f\n}\n\nShadowViewport.prototype.pendingUpdate = false\n\n/**\n * Place a request to update CTM on next Frame\n */\nShadowViewport.prototype.updateCTMOnNextFrame = function() {\n  if (!this.pendingUpdate) {\n    // Lock\n    this.pendingUpdate = true\n\n    // Throttle next update\n    this.requestAnimationFrame.call(window, this.updateCTMCached)\n  }\n}\n\n/**\n * Update viewport CTM with cached CTM\n */\nShadowViewport.prototype.updateCTM = function() {\n  var ctm = this.getCTM()\n\n  // Updates SVG element\n  SvgUtils.setCTM(this.viewport, ctm, this.defs)\n\n  // Free the lock\n  this.pendingUpdate = false\n\n  // Notify about the update\n  if(this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm)\n  }\n}\n\nmodule.exports = function(viewport, options){\n  return new ShadowViewport(viewport, options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9zaGFkb3ctdmlld3BvcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9zaGFkb3ctdmlld3BvcnQuanM/MjFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3ZnVXRpbHMgPSByZXF1aXJlKCcuL3N2Zy11dGlsaXRpZXMnKVxuICAsIFV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKVxuICA7XG5cbnZhciBTaGFkb3dWaWV3cG9ydCA9IGZ1bmN0aW9uKHZpZXdwb3J0LCBvcHRpb25zKXtcbiAgdGhpcy5pbml0KHZpZXdwb3J0LCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdmlld3BvcnRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHZpZXdwb3J0LCBvcHRpb25zKSB7XG4gIC8vIERPTSBFbGVtZW50c1xuICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnRcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuXG4gIC8vIFN0YXRlIGNhY2hlXG4gIHRoaXMub3JpZ2luYWxTdGF0ZSA9IHt6b29tOiAxLCB4OiAwLCB5OiAwfVxuICB0aGlzLmFjdGl2ZVN0YXRlID0ge3pvb206IDEsIHg6IDAsIHk6IDB9XG5cbiAgdGhpcy51cGRhdGVDVE1DYWNoZWQgPSBVdGlscy5wcm94eSh0aGlzLnVwZGF0ZUNUTSwgdGhpcylcblxuICAvLyBDcmVhdGUgYSBjdXN0b20gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRha2luZyBpbiBhY2NvdW50IHJlZnJlc2hSYXRlXG4gIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gVXRpbHMuY3JlYXRlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub3B0aW9ucy5yZWZyZXNoUmF0ZSlcblxuICAvLyBWaWV3Qm94XG4gIHRoaXMudmlld0JveCA9IHt4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwfVxuICB0aGlzLmNhY2hlVmlld0JveCgpXG5cbiAgLy8gUHJvY2VzcyBDVE1cbiAgdmFyIG5ld0NUTSA9IHRoaXMucHJvY2Vzc0NUTSgpXG5cbiAgLy8gVXBkYXRlIHZpZXdwb3J0IENUTSBhbmQgY2FjaGUgem9vbSBhbmQgcGFuXG4gIHRoaXMuc2V0Q1RNKG5ld0NUTSlcblxuICAvLyBVcGRhdGUgQ1RNIGluIHRoaXMgZnJhbWVcbiAgdGhpcy51cGRhdGVDVE0oKVxufVxuXG4vKipcbiAqIENhY2hlIGluaXRpYWwgdmlld0JveCB2YWx1ZVxuICogSWYgbm8gdmlld0JveCBpcyBkZWZpbmVkLCB0aGVuIHVzZSB2aWV3cG9ydCBzaXplL3Bvc2l0aW9uIGluc3RlYWQgZm9yIHZpZXdCb3ggdmFsdWVzXG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5jYWNoZVZpZXdCb3ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN2Z1ZpZXdCb3ggPSB0aGlzLm9wdGlvbnMuc3ZnLmdldEF0dHJpYnV0ZSgndmlld0JveCcpXG5cbiAgaWYgKHN2Z1ZpZXdCb3gpIHtcbiAgICB2YXIgdmlld0JveFZhbHVlcyA9IHN2Z1ZpZXdCb3guc3BsaXQoL1tcXHNcXCxdLykuZmlsdGVyKGZ1bmN0aW9uKHYpe3JldHVybiB2fSkubWFwKHBhcnNlRmxvYXQpXG5cbiAgICAvLyBDYWNoZSB2aWV3Ym94IHggYW5kIHkgb2Zmc2V0XG4gICAgdGhpcy52aWV3Qm94LnggPSB2aWV3Qm94VmFsdWVzWzBdXG4gICAgdGhpcy52aWV3Qm94LnkgPSB2aWV3Qm94VmFsdWVzWzFdXG4gICAgdGhpcy52aWV3Qm94LndpZHRoID0gdmlld0JveFZhbHVlc1syXVxuICAgIHRoaXMudmlld0JveC5oZWlnaHQgPSB2aWV3Qm94VmFsdWVzWzNdXG5cbiAgICB2YXIgem9vbSA9IE1hdGgubWluKHRoaXMub3B0aW9ucy53aWR0aCAvIHRoaXMudmlld0JveC53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCAvIHRoaXMudmlld0JveC5oZWlnaHQpXG5cbiAgICAvLyBVcGRhdGUgYWN0aXZlIHN0YXRlXG4gICAgdGhpcy5hY3RpdmVTdGF0ZS56b29tID0gem9vbVxuICAgIHRoaXMuYWN0aXZlU3RhdGUueCA9ICh0aGlzLm9wdGlvbnMud2lkdGggLSB0aGlzLnZpZXdCb3gud2lkdGggKiB6b29tKSAvIDJcbiAgICB0aGlzLmFjdGl2ZVN0YXRlLnkgPSAodGhpcy5vcHRpb25zLmhlaWdodCAtIHRoaXMudmlld0JveC5oZWlnaHQgKiB6b29tKSAvIDJcblxuICAgIC8vIEZvcmNlIHVwZGF0aW5nIENUTVxuICAgIHRoaXMudXBkYXRlQ1RNT25OZXh0RnJhbWUoKVxuXG4gICAgdGhpcy5vcHRpb25zLnN2Zy5yZW1vdmVBdHRyaWJ1dGUoJ3ZpZXdCb3gnKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc2ltcGxlVmlld0JveENhY2hlKClcbiAgfVxufVxuXG4vKipcbiAqIFJlY2FsY3VsYXRlIHZpZXdwb3J0IHNpemVzIGFuZCB1cGRhdGUgdmlld0JveCBjYWNoZVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuc2ltcGxlVmlld0JveENhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiQm94ID0gdGhpcy52aWV3cG9ydC5nZXRCQm94KClcblxuICB0aGlzLnZpZXdCb3gueCA9IGJCb3gueFxuICB0aGlzLnZpZXdCb3gueSA9IGJCb3gueVxuICB0aGlzLnZpZXdCb3gud2lkdGggPSBiQm94LndpZHRoXG4gIHRoaXMudmlld0JveC5oZWlnaHQgPSBiQm94LmhlaWdodFxufVxuXG4vKipcbiAqIFJldHVybnMgYSB2aWV3Ym94IG9iamVjdC4gU2FmZSB0byBhbHRlclxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdmlld2JveCBvYmplY3RcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmdldFZpZXdCb3ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7fSwgdGhpcy52aWV3Qm94KVxufVxuXG4vKipcbiAqIEdldCBpbml0aWFsIHpvb20gYW5kIHBhbiB2YWx1ZXMuIFNhdmUgdGhlbSBpbnRvIG9yaWdpbmFsU3RhdGVcbiAqIFBhcnNlcyB2aWV3Qm94IGF0dHJpYnV0ZSB0byBhbHRlciBpbml0aWFsIHNpemVzXG4gKlxuICogQHJldHVybiB7Q1RNfSBDVE0gb2JqZWN0IGJhc2VkIG9uIG9wdGlvbnNcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLnByb2Nlc3NDVE0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5ld0NUTSA9IHRoaXMuZ2V0Q1RNKClcblxuICBpZiAodGhpcy5vcHRpb25zLmZpdCB8fCB0aGlzLm9wdGlvbnMuY29udGFpbikge1xuICAgIHZhciBuZXdTY2FsZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpdCkge1xuICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMud2lkdGgvdGhpcy52aWV3Qm94LndpZHRoLCB0aGlzLm9wdGlvbnMuaGVpZ2h0L3RoaXMudmlld0JveC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTY2FsZSA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aC90aGlzLnZpZXdCb3gud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQvdGhpcy52aWV3Qm94LmhlaWdodCk7XG4gICAgfVxuXG4gICAgbmV3Q1RNLmEgPSBuZXdTY2FsZTsgLy94LXNjYWxlXG4gICAgbmV3Q1RNLmQgPSBuZXdTY2FsZTsgLy95LXNjYWxlXG4gICAgbmV3Q1RNLmUgPSAtdGhpcy52aWV3Qm94LnggKiBuZXdTY2FsZTsgLy94LXRyYW5zZm9ybVxuICAgIG5ld0NUTS5mID0gLXRoaXMudmlld0JveC55ICogbmV3U2NhbGU7IC8veS10cmFuc2Zvcm1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuY2VudGVyKSB7XG4gICAgdmFyIG9mZnNldFggPSAodGhpcy5vcHRpb25zLndpZHRoIC0gKHRoaXMudmlld0JveC53aWR0aCArIHRoaXMudmlld0JveC54ICogMikgKiBuZXdDVE0uYSkgKiAwLjVcbiAgICAgICwgb2Zmc2V0WSA9ICh0aGlzLm9wdGlvbnMuaGVpZ2h0IC0gKHRoaXMudmlld0JveC5oZWlnaHQgKyB0aGlzLnZpZXdCb3gueSAqIDIpICogbmV3Q1RNLmEpICogMC41XG5cbiAgICBuZXdDVE0uZSA9IG9mZnNldFhcbiAgICBuZXdDVE0uZiA9IG9mZnNldFlcbiAgfVxuXG4gIC8vIENhY2hlIGluaXRpYWwgdmFsdWVzLiBCYXNlZCBvbiBhY3RpdmVTdGF0ZSBhbmQgZml4K2NlbnRlciBvcGl0b25zXG4gIHRoaXMub3JpZ2luYWxTdGF0ZS56b29tID0gbmV3Q1RNLmFcbiAgdGhpcy5vcmlnaW5hbFN0YXRlLnggPSBuZXdDVE0uZVxuICB0aGlzLm9yaWdpbmFsU3RhdGUueSA9IG5ld0NUTS5mXG5cbiAgcmV0dXJuIG5ld0NUTVxufVxuXG4vKipcbiAqIFJldHVybiBvcmlnaW5hbFN0YXRlIG9iamVjdC4gU2FmZSB0byBhbHRlclxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmdldE9yaWdpbmFsU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5vcmlnaW5hbFN0YXRlKVxufVxuXG4vKipcbiAqIFJldHVybiBhY3R1YWxTdGF0ZSBvYmplY3QuIFNhZmUgdG8gYWx0ZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmFjdGl2ZVN0YXRlKVxufVxuXG4vKipcbiAqIEdldCB6b29tIHNjYWxlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIEdldCB6b29tIHNjYWxlIGZvciBwdWJpbGMgdXNhZ2VcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdH0gem9vbSBzY2FsZVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuZ2V0UmVsYXRpdmVab29tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlLnpvb20gLyB0aGlzLm9yaWdpbmFsU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIENvbXB1dGUgem9vbSBzY2FsZSBmb3IgcHViaWxjIHVzYWdlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmNvbXB1dGVSZWxhdGl2ZVpvb20gPSBmdW5jdGlvbihzY2FsZSkge1xuICByZXR1cm4gc2NhbGUgLyB0aGlzLm9yaWdpbmFsU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIEdldCBwYW5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRQYW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHt4OiB0aGlzLmFjdGl2ZVN0YXRlLngsIHk6IHRoaXMuYWN0aXZlU3RhdGUueX1cbn1cblxuLyoqXG4gKiBSZXR1cm4gY2FjaGVkIHZpZXdwb3J0IENUTSB2YWx1ZSB0aGF0IGNhbiBiZSBzYWZlbHkgbW9kaWZpZWRcbiAqXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRDVE0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNhZmVDVE0gPSB0aGlzLm9wdGlvbnMuc3ZnLmNyZWF0ZVNWR01hdHJpeCgpXG5cbiAgLy8gQ29weSB2YWx1ZXMgbWFudWFsbHkgYXMgaW4gRkYgdGhleSBhcmUgbm90IGl0dGVyYWJsZVxuICBzYWZlQ1RNLmEgPSB0aGlzLmFjdGl2ZVN0YXRlLnpvb21cbiAgc2FmZUNUTS5iID0gMFxuICBzYWZlQ1RNLmMgPSAwXG4gIHNhZmVDVE0uZCA9IHRoaXMuYWN0aXZlU3RhdGUuem9vbVxuICBzYWZlQ1RNLmUgPSB0aGlzLmFjdGl2ZVN0YXRlLnhcbiAgc2FmZUNUTS5mID0gdGhpcy5hY3RpdmVTdGF0ZS55XG5cbiAgcmV0dXJuIHNhZmVDVE1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXcgQ1RNXG4gKlxuICogQHBhcmFtIHtTVkdNYXRyaXh9IG5ld0NUTVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuc2V0Q1RNID0gZnVuY3Rpb24obmV3Q1RNKSB7XG4gIHZhciB3aWxsWm9vbSA9IHRoaXMuaXNab29tRGlmZmVyZW50KG5ld0NUTSlcbiAgICAsIHdpbGxQYW4gPSB0aGlzLmlzUGFuRGlmZmVyZW50KG5ld0NUTSlcblxuICBpZiAod2lsbFpvb20gfHwgd2lsbFBhbikge1xuICAgIC8vIEJlZm9yZSB6b29tXG4gICAgaWYgKHdpbGxab29tKSB7XG4gICAgICAvLyBJZiByZXR1cm5zIGZhbHNlIHRoZW4gY2FuY2VsIHpvb21pbmdcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmVmb3JlWm9vbSh0aGlzLmdldFJlbGF0aXZlWm9vbSgpLCB0aGlzLmNvbXB1dGVSZWxhdGl2ZVpvb20obmV3Q1RNLmEpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmV3Q1RNLmEgPSBuZXdDVE0uZCA9IHRoaXMuYWN0aXZlU3RhdGUuem9vbVxuICAgICAgICB3aWxsWm9vbSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKG5ld0NUTSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblpvb20odGhpcy5nZXRSZWxhdGl2ZVpvb20oKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCZWZvcmUgcGFuXG4gICAgaWYgKHdpbGxQYW4pIHtcbiAgICAgIHZhciBwcmV2ZW50UGFuID0gdGhpcy5vcHRpb25zLmJlZm9yZVBhbih0aGlzLmdldFBhbigpLCB7eDogbmV3Q1RNLmUsIHk6IG5ld0NUTS5mfSlcbiAgICAgICAgICAvLyBJZiBwcmV2ZW50IHBhbiBpcyBhbiBvYmplY3RcbiAgICAgICAgLCBwcmV2ZW50UGFuWCA9IGZhbHNlXG4gICAgICAgICwgcHJldmVudFBhblkgPSBmYWxzZVxuXG4gICAgICAvLyBJZiBwcmV2ZW50IHBhbiBpcyBCb29sZWFuIGZhbHNlXG4gICAgICBpZiAocHJldmVudFBhbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gU2V0IHggYW5kIHkgc2FtZSBhcyBiZWZvcmVcbiAgICAgICAgbmV3Q1RNLmUgPSB0aGlzLmdldFBhbigpLnhcbiAgICAgICAgbmV3Q1RNLmYgPSB0aGlzLmdldFBhbigpLnlcblxuICAgICAgICBwcmV2ZW50UGFuWCA9IHByZXZlbnRQYW5ZID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdChwcmV2ZW50UGFuKSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgWCBheGVzIGF0dHJpYnV0ZVxuICAgICAgICBpZiAocHJldmVudFBhbi54ID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgcGFubmluZyBvbiB4IGF4ZXNcbiAgICAgICAgICBuZXdDVE0uZSA9IHRoaXMuZ2V0UGFuKCkueFxuICAgICAgICAgIHByZXZlbnRQYW5YID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzTnVtYmVyKHByZXZlbnRQYW4ueCkpIHtcbiAgICAgICAgICAvLyBTZXQgYSBjdXN0b20gcGFuIHZhbHVlXG4gICAgICAgICAgbmV3Q1RNLmUgPSBwcmV2ZW50UGFuLnhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBZIGF4ZXMgYXR0cmlidXRlXG4gICAgICAgIGlmIChwcmV2ZW50UGFuLnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBwYW5uaW5nIG9uIHggYXhlc1xuICAgICAgICAgIG5ld0NUTS5mID0gdGhpcy5nZXRQYW4oKS55XG4gICAgICAgICAgcHJldmVudFBhblkgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNOdW1iZXIocHJldmVudFBhbi55KSkge1xuICAgICAgICAgIC8vIFNldCBhIGN1c3RvbSBwYW4gdmFsdWVcbiAgICAgICAgICBuZXdDVE0uZiA9IHByZXZlbnRQYW4ueVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB3aWxsUGFuIGZsYWdcbiAgICAgIC8vIENoZWNrIGlmIG5ld0NUTSBpcyBzdGlsbCBkaWZmZXJlbnRcbiAgICAgIGlmICgocHJldmVudFBhblggJiYgcHJldmVudFBhblkpIHx8ICF0aGlzLmlzUGFuRGlmZmVyZW50KG5ld0NUTSkpIHtcbiAgICAgICAgd2lsbFBhbiA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKG5ld0NUTSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblBhbih0aGlzLmdldFBhbigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhZ2FpbiBpZiBzaG91bGQgem9vbSBvciBwYW5cbiAgICBpZiAod2lsbFpvb20gfHwgd2lsbFBhbikge1xuICAgICAgdGhpcy51cGRhdGVDVE1Pbk5leHRGcmFtZSgpXG4gICAgfVxuICB9XG59XG5cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5pc1pvb21EaWZmZXJlbnQgPSBmdW5jdGlvbihuZXdDVE0pIHtcbiAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGUuem9vbSAhPT0gbmV3Q1RNLmFcbn1cblxuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmlzUGFuRGlmZmVyZW50ID0gZnVuY3Rpb24obmV3Q1RNKSB7XG4gIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlLnggIT09IG5ld0NUTS5lIHx8IHRoaXMuYWN0aXZlU3RhdGUueSAhPT0gbmV3Q1RNLmZcbn1cblxuXG4vKipcbiAqIFVwZGF0ZSBjYWNoZWQgQ1RNIGFuZCBhY3RpdmUgc3RhdGVcbiAqXG4gKiBAcGFyYW0ge1NWR01hdHJpeH0gbmV3Q1RNXG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKG5ld0NUTSkge1xuICB0aGlzLmFjdGl2ZVN0YXRlLnpvb20gPSBuZXdDVE0uYVxuICB0aGlzLmFjdGl2ZVN0YXRlLnggPSBuZXdDVE0uZVxuICB0aGlzLmFjdGl2ZVN0YXRlLnkgPSBuZXdDVE0uZlxufVxuXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlXG5cbi8qKlxuICogUGxhY2UgYSByZXF1ZXN0IHRvIHVwZGF0ZSBDVE0gb24gbmV4dCBGcmFtZVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUudXBkYXRlQ1RNT25OZXh0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnBlbmRpbmdVcGRhdGUpIHtcbiAgICAvLyBMb2NrXG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlID0gdHJ1ZVxuXG4gICAgLy8gVGhyb3R0bGUgbmV4dCB1cGRhdGVcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgdGhpcy51cGRhdGVDVE1DYWNoZWQpXG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgdmlld3BvcnQgQ1RNIHdpdGggY2FjaGVkIENUTVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUudXBkYXRlQ1RNID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdG0gPSB0aGlzLmdldENUTSgpXG5cbiAgLy8gVXBkYXRlcyBTVkcgZWxlbWVudFxuICBTdmdVdGlscy5zZXRDVE0odGhpcy52aWV3cG9ydCwgY3RtLCB0aGlzLmRlZnMpXG5cbiAgLy8gRnJlZSB0aGUgbG9ja1xuICB0aGlzLnBlbmRpbmdVcGRhdGUgPSBmYWxzZVxuXG4gIC8vIE5vdGlmeSBhYm91dCB0aGUgdXBkYXRlXG4gIGlmKHRoaXMub3B0aW9ucy5vblVwZGF0ZWRDVE0pIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGVkQ1RNKGN0bSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZpZXdwb3J0LCBvcHRpb25zKXtcbiAgcmV0dXJuIG5ldyBTaGFkb3dWaWV3cG9ydCh2aWV3cG9ydCwgb3B0aW9ucylcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/shadow-viewport.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/svg-pan-zoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/svg-pan-zoom.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Wheel = __webpack_require__(/*! ./uniwheel */ \"./node_modules/svg-pan-zoom/src/uniwheel.js\")\n, ControlIcons = __webpack_require__(/*! ./control-icons */ \"./node_modules/svg-pan-zoom/src/control-icons.js\")\n, Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\")\n, SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\")\n, ShadowViewport = __webpack_require__(/*! ./shadow-viewport */ \"./node_modules/svg-pan-zoom/src/shadow-viewport.js\")\n\nvar SvgPanZoom = function(svg, options) {\n  this.init(svg, options)\n}\n\nvar optionsDefaults = {\n  viewportSelector: '.svg-pan-zoom_viewport' // Viewport selector. Can be querySelector string or SVGElement\n, panEnabled: true // enable or disable panning (default enabled)\n, controlIconsEnabled: false // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n, zoomEnabled: true // enable or disable zooming (default enabled)\n, dblClickZoomEnabled: true // enable or disable zooming by double clicking (default enabled)\n, mouseWheelZoomEnabled: true // enable or disable zooming by mouse wheel (default enabled)\n, preventMouseEventsDefault: true // enable or disable preventDefault for mouse events\n, zoomScaleSensitivity: 0.1 // Zoom sensitivity\n, minZoom: 0.5 // Minimum Zoom level\n, maxZoom: 10 // Maximum Zoom level\n, fit: true // enable or disable viewport fit in SVG (default true)\n, contain: false // enable or disable viewport contain the svg (default false)\n, center: true // enable or disable viewport centering in SVG (default true)\n, refreshRate: 'auto' // Maximum number of frames per second (altering SVG's viewport)\n, beforeZoom: null\n, onZoom: null\n, beforePan: null\n, onPan: null\n, customEventsHandler: null\n, eventsListenerElement: null\n, onUpdatedCTM: null\n}\n\nSvgPanZoom.prototype.init = function(svg, options) {\n  var that = this\n\n  this.svg = svg\n  this.defs = svg.querySelector('defs')\n\n  // Add default attributes to SVG\n  SvgUtils.setupSvgAttributes(this.svg)\n\n  // Set options\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options)\n\n  // Set default state\n  this.state = 'none'\n\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg)\n  this.width = boundingClientRectNormalized.width\n  this.height = boundingClientRectNormalized.height\n\n  // Init shadow viewport\n  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {\n    svg: this.svg\n  , width: this.width\n  , height: this.height\n  , fit: this.options.fit\n  , contain: this.options.contain\n  , center: this.options.center\n  , refreshRate: this.options.refreshRate\n  // Put callbacks into functions as they can change through time\n  , beforeZoom: function(oldScale, newScale) {\n      if (that.viewport && that.options.beforeZoom) {return that.options.beforeZoom(oldScale, newScale)}\n    }\n  , onZoom: function(scale) {\n      if (that.viewport && that.options.onZoom) {return that.options.onZoom(scale)}\n    }\n  , beforePan: function(oldPoint, newPoint) {\n      if (that.viewport && that.options.beforePan) {return that.options.beforePan(oldPoint, newPoint)}\n    }\n  , onPan: function(point) {\n      if (that.viewport && that.options.onPan) {return that.options.onPan(point)}\n    }\n  , onUpdatedCTM: function(ctm) {\n      if (that.viewport && that.options.onUpdatedCTM) {return that.options.onUpdatedCTM(ctm)}\n    }\n  })\n\n  // Wrap callbacks into public API context\n  var publicInstance = this.getPublicInstance()\n  publicInstance.setBeforeZoom(this.options.beforeZoom)\n  publicInstance.setOnZoom(this.options.onZoom)\n  publicInstance.setBeforePan(this.options.beforePan)\n  publicInstance.setOnPan(this.options.onPan)\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM)\n\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this)\n  }\n\n  // Init events handlers\n  this.lastMouseWheelEventTime = Date.now()\n  this.setupHandlers()\n}\n\n/**\n * Register event handlers\n */\nSvgPanZoom.prototype.setupHandlers = function() {\n  var that = this\n    , prevEvt = null // use for touchstart event to detect double tap\n    ;\n\n  this.eventListeners = {\n    // Mouse down group\n    mousedown: function(evt) {\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt\n      return result;\n    }\n  , touchstart: function(evt) {\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt\n      return result;\n    }\n\n    // Mouse up group\n  , mouseup: function(evt) {\n      return that.handleMouseUp(evt);\n    }\n  , touchend: function(evt) {\n      return that.handleMouseUp(evt);\n    }\n\n    // Mouse move group\n  , mousemove: function(evt) {\n      return that.handleMouseMove(evt);\n    }\n  , touchmove: function(evt) {\n      return that.handleMouseMove(evt);\n    }\n\n    // Mouse leave group\n  , mouseleave: function(evt) {\n      return that.handleMouseUp(evt);\n    }\n  , touchleave: function(evt) {\n      return that.handleMouseUp(evt);\n    }\n  , touchcancel: function(evt) {\n      return that.handleMouseUp(evt);\n    }\n  }\n\n  // Init custom events handler if available\n  if (this.options.customEventsHandler != null) { // jshint ignore:line\n    this.options.customEventsHandler.init({\n      svgElement: this.svg\n    , eventsListenerElement: this.options.eventsListenerElement\n    , instance: this.getPublicInstance()\n    })\n\n    // Custom event handler may halt builtin listeners\n    var haltEventListeners = this.options.customEventsHandler.haltEventListeners\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]]\n        }\n      }\n    }\n  }\n\n  // Bind eventListeners\n  for (var event in this.eventListeners) {\n    // Attach event to eventsListenerElement or SVG if not available\n    (this.options.eventsListenerElement || this.svg)\n      .addEventListener(event, this.eventListeners[event], false)\n  }\n\n  // Zoom using mouse wheel\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false // set to false as enable will set it back to true\n    this.enableMouseWheelZoom()\n  }\n}\n\n/**\n * Enable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.enableMouseWheelZoom = function() {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this\n\n    // Mouse wheel listener\n    this.wheelListener = function(evt) {\n      return that.handleMouseWheel(evt);\n    }\n\n    // Bind wheelListener\n    Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, false)\n\n    this.options.mouseWheelZoomEnabled = true\n  }\n}\n\n/**\n * Disable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.disableMouseWheelZoom = function() {\n  if (this.options.mouseWheelZoomEnabled) {\n    Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, false)\n    this.options.mouseWheelZoomEnabled = false\n  }\n}\n\n/**\n * Handle mouse wheel event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseWheel = function(evt) {\n  if (!this.options.zoomEnabled || this.state !== 'none') {\n    return;\n  }\n\n  if (this.options.preventMouseEventsDefault){\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Default delta in case that deltaY is not available\n  var delta = evt.deltaY || 1\n    , timeDelta = Date.now() - this.lastMouseWheelEventTime\n    , divider = 3 + Math.max(0, 30 - timeDelta)\n\n  // Update cache\n  this.lastMouseWheelEventTime = Date.now()\n\n  // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)\n  if ('deltaMode' in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 :  Math.abs(evt.wheelDelta) / evt.deltaY\n  }\n\n  delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider\n\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse()\n    , relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM)\n    , zoom = Math.pow(1 + this.options.zoomScaleSensitivity, (-1) * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior\n\n  this.zoomAtPoint(zoom, relativeMousePoint)\n}\n\n/**\n * Zoom in at a SVG point\n *\n * @param  {SVGPoint} point\n * @param  {Float} zoomScale    Number representing how much to zoom\n * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.\n *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)\n */\nSvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState()\n\n  if (!zoomAbsolute) {\n    // Fit zoomScale in set bounds\n    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {\n      zoomScale = (this.options.minZoom * originalState.zoom) / this.getZoom()\n    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {\n      zoomScale = (this.options.maxZoom * originalState.zoom) / this.getZoom()\n    }\n  } else {\n    // Fit zoomScale in set bounds\n    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale))\n    // Find relative scale to achieve desired scale\n    zoomScale = zoomScale/this.getZoom()\n  }\n\n  var oldCTM = this.viewport.getCTM()\n    , relativePoint = point.matrixTransform(oldCTM.inverse())\n    , modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y)\n    , newCTM = oldCTM.multiply(modifier)\n\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM)\n  }\n}\n\n/**\n * Zoom at center point\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.zoom = function(scale, absolute) {\n  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute)\n}\n\n/**\n * Zoom used by public instance\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoom = function(scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale)\n  }\n\n  this.zoom(scale, absolute)\n}\n\n/**\n * Zoom at point used by public instance\n *\n * @param  {Float} scale\n * @param  {SVGPoint|Object} point    An object that has x and y attributes\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {\n  if (absolute) {\n    // Transform zoom into a relative value\n    scale = this.computeFromRelativeZoom(scale)\n  }\n\n  // If not a SVGPoint but has x and y then create a SVGPoint\n  if (Utils.getType(point) !== 'SVGPoint') {\n    if('x' in point && 'y' in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y)\n    } else {\n      throw new Error('Given point is invalid')\n    }\n  }\n\n  this.zoomAtPoint(scale, point, absolute)\n}\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getZoom = function() {\n  return this.viewport.getZoom()\n}\n\n/**\n * Get zoom scale for public usage\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getRelativeZoom = function() {\n  return this.viewport.getRelativeZoom()\n}\n\n/**\n * Compute actual zoom from public zoom\n *\n * @param  {Float} zoom\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {\n  return zoom * this.viewport.getOriginalState().zoom\n}\n\n/**\n * Set zoom to initial state\n */\nSvgPanZoom.prototype.resetZoom = function() {\n  var originalState = this.viewport.getOriginalState()\n\n  this.zoom(originalState.zoom, true);\n}\n\n/**\n * Set pan to initial state\n */\nSvgPanZoom.prototype.resetPan = function() {\n  this.pan(this.viewport.getOriginalState());\n}\n\n/**\n * Set pan and zoom to initial state\n */\nSvgPanZoom.prototype.reset = function() {\n  this.resetZoom()\n  this.resetPan()\n}\n\n/**\n * Handle double click event\n * See handleMouseDown() for alternate detection method\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleDblClick = function(evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault()\n    } else {\n      evt.returnValue = false\n    }\n  }\n\n  // Check if target was a control button\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute('class') || ''\n    if (targetClass.indexOf('svg-pan-zoom-control') > -1) {\n      return false\n    }\n  }\n\n  var zoomFactor\n\n  if (evt.shiftKey) {\n    zoomFactor = 1/((1 + this.options.zoomScaleSensitivity) * 2) // zoom out when shift key pressed\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2\n  }\n\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse())\n  this.zoomAtPoint(zoomFactor, point)\n}\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault()\n    } else {\n      evt.returnValue = false\n    }\n  }\n\n  Utils.mouseAndTouchNormalize(evt, this.svg)\n\n  // Double click detection; more consistent than ondblclick\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)){\n    this.handleDblClick(evt)\n  } else {\n    // Pan mode\n    this.state = 'pan'\n    this.firstEventCTM = this.viewport.getCTM()\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse())\n  }\n}\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseMove = function(evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault()\n    } else {\n      evt.returnValue = false\n    }\n  }\n\n  if (this.state === 'pan' && this.options.panEnabled) {\n    // Pan mode\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse())\n      , viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y)\n\n    this.viewport.setCTM(viewportCTM)\n  }\n}\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseUp = function(evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault()\n    } else {\n      evt.returnValue = false\n    }\n  }\n\n  if (this.state === 'pan') {\n    // Quit pan mode\n    this.state = 'none'\n  }\n}\n\n/**\n * Adjust viewport size (only) so it will fit in SVG\n * Does not center image\n */\nSvgPanZoom.prototype.fit = function() {\n  var viewBox = this.viewport.getViewBox()\n    , newScale = Math.min(this.width/viewBox.width, this.height/viewBox.height)\n\n  this.zoom(newScale, true)\n}\n\n/**\n * Adjust viewport size (only) so it will contain the SVG\n * Does not center image\n */\nSvgPanZoom.prototype.contain = function() {\n  var viewBox = this.viewport.getViewBox()\n    , newScale = Math.max(this.width/viewBox.width, this.height/viewBox.height)\n\n  this.zoom(newScale, true)\n}\n\n/**\n * Adjust viewport pan (only) so it will be centered in SVG\n * Does not zoom/fit/contain image\n */\nSvgPanZoom.prototype.center = function() {\n  var viewBox = this.viewport.getViewBox()\n    , offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5\n    , offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5\n\n  this.getPublicInstance().pan({x: offsetX, y: offsetY})\n}\n\n/**\n * Update content cached BorderBox\n * Use when viewport contents change\n */\nSvgPanZoom.prototype.updateBBox = function() {\n  this.viewport.simpleViewBoxCache()\n}\n\n/**\n * Pan to a rendered position\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.pan = function(point) {\n  var viewportCTM = this.viewport.getCTM()\n  viewportCTM.e = point.x\n  viewportCTM.f = point.y\n  this.viewport.setCTM(viewportCTM)\n}\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.panBy = function(point) {\n  var viewportCTM = this.viewport.getCTM()\n  viewportCTM.e += point.x\n  viewportCTM.f += point.y\n  this.viewport.setCTM(viewportCTM)\n}\n\n/**\n * Get pan vector\n *\n * @return {Object} {x: 0, y: 0}\n */\nSvgPanZoom.prototype.getPan = function() {\n  var state = this.viewport.getState()\n\n  return {x: state.x, y: state.y}\n}\n\n/**\n * Recalculates cached svg dimensions and controls position\n */\nSvgPanZoom.prototype.resize = function() {\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg)\n  this.width = boundingClientRectNormalized.width\n  this.height = boundingClientRectNormalized.height\n\n  // Recalculate original state\n  var viewport = this.viewport\n  viewport.options.width = this.width\n  viewport.options.height = this.height\n  viewport.processCTM()\n\n  // Reposition control icons by re-enabling them\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons()\n    this.getPublicInstance().enableControlIcons()\n  }\n}\n\n/**\n * Unbind mouse events, free callbacks and destroy public instance\n */\nSvgPanZoom.prototype.destroy = function() {\n  var that = this\n\n  // Free callbacks\n  this.beforeZoom = null\n  this.onZoom = null\n  this.beforePan = null\n  this.onPan = null\n  this.onUpdatedCTM = null\n\n  // Destroy custom event handlers\n  if (this.options.customEventsHandler != null) { // jshint ignore:line\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg\n    , eventsListenerElement: this.options.eventsListenerElement\n    , instance: this.getPublicInstance()\n    })\n  }\n\n  // Unbind eventListeners\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg)\n      .removeEventListener(event, this.eventListeners[event], false)\n  }\n\n  // Unbind wheelListener\n  this.disableMouseWheelZoom()\n\n  // Remove control icons\n  this.getPublicInstance().disableControlIcons()\n\n  // Reset zoom and pan\n  this.reset()\n\n  // Remove instance from instancesStore\n  instancesStore = instancesStore.filter(function(instance){\n    return instance.svg !== that.svg\n  })\n\n  // Delete options and its contents\n  delete this.options\n\n  // Delete viewport to make public shadow viewport functions uncallable\n  delete this.viewport\n\n  // Destroy public instance and rewrite getPublicInstance\n  delete this.publicInstance\n  delete this.pi\n  this.getPublicInstance = function(){\n    return null\n  }\n}\n\n/**\n * Returns a public instance object\n *\n * @return {Object} Public instance object\n */\nSvgPanZoom.prototype.getPublicInstance = function() {\n  var that = this\n\n  // Create cache\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      // Pan\n      enablePan: function() {that.options.panEnabled = true; return that.pi}\n    , disablePan: function() {that.options.panEnabled = false; return that.pi}\n    , isPanEnabled: function() {return !!that.options.panEnabled}\n    , pan: function(point) {that.pan(point); return that.pi}\n    , panBy: function(point) {that.panBy(point); return that.pi}\n    , getPan: function() {return that.getPan()}\n      // Pan event\n    , setBeforePan: function(fn) {that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}\n    , setOnPan: function(fn) {that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}\n      // Zoom and Control Icons\n    , enableZoom: function() {that.options.zoomEnabled = true; return that.pi}\n    , disableZoom: function() {that.options.zoomEnabled = false; return that.pi}\n    , isZoomEnabled: function() {return !!that.options.zoomEnabled}\n    , enableControlIcons: function() {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true\n          ControlIcons.enable(that)\n        }\n        return that.pi\n      }\n    , disableControlIcons: function() {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that)\n        }\n        return that.pi\n      }\n    , isControlIconsEnabled: function() {return !!that.options.controlIconsEnabled}\n      // Double click zoom\n    , enableDblClickZoom: function() {that.options.dblClickZoomEnabled = true; return that.pi}\n    , disableDblClickZoom: function() {that.options.dblClickZoomEnabled = false; return that.pi}\n    , isDblClickZoomEnabled: function() {return !!that.options.dblClickZoomEnabled}\n      // Mouse wheel zoom\n    , enableMouseWheelZoom: function() {that.enableMouseWheelZoom(); return that.pi}\n    , disableMouseWheelZoom: function() {that.disableMouseWheelZoom(); return that.pi}\n    , isMouseWheelZoomEnabled: function() {return !!that.options.mouseWheelZoomEnabled}\n      // Zoom scale and bounds\n    , setZoomScaleSensitivity: function(scale) {that.options.zoomScaleSensitivity = scale; return that.pi}\n    , setMinZoom: function(zoom) {that.options.minZoom = zoom; return that.pi}\n    , setMaxZoom: function(zoom) {that.options.maxZoom = zoom; return that.pi}\n      // Zoom event\n    , setBeforeZoom: function(fn) {that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}\n    , setOnZoom: function(fn) {that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}\n      // Zooming\n    , zoom: function(scale) {that.publicZoom(scale, true); return that.pi}\n    , zoomBy: function(scale) {that.publicZoom(scale, false); return that.pi}\n    , zoomAtPoint: function(scale, point) {that.publicZoomAtPoint(scale, point, true); return that.pi}\n    , zoomAtPointBy: function(scale, point) {that.publicZoomAtPoint(scale, point, false); return that.pi}\n    , zoomIn: function() {this.zoomBy(1 + that.options.zoomScaleSensitivity); return that.pi}\n    , zoomOut: function() {this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity)); return that.pi}\n    , getZoom: function() {return that.getRelativeZoom()}\n      // CTM update\n    , setOnUpdatedCTM: function(fn) {that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}\n      // Reset\n    , resetZoom: function() {that.resetZoom(); return that.pi}\n    , resetPan: function() {that.resetPan(); return that.pi}\n    , reset: function() {that.reset(); return that.pi}\n      // Fit, Contain and Center\n    , fit: function() {that.fit(); return that.pi}\n    , contain: function() {that.contain(); return that.pi}\n    , center: function() {that.center(); return that.pi}\n      // Size and Resize\n    , updateBBox: function() {that.updateBBox(); return that.pi}\n    , resize: function() {that.resize(); return that.pi}\n    , getSizes: function() {\n        return {\n          width: that.width\n        , height: that.height\n        , realZoom: that.getZoom()\n        , viewBox: that.viewport.getViewBox()\n        }\n      }\n      // Destroy\n    , destroy: function() {that.destroy(); return that.pi}\n    }\n  }\n\n  return this.publicInstance\n}\n\n/**\n * Stores pairs of instances of SvgPanZoom and SVG\n * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}\n *\n * @type {Array}\n */\nvar instancesStore = []\n\nvar svgPanZoom = function(elementOrSelector, options){\n  var svg = Utils.getSvg(elementOrSelector)\n\n  if (svg === null) {\n    return null\n  } else {\n    // Look for existent instance\n    for(var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance()\n      }\n    }\n\n    // If instance not found - create one\n    instancesStore.push({\n      svg: svg\n    , instance: new SvgPanZoom(svg, options)\n    })\n\n    // Return just pushed instance\n    return instancesStore[instancesStore.length - 1].instance.getPublicInstance()\n  }\n}\n\nmodule.exports = svgPanZoom;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9zdmctcGFuLXpvb20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9zdmctcGFuLXpvb20uanM/ODViNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgV2hlZWwgPSByZXF1aXJlKCcuL3VuaXdoZWVsJylcbiwgQ29udHJvbEljb25zID0gcmVxdWlyZSgnLi9jb250cm9sLWljb25zJylcbiwgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpXG4sIFN2Z1V0aWxzID0gcmVxdWlyZSgnLi9zdmctdXRpbGl0aWVzJylcbiwgU2hhZG93Vmlld3BvcnQgPSByZXF1aXJlKCcuL3NoYWRvdy12aWV3cG9ydCcpXG5cbnZhciBTdmdQYW5ab29tID0gZnVuY3Rpb24oc3ZnLCBvcHRpb25zKSB7XG4gIHRoaXMuaW5pdChzdmcsIG9wdGlvbnMpXG59XG5cbnZhciBvcHRpb25zRGVmYXVsdHMgPSB7XG4gIHZpZXdwb3J0U2VsZWN0b3I6ICcuc3ZnLXBhbi16b29tX3ZpZXdwb3J0JyAvLyBWaWV3cG9ydCBzZWxlY3Rvci4gQ2FuIGJlIHF1ZXJ5U2VsZWN0b3Igc3RyaW5nIG9yIFNWR0VsZW1lbnRcbiwgcGFuRW5hYmxlZDogdHJ1ZSAvLyBlbmFibGUgb3IgZGlzYWJsZSBwYW5uaW5nIChkZWZhdWx0IGVuYWJsZWQpXG4sIGNvbnRyb2xJY29uc0VuYWJsZWQ6IGZhbHNlIC8vIGluc2VydCBpY29ucyB0byBnaXZlIHVzZXIgYW4gb3B0aW9uIGluIGFkZGl0aW9uIHRvIG1vdXNlIGV2ZW50cyB0byBjb250cm9sIHBhbi96b29tIChkZWZhdWx0IGRpc2FibGVkKVxuLCB6b29tRW5hYmxlZDogdHJ1ZSAvLyBlbmFibGUgb3IgZGlzYWJsZSB6b29taW5nIChkZWZhdWx0IGVuYWJsZWQpXG4sIGRibENsaWNrWm9vbUVuYWJsZWQ6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgem9vbWluZyBieSBkb3VibGUgY2xpY2tpbmcgKGRlZmF1bHQgZW5hYmxlZClcbiwgbW91c2VXaGVlbFpvb21FbmFibGVkOiB0cnVlIC8vIGVuYWJsZSBvciBkaXNhYmxlIHpvb21pbmcgYnkgbW91c2Ugd2hlZWwgKGRlZmF1bHQgZW5hYmxlZClcbiwgcHJldmVudE1vdXNlRXZlbnRzRGVmYXVsdDogdHJ1ZSAvLyBlbmFibGUgb3IgZGlzYWJsZSBwcmV2ZW50RGVmYXVsdCBmb3IgbW91c2UgZXZlbnRzXG4sIHpvb21TY2FsZVNlbnNpdGl2aXR5OiAwLjEgLy8gWm9vbSBzZW5zaXRpdml0eVxuLCBtaW5ab29tOiAwLjUgLy8gTWluaW11bSBab29tIGxldmVsXG4sIG1heFpvb206IDEwIC8vIE1heGltdW0gWm9vbSBsZXZlbFxuLCBmaXQ6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgdmlld3BvcnQgZml0IGluIFNWRyAoZGVmYXVsdCB0cnVlKVxuLCBjb250YWluOiBmYWxzZSAvLyBlbmFibGUgb3IgZGlzYWJsZSB2aWV3cG9ydCBjb250YWluIHRoZSBzdmcgKGRlZmF1bHQgZmFsc2UpXG4sIGNlbnRlcjogdHJ1ZSAvLyBlbmFibGUgb3IgZGlzYWJsZSB2aWV3cG9ydCBjZW50ZXJpbmcgaW4gU1ZHIChkZWZhdWx0IHRydWUpXG4sIHJlZnJlc2hSYXRlOiAnYXV0bycgLy8gTWF4aW11bSBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmQgKGFsdGVyaW5nIFNWRydzIHZpZXdwb3J0KVxuLCBiZWZvcmVab29tOiBudWxsXG4sIG9uWm9vbTogbnVsbFxuLCBiZWZvcmVQYW46IG51bGxcbiwgb25QYW46IG51bGxcbiwgY3VzdG9tRXZlbnRzSGFuZGxlcjogbnVsbFxuLCBldmVudHNMaXN0ZW5lckVsZW1lbnQ6IG51bGxcbiwgb25VcGRhdGVkQ1RNOiBudWxsXG59XG5cblN2Z1Bhblpvb20ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzdmcsIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgdGhpcy5zdmcgPSBzdmdcbiAgdGhpcy5kZWZzID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKVxuXG4gIC8vIEFkZCBkZWZhdWx0IGF0dHJpYnV0ZXMgdG8gU1ZHXG4gIFN2Z1V0aWxzLnNldHVwU3ZnQXR0cmlidXRlcyh0aGlzLnN2ZylcblxuICAvLyBTZXQgb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zRGVmYXVsdHMpLCBvcHRpb25zKVxuXG4gIC8vIFNldCBkZWZhdWx0IHN0YXRlXG4gIHRoaXMuc3RhdGUgPSAnbm9uZSdcblxuICAvLyBHZXQgZGltZW5zaW9uc1xuICB2YXIgYm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZCA9IFN2Z1V0aWxzLmdldEJvdW5kaW5nQ2xpZW50UmVjdE5vcm1hbGl6ZWQoc3ZnKVxuICB0aGlzLndpZHRoID0gYm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZC53aWR0aFxuICB0aGlzLmhlaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdE5vcm1hbGl6ZWQuaGVpZ2h0XG5cbiAgLy8gSW5pdCBzaGFkb3cgdmlld3BvcnRcbiAgdGhpcy52aWV3cG9ydCA9IFNoYWRvd1ZpZXdwb3J0KFN2Z1V0aWxzLmdldE9yQ3JlYXRlVmlld3BvcnQodGhpcy5zdmcsIHRoaXMub3B0aW9ucy52aWV3cG9ydFNlbGVjdG9yKSwge1xuICAgIHN2ZzogdGhpcy5zdmdcbiAgLCB3aWR0aDogdGhpcy53aWR0aFxuICAsIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgLCBmaXQ6IHRoaXMub3B0aW9ucy5maXRcbiAgLCBjb250YWluOiB0aGlzLm9wdGlvbnMuY29udGFpblxuICAsIGNlbnRlcjogdGhpcy5vcHRpb25zLmNlbnRlclxuICAsIHJlZnJlc2hSYXRlOiB0aGlzLm9wdGlvbnMucmVmcmVzaFJhdGVcbiAgLy8gUHV0IGNhbGxiYWNrcyBpbnRvIGZ1bmN0aW9ucyBhcyB0aGV5IGNhbiBjaGFuZ2UgdGhyb3VnaCB0aW1lXG4gICwgYmVmb3JlWm9vbTogZnVuY3Rpb24ob2xkU2NhbGUsIG5ld1NjYWxlKSB7XG4gICAgICBpZiAodGhhdC52aWV3cG9ydCAmJiB0aGF0Lm9wdGlvbnMuYmVmb3JlWm9vbSkge3JldHVybiB0aGF0Lm9wdGlvbnMuYmVmb3JlWm9vbShvbGRTY2FsZSwgbmV3U2NhbGUpfVxuICAgIH1cbiAgLCBvblpvb206IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICBpZiAodGhhdC52aWV3cG9ydCAmJiB0aGF0Lm9wdGlvbnMub25ab29tKSB7cmV0dXJuIHRoYXQub3B0aW9ucy5vblpvb20oc2NhbGUpfVxuICAgIH1cbiAgLCBiZWZvcmVQYW46IGZ1bmN0aW9uKG9sZFBvaW50LCBuZXdQb2ludCkge1xuICAgICAgaWYgKHRoYXQudmlld3BvcnQgJiYgdGhhdC5vcHRpb25zLmJlZm9yZVBhbikge3JldHVybiB0aGF0Lm9wdGlvbnMuYmVmb3JlUGFuKG9sZFBvaW50LCBuZXdQb2ludCl9XG4gICAgfVxuICAsIG9uUGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoYXQudmlld3BvcnQgJiYgdGhhdC5vcHRpb25zLm9uUGFuKSB7cmV0dXJuIHRoYXQub3B0aW9ucy5vblBhbihwb2ludCl9XG4gICAgfVxuICAsIG9uVXBkYXRlZENUTTogZnVuY3Rpb24oY3RtKSB7XG4gICAgICBpZiAodGhhdC52aWV3cG9ydCAmJiB0aGF0Lm9wdGlvbnMub25VcGRhdGVkQ1RNKSB7cmV0dXJuIHRoYXQub3B0aW9ucy5vblVwZGF0ZWRDVE0oY3RtKX1cbiAgICB9XG4gIH0pXG5cbiAgLy8gV3JhcCBjYWxsYmFja3MgaW50byBwdWJsaWMgQVBJIGNvbnRleHRcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpXG4gIHB1YmxpY0luc3RhbmNlLnNldEJlZm9yZVpvb20odGhpcy5vcHRpb25zLmJlZm9yZVpvb20pXG4gIHB1YmxpY0luc3RhbmNlLnNldE9uWm9vbSh0aGlzLm9wdGlvbnMub25ab29tKVxuICBwdWJsaWNJbnN0YW5jZS5zZXRCZWZvcmVQYW4odGhpcy5vcHRpb25zLmJlZm9yZVBhbilcbiAgcHVibGljSW5zdGFuY2Uuc2V0T25QYW4odGhpcy5vcHRpb25zLm9uUGFuKVxuICBwdWJsaWNJbnN0YW5jZS5zZXRPblVwZGF0ZWRDVE0odGhpcy5vcHRpb25zLm9uVXBkYXRlZENUTSlcblxuICBpZiAodGhpcy5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICBDb250cm9sSWNvbnMuZW5hYmxlKHRoaXMpXG4gIH1cblxuICAvLyBJbml0IGV2ZW50cyBoYW5kbGVyc1xuICB0aGlzLmxhc3RNb3VzZVdoZWVsRXZlbnRUaW1lID0gRGF0ZS5ub3coKVxuICB0aGlzLnNldHVwSGFuZGxlcnMoKVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnNldHVwSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBwcmV2RXZ0ID0gbnVsbCAvLyB1c2UgZm9yIHRvdWNoc3RhcnQgZXZlbnQgdG8gZGV0ZWN0IGRvdWJsZSB0YXBcbiAgICA7XG5cbiAgdGhpcy5ldmVudExpc3RlbmVycyA9IHtcbiAgICAvLyBNb3VzZSBkb3duIGdyb3VwXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGF0LmhhbmRsZU1vdXNlRG93bihldnQsIHByZXZFdnQpO1xuICAgICAgcHJldkV2dCA9IGV2dFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICwgdG91Y2hzdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhhdC5oYW5kbGVNb3VzZURvd24oZXZ0LCBwcmV2RXZ0KTtcbiAgICAgIHByZXZFdnQgPSBldnRcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTW91c2UgdXAgZ3JvdXBcbiAgLCBtb3VzZXVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiB0aGF0LmhhbmRsZU1vdXNlVXAoZXZ0KTtcbiAgICB9XG4gICwgdG91Y2hlbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VVcChldnQpO1xuICAgIH1cblxuICAgIC8vIE1vdXNlIG1vdmUgZ3JvdXBcbiAgLCBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VNb3ZlKGV2dCk7XG4gICAgfVxuICAsIHRvdWNobW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZU1vdmUoZXZ0KTtcbiAgICB9XG5cbiAgICAvLyBNb3VzZSBsZWF2ZSBncm91cFxuICAsIG1vdXNlbGVhdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VVcChldnQpO1xuICAgIH1cbiAgLCB0b3VjaGxlYXZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiB0aGF0LmhhbmRsZU1vdXNlVXAoZXZ0KTtcbiAgICB9XG4gICwgdG91Y2hjYW5jZWw6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VVcChldnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXQgY3VzdG9tIGV2ZW50cyBoYW5kbGVyIGlmIGF2YWlsYWJsZVxuICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbUV2ZW50c0hhbmRsZXIgIT0gbnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB0aGlzLm9wdGlvbnMuY3VzdG9tRXZlbnRzSGFuZGxlci5pbml0KHtcbiAgICAgIHN2Z0VsZW1lbnQ6IHRoaXMuc3ZnXG4gICAgLCBldmVudHNMaXN0ZW5lckVsZW1lbnQ6IHRoaXMub3B0aW9ucy5ldmVudHNMaXN0ZW5lckVsZW1lbnRcbiAgICAsIGluc3RhbmNlOiB0aGlzLmdldFB1YmxpY0luc3RhbmNlKClcbiAgICB9KVxuXG4gICAgLy8gQ3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IGhhbHQgYnVpbHRpbiBsaXN0ZW5lcnNcbiAgICB2YXIgaGFsdEV2ZW50TGlzdGVuZXJzID0gdGhpcy5vcHRpb25zLmN1c3RvbUV2ZW50c0hhbmRsZXIuaGFsdEV2ZW50TGlzdGVuZXJzXG4gICAgaWYgKGhhbHRFdmVudExpc3RlbmVycyAmJiBoYWx0RXZlbnRMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gaGFsdEV2ZW50TGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KGhhbHRFdmVudExpc3RlbmVyc1tpXSkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVyc1toYWx0RXZlbnRMaXN0ZW5lcnNbaV1dXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCaW5kIGV2ZW50TGlzdGVuZXJzXG4gIGZvciAodmFyIGV2ZW50IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAvLyBBdHRhY2ggZXZlbnQgdG8gZXZlbnRzTGlzdGVuZXJFbGVtZW50IG9yIFNWRyBpZiBub3QgYXZhaWxhYmxlXG4gICAgKHRoaXMub3B0aW9ucy5ldmVudHNMaXN0ZW5lckVsZW1lbnQgfHwgdGhpcy5zdmcpXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0sIGZhbHNlKVxuICB9XG5cbiAgLy8gWm9vbSB1c2luZyBtb3VzZSB3aGVlbFxuICBpZiAodGhpcy5vcHRpb25zLm1vdXNlV2hlZWxab29tRW5hYmxlZCkge1xuICAgIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQgPSBmYWxzZSAvLyBzZXQgdG8gZmFsc2UgYXMgZW5hYmxlIHdpbGwgc2V0IGl0IGJhY2sgdG8gdHJ1ZVxuICAgIHRoaXMuZW5hYmxlTW91c2VXaGVlbFpvb20oKVxuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIGFiaWxpdHkgdG8gem9vbSB1c2luZyBtb3VzZSB3aGVlbFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5lbmFibGVNb3VzZVdoZWVsWm9vbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgIC8vIE1vdXNlIHdoZWVsIGxpc3RlbmVyXG4gICAgdGhpcy53aGVlbExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZVdoZWVsKGV2dCk7XG4gICAgfVxuXG4gICAgLy8gQmluZCB3aGVlbExpc3RlbmVyXG4gICAgV2hlZWwub24odGhpcy5vcHRpb25zLmV2ZW50c0xpc3RlbmVyRWxlbWVudCB8fCB0aGlzLnN2ZywgdGhpcy53aGVlbExpc3RlbmVyLCBmYWxzZSlcblxuICAgIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQgPSB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGFiaWxpdHkgdG8gem9vbSB1c2luZyBtb3VzZSB3aGVlbFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5kaXNhYmxlTW91c2VXaGVlbFpvb20gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQpIHtcbiAgICBXaGVlbC5vZmYodGhpcy5vcHRpb25zLmV2ZW50c0xpc3RlbmVyRWxlbWVudCB8fCB0aGlzLnN2ZywgdGhpcy53aGVlbExpc3RlbmVyLCBmYWxzZSlcbiAgICB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFpvb21FbmFibGVkID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSB3aGVlbCBldmVudFxuICpcbiAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuaGFuZGxlTW91c2VXaGVlbCA9IGZ1bmN0aW9uKGV2dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy56b29tRW5hYmxlZCB8fCB0aGlzLnN0YXRlICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRNb3VzZUV2ZW50c0RlZmF1bHQpe1xuICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBEZWZhdWx0IGRlbHRhIGluIGNhc2UgdGhhdCBkZWx0YVkgaXMgbm90IGF2YWlsYWJsZVxuICB2YXIgZGVsdGEgPSBldnQuZGVsdGFZIHx8IDFcbiAgICAsIHRpbWVEZWx0YSA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RNb3VzZVdoZWVsRXZlbnRUaW1lXG4gICAgLCBkaXZpZGVyID0gMyArIE1hdGgubWF4KDAsIDMwIC0gdGltZURlbHRhKVxuXG4gIC8vIFVwZGF0ZSBjYWNoZVxuICB0aGlzLmxhc3RNb3VzZVdoZWVsRXZlbnRUaW1lID0gRGF0ZS5ub3coKVxuXG4gIC8vIE1ha2UgZW1waXJpY2FsIGFkanVzdG1lbnRzIGZvciBicm93c2VycyB0aGF0IGdpdmUgZGVsdGFZIGluIHBpeGVscyAoZGVsdGFNb2RlPTApXG4gIGlmICgnZGVsdGFNb2RlJyBpbiBldnQgJiYgZXZ0LmRlbHRhTW9kZSA9PT0gMCAmJiBldnQud2hlZWxEZWx0YSkge1xuICAgIGRlbHRhID0gZXZ0LmRlbHRhWSA9PT0gMCA/IDAgOiAgTWF0aC5hYnMoZXZ0LndoZWVsRGVsdGEpIC8gZXZ0LmRlbHRhWVxuICB9XG5cbiAgZGVsdGEgPSAtMC4zIDwgZGVsdGEgJiYgZGVsdGEgPCAwLjMgPyBkZWx0YSA6IChkZWx0YSA+IDAgPyAxIDogLTEpICogTWF0aC5sb2coTWF0aC5hYnMoZGVsdGEpICsgMTApIC8gZGl2aWRlclxuXG4gIHZhciBpbnZlcnNlZFNjcmVlbkNUTSA9IHRoaXMuc3ZnLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKVxuICAgICwgcmVsYXRpdmVNb3VzZVBvaW50ID0gU3ZnVXRpbHMuZ2V0RXZlbnRQb2ludChldnQsIHRoaXMuc3ZnKS5tYXRyaXhUcmFuc2Zvcm0oaW52ZXJzZWRTY3JlZW5DVE0pXG4gICAgLCB6b29tID0gTWF0aC5wb3coMSArIHRoaXMub3B0aW9ucy56b29tU2NhbGVTZW5zaXRpdml0eSwgKC0xKSAqIGRlbHRhKTsgLy8gbXVsdGlwbHlpbmcgYnkgbmVnLiAxIHNvIGFzIHRvIG1ha2Ugem9vbSBpbi9vdXQgYmVoYXZpb3IgbWF0Y2ggR29vZ2xlIG1hcHMgYmVoYXZpb3JcblxuICB0aGlzLnpvb21BdFBvaW50KHpvb20sIHJlbGF0aXZlTW91c2VQb2ludClcbn1cblxuLyoqXG4gKiBab29tIGluIGF0IGEgU1ZHIHBvaW50XG4gKlxuICogQHBhcmFtICB7U1ZHUG9pbnR9IHBvaW50XG4gKiBAcGFyYW0gIHtGbG9hdH0gem9vbVNjYWxlICAgIE51bWJlciByZXByZXNlbnRpbmcgaG93IG11Y2ggdG8gem9vbVxuICogQHBhcmFtICB7Qm9vbGVhbn0gem9vbUFic29sdXRlIERlZmF1bHQgZmFsc2UuIElmIHRydWUsIHpvb21TY2FsZSBpcyB0cmVhdGVkIGFzIGFuIGFic29sdXRlIHZhbHVlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSwgem9vbVNjYWxlIGlzIHRyZWF0ZWQgYXMgYSBtdWx0aXBsaWVkIChlLmcuIDEuMTAgd291bGQgem9vbSBpbiAxMCUpXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnpvb21BdFBvaW50ID0gZnVuY3Rpb24oem9vbVNjYWxlLCBwb2ludCwgem9vbUFic29sdXRlKSB7XG4gIHZhciBvcmlnaW5hbFN0YXRlID0gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW5hbFN0YXRlKClcblxuICBpZiAoIXpvb21BYnNvbHV0ZSkge1xuICAgIC8vIEZpdCB6b29tU2NhbGUgaW4gc2V0IGJvdW5kc1xuICAgIGlmICh0aGlzLmdldFpvb20oKSAqIHpvb21TY2FsZSA8IHRoaXMub3B0aW9ucy5taW5ab29tICogb3JpZ2luYWxTdGF0ZS56b29tKSB7XG4gICAgICB6b29tU2NhbGUgPSAodGhpcy5vcHRpb25zLm1pblpvb20gKiBvcmlnaW5hbFN0YXRlLnpvb20pIC8gdGhpcy5nZXRab29tKClcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0Wm9vbSgpICogem9vbVNjYWxlID4gdGhpcy5vcHRpb25zLm1heFpvb20gKiBvcmlnaW5hbFN0YXRlLnpvb20pIHtcbiAgICAgIHpvb21TY2FsZSA9ICh0aGlzLm9wdGlvbnMubWF4Wm9vbSAqIG9yaWdpbmFsU3RhdGUuem9vbSkgLyB0aGlzLmdldFpvb20oKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGaXQgem9vbVNjYWxlIGluIHNldCBib3VuZHNcbiAgICB6b29tU2NhbGUgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluWm9vbSAqIG9yaWdpbmFsU3RhdGUuem9vbSwgTWF0aC5taW4odGhpcy5vcHRpb25zLm1heFpvb20gKiBvcmlnaW5hbFN0YXRlLnpvb20sIHpvb21TY2FsZSkpXG4gICAgLy8gRmluZCByZWxhdGl2ZSBzY2FsZSB0byBhY2hpZXZlIGRlc2lyZWQgc2NhbGVcbiAgICB6b29tU2NhbGUgPSB6b29tU2NhbGUvdGhpcy5nZXRab29tKClcbiAgfVxuXG4gIHZhciBvbGRDVE0gPSB0aGlzLnZpZXdwb3J0LmdldENUTSgpXG4gICAgLCByZWxhdGl2ZVBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG9sZENUTS5pbnZlcnNlKCkpXG4gICAgLCBtb2RpZmllciA9IHRoaXMuc3ZnLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShyZWxhdGl2ZVBvaW50LngsIHJlbGF0aXZlUG9pbnQueSkuc2NhbGUoem9vbVNjYWxlKS50cmFuc2xhdGUoLXJlbGF0aXZlUG9pbnQueCwgLXJlbGF0aXZlUG9pbnQueSlcbiAgICAsIG5ld0NUTSA9IG9sZENUTS5tdWx0aXBseShtb2RpZmllcilcblxuICBpZiAobmV3Q1RNLmEgIT09IG9sZENUTS5hKSB7XG4gICAgdGhpcy52aWV3cG9ydC5zZXRDVE0obmV3Q1RNKVxuICB9XG59XG5cbi8qKlxuICogWm9vbSBhdCBjZW50ZXIgcG9pbnRcbiAqXG4gKiBAcGFyYW0gIHtGbG9hdH0gc2NhbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGFic29sdXRlIE1hcmtzIHpvb20gc2NhbGUgYXMgcmVsYXRpdmUgb3IgYWJzb2x1dGVcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uKHNjYWxlLCBhYnNvbHV0ZSkge1xuICB0aGlzLnpvb21BdFBvaW50KHNjYWxlLCBTdmdVdGlscy5nZXRTdmdDZW50ZXJQb2ludCh0aGlzLnN2ZywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCBhYnNvbHV0ZSlcbn1cblxuLyoqXG4gKiBab29tIHVzZWQgYnkgcHVibGljIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7RmxvYXR9IHNjYWxlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBhYnNvbHV0ZSBNYXJrcyB6b29tIHNjYWxlIGFzIHJlbGF0aXZlIG9yIGFic29sdXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnB1YmxpY1pvb20gPSBmdW5jdGlvbihzY2FsZSwgYWJzb2x1dGUpIHtcbiAgaWYgKGFic29sdXRlKSB7XG4gICAgc2NhbGUgPSB0aGlzLmNvbXB1dGVGcm9tUmVsYXRpdmVab29tKHNjYWxlKVxuICB9XG5cbiAgdGhpcy56b29tKHNjYWxlLCBhYnNvbHV0ZSlcbn1cblxuLyoqXG4gKiBab29tIGF0IHBvaW50IHVzZWQgYnkgcHVibGljIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7RmxvYXR9IHNjYWxlXG4gKiBAcGFyYW0gIHtTVkdQb2ludHxPYmplY3R9IHBvaW50ICAgIEFuIG9iamVjdCB0aGF0IGhhcyB4IGFuZCB5IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGFic29sdXRlIE1hcmtzIHpvb20gc2NhbGUgYXMgcmVsYXRpdmUgb3IgYWJzb2x1dGVcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUucHVibGljWm9vbUF0UG9pbnQgPSBmdW5jdGlvbihzY2FsZSwgcG9pbnQsIGFic29sdXRlKSB7XG4gIGlmIChhYnNvbHV0ZSkge1xuICAgIC8vIFRyYW5zZm9ybSB6b29tIGludG8gYSByZWxhdGl2ZSB2YWx1ZVxuICAgIHNjYWxlID0gdGhpcy5jb21wdXRlRnJvbVJlbGF0aXZlWm9vbShzY2FsZSlcbiAgfVxuXG4gIC8vIElmIG5vdCBhIFNWR1BvaW50IGJ1dCBoYXMgeCBhbmQgeSB0aGVuIGNyZWF0ZSBhIFNWR1BvaW50XG4gIGlmIChVdGlscy5nZXRUeXBlKHBvaW50KSAhPT0gJ1NWR1BvaW50Jykge1xuICAgIGlmKCd4JyBpbiBwb2ludCAmJiAneScgaW4gcG9pbnQpIHtcbiAgICAgIHBvaW50ID0gU3ZnVXRpbHMuY3JlYXRlU1ZHUG9pbnQodGhpcy5zdmcsIHBvaW50LngsIHBvaW50LnkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gcG9pbnQgaXMgaW52YWxpZCcpXG4gICAgfVxuICB9XG5cbiAgdGhpcy56b29tQXRQb2ludChzY2FsZSwgcG9pbnQsIGFic29sdXRlKVxufVxuXG4vKipcbiAqIEdldCB6b29tIHNjYWxlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRab29tKClcbn1cblxuLyoqXG4gKiBHZXQgem9vbSBzY2FsZSBmb3IgcHVibGljIHVzYWdlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZ2V0UmVsYXRpdmVab29tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFJlbGF0aXZlWm9vbSgpXG59XG5cbi8qKlxuICogQ29tcHV0ZSBhY3R1YWwgem9vbSBmcm9tIHB1YmxpYyB6b29tXG4gKlxuICogQHBhcmFtICB7RmxvYXR9IHpvb21cbiAqIEByZXR1cm4ge0Zsb2F0fSB6b29tIHNjYWxlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmNvbXB1dGVGcm9tUmVsYXRpdmVab29tID0gZnVuY3Rpb24oem9vbSkge1xuICByZXR1cm4gem9vbSAqIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luYWxTdGF0ZSgpLnpvb21cbn1cblxuLyoqXG4gKiBTZXQgem9vbSB0byBpbml0aWFsIHN0YXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnJlc2V0Wm9vbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZ2luYWxTdGF0ZSA9IHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luYWxTdGF0ZSgpXG5cbiAgdGhpcy56b29tKG9yaWdpbmFsU3RhdGUuem9vbSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogU2V0IHBhbiB0byBpbml0aWFsIHN0YXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnJlc2V0UGFuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGFuKHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luYWxTdGF0ZSgpKTtcbn1cblxuLyoqXG4gKiBTZXQgcGFuIGFuZCB6b29tIHRvIGluaXRpYWwgc3RhdGVcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNldFpvb20oKVxuICB0aGlzLnJlc2V0UGFuKClcbn1cblxuLyoqXG4gKiBIYW5kbGUgZG91YmxlIGNsaWNrIGV2ZW50XG4gKiBTZWUgaGFuZGxlTW91c2VEb3duKCkgZm9yIGFsdGVybmF0ZSBkZXRlY3Rpb24gbWV0aG9kXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZ0XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmhhbmRsZURibENsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMucHJldmVudE1vdXNlRXZlbnRzRGVmYXVsdCkge1xuICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGFyZ2V0IHdhcyBhIGNvbnRyb2wgYnV0dG9uXG4gIGlmICh0aGlzLm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCkge1xuICAgIHZhciB0YXJnZXRDbGFzcyA9IGV2dC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnXG4gICAgaWYgKHRhcmdldENsYXNzLmluZGV4T2YoJ3N2Zy1wYW4tem9vbS1jb250cm9sJykgPiAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdmFyIHpvb21GYWN0b3JcblxuICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgem9vbUZhY3RvciA9IDEvKCgxICsgdGhpcy5vcHRpb25zLnpvb21TY2FsZVNlbnNpdGl2aXR5KSAqIDIpIC8vIHpvb20gb3V0IHdoZW4gc2hpZnQga2V5IHByZXNzZWRcbiAgfSBlbHNlIHtcbiAgICB6b29tRmFjdG9yID0gKDEgKyB0aGlzLm9wdGlvbnMuem9vbVNjYWxlU2Vuc2l0aXZpdHkpICogMlxuICB9XG5cbiAgdmFyIHBvaW50ID0gU3ZnVXRpbHMuZ2V0RXZlbnRQb2ludChldnQsIHRoaXMuc3ZnKS5tYXRyaXhUcmFuc2Zvcm0odGhpcy5zdmcuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKVxuICB0aGlzLnpvb21BdFBvaW50KHpvb21GYWN0b3IsIHBvaW50KVxufVxuXG4vKipcbiAqIEhhbmRsZSBjbGljayBldmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihldnQsIHByZXZFdnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50TW91c2VFdmVudHNEZWZhdWx0KSB7XG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBVdGlscy5tb3VzZUFuZFRvdWNoTm9ybWFsaXplKGV2dCwgdGhpcy5zdmcpXG5cbiAgLy8gRG91YmxlIGNsaWNrIGRldGVjdGlvbjsgbW9yZSBjb25zaXN0ZW50IHRoYW4gb25kYmxjbGlja1xuICBpZiAodGhpcy5vcHRpb25zLmRibENsaWNrWm9vbUVuYWJsZWQgJiYgVXRpbHMuaXNEYmxDbGljayhldnQsIHByZXZFdnQpKXtcbiAgICB0aGlzLmhhbmRsZURibENsaWNrKGV2dClcbiAgfSBlbHNlIHtcbiAgICAvLyBQYW4gbW9kZVxuICAgIHRoaXMuc3RhdGUgPSAncGFuJ1xuICAgIHRoaXMuZmlyc3RFdmVudENUTSA9IHRoaXMudmlld3BvcnQuZ2V0Q1RNKClcbiAgICB0aGlzLnN0YXRlT3JpZ2luID0gU3ZnVXRpbHMuZ2V0RXZlbnRQb2ludChldnQsIHRoaXMuc3ZnKS5tYXRyaXhUcmFuc2Zvcm0odGhpcy5maXJzdEV2ZW50Q1RNLmludmVyc2UoKSlcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSBtb3ZlIGV2ZW50XG4gKlxuICogQHBhcmFtICB7RXZlbnR9IGV2dFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50TW91c2VFdmVudHNEZWZhdWx0KSB7XG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3BhbicgJiYgdGhpcy5vcHRpb25zLnBhbkVuYWJsZWQpIHtcbiAgICAvLyBQYW4gbW9kZVxuICAgIHZhciBwb2ludCA9IFN2Z1V0aWxzLmdldEV2ZW50UG9pbnQoZXZ0LCB0aGlzLnN2ZykubWF0cml4VHJhbnNmb3JtKHRoaXMuZmlyc3RFdmVudENUTS5pbnZlcnNlKCkpXG4gICAgICAsIHZpZXdwb3J0Q1RNID0gdGhpcy5maXJzdEV2ZW50Q1RNLnRyYW5zbGF0ZShwb2ludC54IC0gdGhpcy5zdGF0ZU9yaWdpbi54LCBwb2ludC55IC0gdGhpcy5zdGF0ZU9yaWdpbi55KVxuXG4gICAgdGhpcy52aWV3cG9ydC5zZXRDVE0odmlld3BvcnRDVE0pXG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgbW91c2UgYnV0dG9uIHJlbGVhc2UgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uKGV2dCkge1xuICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRNb3VzZUV2ZW50c0RlZmF1bHQpIHtcbiAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09PSAncGFuJykge1xuICAgIC8vIFF1aXQgcGFuIG1vZGVcbiAgICB0aGlzLnN0YXRlID0gJ25vbmUnXG4gIH1cbn1cblxuLyoqXG4gKiBBZGp1c3Qgdmlld3BvcnQgc2l6ZSAob25seSkgc28gaXQgd2lsbCBmaXQgaW4gU1ZHXG4gKiBEb2VzIG5vdCBjZW50ZXIgaW1hZ2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2aWV3Qm94ID0gdGhpcy52aWV3cG9ydC5nZXRWaWV3Qm94KClcbiAgICAsIG5ld1NjYWxlID0gTWF0aC5taW4odGhpcy53aWR0aC92aWV3Qm94LndpZHRoLCB0aGlzLmhlaWdodC92aWV3Qm94LmhlaWdodClcblxuICB0aGlzLnpvb20obmV3U2NhbGUsIHRydWUpXG59XG5cbi8qKlxuICogQWRqdXN0IHZpZXdwb3J0IHNpemUgKG9ubHkpIHNvIGl0IHdpbGwgY29udGFpbiB0aGUgU1ZHXG4gKiBEb2VzIG5vdCBjZW50ZXIgaW1hZ2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmlld0JveCA9IHRoaXMudmlld3BvcnQuZ2V0Vmlld0JveCgpXG4gICAgLCBuZXdTY2FsZSA9IE1hdGgubWF4KHRoaXMud2lkdGgvdmlld0JveC53aWR0aCwgdGhpcy5oZWlnaHQvdmlld0JveC5oZWlnaHQpXG5cbiAgdGhpcy56b29tKG5ld1NjYWxlLCB0cnVlKVxufVxuXG4vKipcbiAqIEFkanVzdCB2aWV3cG9ydCBwYW4gKG9ubHkpIHNvIGl0IHdpbGwgYmUgY2VudGVyZWQgaW4gU1ZHXG4gKiBEb2VzIG5vdCB6b29tL2ZpdC9jb250YWluIGltYWdlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmlld0JveCA9IHRoaXMudmlld3BvcnQuZ2V0Vmlld0JveCgpXG4gICAgLCBvZmZzZXRYID0gKHRoaXMud2lkdGggLSAodmlld0JveC53aWR0aCArIHZpZXdCb3gueCAqIDIpICogdGhpcy5nZXRab29tKCkpICogMC41XG4gICAgLCBvZmZzZXRZID0gKHRoaXMuaGVpZ2h0IC0gKHZpZXdCb3guaGVpZ2h0ICsgdmlld0JveC55ICogMikgKiB0aGlzLmdldFpvb20oKSkgKiAwLjVcblxuICB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucGFuKHt4OiBvZmZzZXRYLCB5OiBvZmZzZXRZfSlcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29udGVudCBjYWNoZWQgQm9yZGVyQm94XG4gKiBVc2Ugd2hlbiB2aWV3cG9ydCBjb250ZW50cyBjaGFuZ2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUudXBkYXRlQkJveCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZpZXdwb3J0LnNpbXBsZVZpZXdCb3hDYWNoZSgpXG59XG5cbi8qKlxuICogUGFuIHRvIGEgcmVuZGVyZWQgcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50IHt4OiAwLCB5OiAwfVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5wYW4gPSBmdW5jdGlvbihwb2ludCkge1xuICB2YXIgdmlld3BvcnRDVE0gPSB0aGlzLnZpZXdwb3J0LmdldENUTSgpXG4gIHZpZXdwb3J0Q1RNLmUgPSBwb2ludC54XG4gIHZpZXdwb3J0Q1RNLmYgPSBwb2ludC55XG4gIHRoaXMudmlld3BvcnQuc2V0Q1RNKHZpZXdwb3J0Q1RNKVxufVxuXG4vKipcbiAqIFJlbGF0aXZlbHkgcGFuIHRoZSBncmFwaCBieSBhIHNwZWNpZmllZCByZW5kZXJlZCBwb3NpdGlvbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50IHt4OiAwLCB5OiAwfVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5wYW5CeSA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gIHZhciB2aWV3cG9ydENUTSA9IHRoaXMudmlld3BvcnQuZ2V0Q1RNKClcbiAgdmlld3BvcnRDVE0uZSArPSBwb2ludC54XG4gIHZpZXdwb3J0Q1RNLmYgKz0gcG9pbnQueVxuICB0aGlzLnZpZXdwb3J0LnNldENUTSh2aWV3cG9ydENUTSlcbn1cblxuLyoqXG4gKiBHZXQgcGFuIHZlY3RvclxuICpcbiAqIEByZXR1cm4ge09iamVjdH0ge3g6IDAsIHk6IDB9XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmdldFBhbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLnZpZXdwb3J0LmdldFN0YXRlKClcblxuICByZXR1cm4ge3g6IHN0YXRlLngsIHk6IHN0YXRlLnl9XG59XG5cbi8qKlxuICogUmVjYWxjdWxhdGVzIGNhY2hlZCBzdmcgZGltZW5zaW9ucyBhbmQgY29udHJvbHMgcG9zaXRpb25cbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIC8vIEdldCBkaW1lbnNpb25zXG4gIHZhciBib3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkID0gU3ZnVXRpbHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZCh0aGlzLnN2ZylcbiAgdGhpcy53aWR0aCA9IGJvdW5kaW5nQ2xpZW50UmVjdE5vcm1hbGl6ZWQud2lkdGhcbiAgdGhpcy5oZWlnaHQgPSBib3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkLmhlaWdodFxuXG4gIC8vIFJlY2FsY3VsYXRlIG9yaWdpbmFsIHN0YXRlXG4gIHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnRcbiAgdmlld3BvcnQub3B0aW9ucy53aWR0aCA9IHRoaXMud2lkdGhcbiAgdmlld3BvcnQub3B0aW9ucy5oZWlnaHQgPSB0aGlzLmhlaWdodFxuICB2aWV3cG9ydC5wcm9jZXNzQ1RNKClcblxuICAvLyBSZXBvc2l0aW9uIGNvbnRyb2wgaWNvbnMgYnkgcmUtZW5hYmxpbmcgdGhlbVxuICBpZiAodGhpcy5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkuZGlzYWJsZUNvbnRyb2xJY29ucygpXG4gICAgdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLmVuYWJsZUNvbnRyb2xJY29ucygpXG4gIH1cbn1cblxuLyoqXG4gKiBVbmJpbmQgbW91c2UgZXZlbnRzLCBmcmVlIGNhbGxiYWNrcyBhbmQgZGVzdHJveSBwdWJsaWMgaW5zdGFuY2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICAvLyBGcmVlIGNhbGxiYWNrc1xuICB0aGlzLmJlZm9yZVpvb20gPSBudWxsXG4gIHRoaXMub25ab29tID0gbnVsbFxuICB0aGlzLmJlZm9yZVBhbiA9IG51bGxcbiAgdGhpcy5vblBhbiA9IG51bGxcbiAgdGhpcy5vblVwZGF0ZWRDVE0gPSBudWxsXG5cbiAgLy8gRGVzdHJveSBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKHRoaXMub3B0aW9ucy5jdXN0b21FdmVudHNIYW5kbGVyICE9IG51bGwpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdGhpcy5vcHRpb25zLmN1c3RvbUV2ZW50c0hhbmRsZXIuZGVzdHJveSh7XG4gICAgICBzdmdFbGVtZW50OiB0aGlzLnN2Z1xuICAgICwgZXZlbnRzTGlzdGVuZXJFbGVtZW50OiB0aGlzLm9wdGlvbnMuZXZlbnRzTGlzdGVuZXJFbGVtZW50XG4gICAgLCBpbnN0YW5jZTogdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFVuYmluZCBldmVudExpc3RlbmVyc1xuICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgKHRoaXMub3B0aW9ucy5ldmVudHNMaXN0ZW5lckVsZW1lbnQgfHwgdGhpcy5zdmcpXG4gICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0sIGZhbHNlKVxuICB9XG5cbiAgLy8gVW5iaW5kIHdoZWVsTGlzdGVuZXJcbiAgdGhpcy5kaXNhYmxlTW91c2VXaGVlbFpvb20oKVxuXG4gIC8vIFJlbW92ZSBjb250cm9sIGljb25zXG4gIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5kaXNhYmxlQ29udHJvbEljb25zKClcblxuICAvLyBSZXNldCB6b29tIGFuZCBwYW5cbiAgdGhpcy5yZXNldCgpXG5cbiAgLy8gUmVtb3ZlIGluc3RhbmNlIGZyb20gaW5zdGFuY2VzU3RvcmVcbiAgaW5zdGFuY2VzU3RvcmUgPSBpbnN0YW5jZXNTdG9yZS5maWx0ZXIoZnVuY3Rpb24oaW5zdGFuY2Upe1xuICAgIHJldHVybiBpbnN0YW5jZS5zdmcgIT09IHRoYXQuc3ZnXG4gIH0pXG5cbiAgLy8gRGVsZXRlIG9wdGlvbnMgYW5kIGl0cyBjb250ZW50c1xuICBkZWxldGUgdGhpcy5vcHRpb25zXG5cbiAgLy8gRGVsZXRlIHZpZXdwb3J0IHRvIG1ha2UgcHVibGljIHNoYWRvdyB2aWV3cG9ydCBmdW5jdGlvbnMgdW5jYWxsYWJsZVxuICBkZWxldGUgdGhpcy52aWV3cG9ydFxuXG4gIC8vIERlc3Ryb3kgcHVibGljIGluc3RhbmNlIGFuZCByZXdyaXRlIGdldFB1YmxpY0luc3RhbmNlXG4gIGRlbGV0ZSB0aGlzLnB1YmxpY0luc3RhbmNlXG4gIGRlbGV0ZSB0aGlzLnBpXG4gIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHVibGljIGluc3RhbmNlIG9iamVjdFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gUHVibGljIGluc3RhbmNlIG9iamVjdFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5nZXRQdWJsaWNJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICAvLyBDcmVhdGUgY2FjaGVcbiAgaWYgKCF0aGlzLnB1YmxpY0luc3RhbmNlKSB7XG4gICAgdGhpcy5wdWJsaWNJbnN0YW5jZSA9IHRoaXMucGkgPSB7XG4gICAgICAvLyBQYW5cbiAgICAgIGVuYWJsZVBhbjogZnVuY3Rpb24oKSB7dGhhdC5vcHRpb25zLnBhbkVuYWJsZWQgPSB0cnVlOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGRpc2FibGVQYW46IGZ1bmN0aW9uKCkge3RoYXQub3B0aW9ucy5wYW5FbmFibGVkID0gZmFsc2U7IHJldHVybiB0aGF0LnBpfVxuICAgICwgaXNQYW5FbmFibGVkOiBmdW5jdGlvbigpIHtyZXR1cm4gISF0aGF0Lm9wdGlvbnMucGFuRW5hYmxlZH1cbiAgICAsIHBhbjogZnVuY3Rpb24ocG9pbnQpIHt0aGF0LnBhbihwb2ludCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgcGFuQnk6IGZ1bmN0aW9uKHBvaW50KSB7dGhhdC5wYW5CeShwb2ludCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgZ2V0UGFuOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhhdC5nZXRQYW4oKX1cbiAgICAgIC8vIFBhbiBldmVudFxuICAgICwgc2V0QmVmb3JlUGFuOiBmdW5jdGlvbihmbikge3RoYXQub3B0aW9ucy5iZWZvcmVQYW4gPSBmbiA9PT0gbnVsbCA/IG51bGwgOiBVdGlscy5wcm94eShmbiwgdGhhdC5wdWJsaWNJbnN0YW5jZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgc2V0T25QYW46IGZ1bmN0aW9uKGZuKSB7dGhhdC5vcHRpb25zLm9uUGFuID0gZm4gPT09IG51bGwgPyBudWxsIDogVXRpbHMucHJveHkoZm4sIHRoYXQucHVibGljSW5zdGFuY2UpOyByZXR1cm4gdGhhdC5waX1cbiAgICAgIC8vIFpvb20gYW5kIENvbnRyb2wgSWNvbnNcbiAgICAsIGVuYWJsZVpvb206IGZ1bmN0aW9uKCkge3RoYXQub3B0aW9ucy56b29tRW5hYmxlZCA9IHRydWU7IHJldHVybiB0aGF0LnBpfVxuICAgICwgZGlzYWJsZVpvb206IGZ1bmN0aW9uKCkge3RoYXQub3B0aW9ucy56b29tRW5hYmxlZCA9IGZhbHNlOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGlzWm9vbUVuYWJsZWQ6IGZ1bmN0aW9uKCkge3JldHVybiAhIXRoYXQub3B0aW9ucy56b29tRW5hYmxlZH1cbiAgICAsIGVuYWJsZUNvbnRyb2xJY29uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhhdC5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICAgICAgICB0aGF0Lm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCA9IHRydWVcbiAgICAgICAgICBDb250cm9sSWNvbnMuZW5hYmxlKHRoYXQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoYXQucGlcbiAgICAgIH1cbiAgICAsIGRpc2FibGVDb250cm9sSWNvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICAgICAgICB0aGF0Lm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIENvbnRyb2xJY29ucy5kaXNhYmxlKHRoYXQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoYXQucGlcbiAgICAgIH1cbiAgICAsIGlzQ29udHJvbEljb25zRW5hYmxlZDogZnVuY3Rpb24oKSB7cmV0dXJuICEhdGhhdC5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWR9XG4gICAgICAvLyBEb3VibGUgY2xpY2sgem9vbVxuICAgICwgZW5hYmxlRGJsQ2xpY2tab29tOiBmdW5jdGlvbigpIHt0aGF0Lm9wdGlvbnMuZGJsQ2xpY2tab29tRW5hYmxlZCA9IHRydWU7IHJldHVybiB0aGF0LnBpfVxuICAgICwgZGlzYWJsZURibENsaWNrWm9vbTogZnVuY3Rpb24oKSB7dGhhdC5vcHRpb25zLmRibENsaWNrWm9vbUVuYWJsZWQgPSBmYWxzZTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBpc0RibENsaWNrWm9vbUVuYWJsZWQ6IGZ1bmN0aW9uKCkge3JldHVybiAhIXRoYXQub3B0aW9ucy5kYmxDbGlja1pvb21FbmFibGVkfVxuICAgICAgLy8gTW91c2Ugd2hlZWwgem9vbVxuICAgICwgZW5hYmxlTW91c2VXaGVlbFpvb206IGZ1bmN0aW9uKCkge3RoYXQuZW5hYmxlTW91c2VXaGVlbFpvb20oKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBkaXNhYmxlTW91c2VXaGVlbFpvb206IGZ1bmN0aW9uKCkge3RoYXQuZGlzYWJsZU1vdXNlV2hlZWxab29tKCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgaXNNb3VzZVdoZWVsWm9vbUVuYWJsZWQ6IGZ1bmN0aW9uKCkge3JldHVybiAhIXRoYXQub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWR9XG4gICAgICAvLyBab29tIHNjYWxlIGFuZCBib3VuZHNcbiAgICAsIHNldFpvb21TY2FsZVNlbnNpdGl2aXR5OiBmdW5jdGlvbihzY2FsZSkge3RoYXQub3B0aW9ucy56b29tU2NhbGVTZW5zaXRpdml0eSA9IHNjYWxlOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHNldE1pblpvb206IGZ1bmN0aW9uKHpvb20pIHt0aGF0Lm9wdGlvbnMubWluWm9vbSA9IHpvb207IHJldHVybiB0aGF0LnBpfVxuICAgICwgc2V0TWF4Wm9vbTogZnVuY3Rpb24oem9vbSkge3RoYXQub3B0aW9ucy5tYXhab29tID0gem9vbTsgcmV0dXJuIHRoYXQucGl9XG4gICAgICAvLyBab29tIGV2ZW50XG4gICAgLCBzZXRCZWZvcmVab29tOiBmdW5jdGlvbihmbikge3RoYXQub3B0aW9ucy5iZWZvcmVab29tID0gZm4gPT09IG51bGwgPyBudWxsIDogVXRpbHMucHJveHkoZm4sIHRoYXQucHVibGljSW5zdGFuY2UpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHNldE9uWm9vbTogZnVuY3Rpb24oZm4pIHt0aGF0Lm9wdGlvbnMub25ab29tID0gZm4gPT09IG51bGwgPyBudWxsIDogVXRpbHMucHJveHkoZm4sIHRoYXQucHVibGljSW5zdGFuY2UpOyByZXR1cm4gdGhhdC5waX1cbiAgICAgIC8vIFpvb21pbmdcbiAgICAsIHpvb206IGZ1bmN0aW9uKHNjYWxlKSB7dGhhdC5wdWJsaWNab29tKHNjYWxlLCB0cnVlKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCB6b29tQnk6IGZ1bmN0aW9uKHNjYWxlKSB7dGhhdC5wdWJsaWNab29tKHNjYWxlLCBmYWxzZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgem9vbUF0UG9pbnQ6IGZ1bmN0aW9uKHNjYWxlLCBwb2ludCkge3RoYXQucHVibGljWm9vbUF0UG9pbnQoc2NhbGUsIHBvaW50LCB0cnVlKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCB6b29tQXRQb2ludEJ5OiBmdW5jdGlvbihzY2FsZSwgcG9pbnQpIHt0aGF0LnB1YmxpY1pvb21BdFBvaW50KHNjYWxlLCBwb2ludCwgZmFsc2UpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHpvb21JbjogZnVuY3Rpb24oKSB7dGhpcy56b29tQnkoMSArIHRoYXQub3B0aW9ucy56b29tU2NhbGVTZW5zaXRpdml0eSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgem9vbU91dDogZnVuY3Rpb24oKSB7dGhpcy56b29tQnkoMSAvICgxICsgdGhhdC5vcHRpb25zLnpvb21TY2FsZVNlbnNpdGl2aXR5KSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgZ2V0Wm9vbTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoYXQuZ2V0UmVsYXRpdmVab29tKCl9XG4gICAgICAvLyBDVE0gdXBkYXRlXG4gICAgLCBzZXRPblVwZGF0ZWRDVE06IGZ1bmN0aW9uKGZuKSB7dGhhdC5vcHRpb25zLm9uVXBkYXRlZENUTSA9IGZuID09PSBudWxsID8gbnVsbCA6IFV0aWxzLnByb3h5KGZuLCB0aGF0LnB1YmxpY0luc3RhbmNlKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgICAvLyBSZXNldFxuICAgICwgcmVzZXRab29tOiBmdW5jdGlvbigpIHt0aGF0LnJlc2V0Wm9vbSgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHJlc2V0UGFuOiBmdW5jdGlvbigpIHt0aGF0LnJlc2V0UGFuKCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgcmVzZXQ6IGZ1bmN0aW9uKCkge3RoYXQucmVzZXQoKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgICAvLyBGaXQsIENvbnRhaW4gYW5kIENlbnRlclxuICAgICwgZml0OiBmdW5jdGlvbigpIHt0aGF0LmZpdCgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGNvbnRhaW46IGZ1bmN0aW9uKCkge3RoYXQuY29udGFpbigpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGNlbnRlcjogZnVuY3Rpb24oKSB7dGhhdC5jZW50ZXIoKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgICAvLyBTaXplIGFuZCBSZXNpemVcbiAgICAsIHVwZGF0ZUJCb3g6IGZ1bmN0aW9uKCkge3RoYXQudXBkYXRlQkJveCgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHJlc2l6ZTogZnVuY3Rpb24oKSB7dGhhdC5yZXNpemUoKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBnZXRTaXplczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHRoYXQud2lkdGhcbiAgICAgICAgLCBoZWlnaHQ6IHRoYXQuaGVpZ2h0XG4gICAgICAgICwgcmVhbFpvb206IHRoYXQuZ2V0Wm9vbSgpXG4gICAgICAgICwgdmlld0JveDogdGhhdC52aWV3cG9ydC5nZXRWaWV3Qm94KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGVzdHJveVxuICAgICwgZGVzdHJveTogZnVuY3Rpb24oKSB7dGhhdC5kZXN0cm95KCk7IHJldHVybiB0aGF0LnBpfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnB1YmxpY0luc3RhbmNlXG59XG5cbi8qKlxuICogU3RvcmVzIHBhaXJzIG9mIGluc3RhbmNlcyBvZiBTdmdQYW5ab29tIGFuZCBTVkdcbiAqIEVhY2ggcGFpciBpcyByZXByZXNlbnRlZCBieSBhbiBvYmplY3Qge3N2ZzogU1ZHU1ZHRWxlbWVudCwgaW5zdGFuY2U6IFN2Z1Bhblpvb219XG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgaW5zdGFuY2VzU3RvcmUgPSBbXVxuXG52YXIgc3ZnUGFuWm9vbSA9IGZ1bmN0aW9uKGVsZW1lbnRPclNlbGVjdG9yLCBvcHRpb25zKXtcbiAgdmFyIHN2ZyA9IFV0aWxzLmdldFN2ZyhlbGVtZW50T3JTZWxlY3RvcilcblxuICBpZiAoc3ZnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICAvLyBMb29rIGZvciBleGlzdGVudCBpbnN0YW5jZVxuICAgIGZvcih2YXIgaSA9IGluc3RhbmNlc1N0b3JlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaW5zdGFuY2VzU3RvcmVbaV0uc3ZnID09PSBzdmcpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1N0b3JlW2ldLmluc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBpbnN0YW5jZSBub3QgZm91bmQgLSBjcmVhdGUgb25lXG4gICAgaW5zdGFuY2VzU3RvcmUucHVzaCh7XG4gICAgICBzdmc6IHN2Z1xuICAgICwgaW5zdGFuY2U6IG5ldyBTdmdQYW5ab29tKHN2Zywgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgLy8gUmV0dXJuIGp1c3QgcHVzaGVkIGluc3RhbmNlXG4gICAgcmV0dXJuIGluc3RhbmNlc1N0b3JlW2luc3RhbmNlc1N0b3JlLmxlbmd0aCAtIDFdLmluc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN2Z1Bhblpvb207XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/svg-pan-zoom.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/svg-utilities.js":
/*!********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/svg-utilities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\")\n  , _browser = 'unknown'\n  ;\n\n// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\nif (/*@cc_on!@*/false || !!document.documentMode) { // internet explorer\n  _browser = 'ie';\n}\n\nmodule.exports = {\n  svgNS:  'http://www.w3.org/2000/svg'\n, xmlNS:  'http://www.w3.org/XML/1998/namespace'\n, xmlnsNS:  'http://www.w3.org/2000/xmlns/'\n, xlinkNS:  'http://www.w3.org/1999/xlink'\n, evNS:  'http://www.w3.org/2001/xml-events'\n\n  /**\n   * Get svg dimensions: width and height\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {Object}     {width: 0, height: 0}\n   */\n, getBoundingClientRectNormalized: function(svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return {width: svg.clientWidth, height: svg.clientHeight}\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error('Cannot get BoundingClientRect for SVG.');\n    }\n  }\n\n  /**\n   * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGElement}     g (group) element\n   */\n, getOrCreateViewport: function(svg, selector) {\n    var viewport = null\n\n    if (Utils.isElement(selector)) {\n      viewport = selector\n    } else {\n      viewport = svg.querySelector(selector)\n    }\n\n    // Check if there is just one main group in SVG\n    if (!viewport) {\n      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el){\n        return el.nodeName !== 'defs' && el.nodeName !== '#text'\n      })\n\n      // Node name should be SVGGElement and should have no transform attribute\n      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities\n      if (childNodes.length === 1 && childNodes[0].nodeName === 'g' && childNodes[0].getAttribute('transform') === null) {\n        viewport = childNodes[0]\n      }\n    }\n\n    // If no favorable group element exists then create one\n    if (!viewport) {\n      var viewportId = 'viewport-' + new Date().toISOString().replace(/\\D/g, '');\n      viewport = document.createElementNS(this.svgNS, 'g');\n      viewport.setAttribute('id', viewportId);\n\n      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes\n      var svgChildren = svg.childNodes || svg.children;\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          // Move everything into viewport except defs\n          if (svgChildren[svgChildren.length - i].nodeName !== 'defs') {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n      svg.appendChild(viewport);\n    }\n\n    // Parse class names\n    var classNames = [];\n    if (viewport.getAttribute('class')) {\n      classNames = viewport.getAttribute('class').split(' ')\n    }\n\n    // Set class (if not set already)\n    if (!~classNames.indexOf('svg-pan-zoom_viewport')) {\n      classNames.push('svg-pan-zoom_viewport')\n      viewport.setAttribute('class', classNames.join(' '))\n    }\n\n    return viewport\n  }\n\n  /**\n   * Set SVG attributes\n   *\n   * @param  {SVGSVGElement} svg\n   */\n  , setupSvgAttributes: function(svg) {\n    // Setting default attributes\n    svg.setAttribute('xmlns', this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, 'xmlns:xlink', this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, 'xmlns:ev', this.evNS);\n\n    // Needed for Internet Explorer, otherwise the viewport overflows\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute('style') || '';\n      if (style.toLowerCase().indexOf('overflow') === -1) {\n        svg.setAttribute('style', 'overflow: hidden; ' + style);\n      }\n    }\n  }\n\n/**\n * How long Internet Explorer takes to finish updating its display (ms).\n */\n, internetExplorerRedisplayInterval: 300\n\n/**\n * Forces the browser to redisplay all SVG elements that rely on an\n * element defined in a 'defs' section. It works globally, for every\n * available defs element on the page.\n * The throttling is intentionally global.\n *\n * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n * visible after pan/zoom when there are multiple SVGs on the page.\n * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n */\n, refreshDefsGlobal: Utils.throttle(function() {\n    var allDefs = document.querySelectorAll('defs');\n    var allDefsCount = allDefs.length;\n    for (var i = 0; i < allDefsCount; i++) {\n      var thisDefs = allDefs[i];\n      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n    }\n  }, this ? this.internetExplorerRedisplayInterval : null)\n\n  /**\n   * Sets the current transform matrix of an element\n   *\n   * @param {SVGElement} element\n   * @param {SVGMatrix} matrix  CTM\n   * @param {SVGElement} defs\n   */\n, setCTM: function(element, matrix, defs) {\n    var that = this\n      , s = 'matrix(' + matrix.a + ',' + matrix.b + ',' + matrix.c + ',' + matrix.d + ',' + matrix.e + ',' + matrix.f + ')';\n\n    element.setAttributeNS(null, 'transform', s);\n    if ('transform' in element.style) {\n      element.style.transform = s;\n    } else if ('-ms-transform' in element.style) {\n      element.style['-ms-transform'] = s;\n    } else if ('-webkit-transform' in element.style) {\n      element.style['-webkit-transform'] = s;\n    }\n\n    // IE has a bug that makes markers disappear on zoom (when the matrix \"a\" and/or \"d\" elements change)\n    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10\n    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/\n    if (_browser === 'ie' && !!defs) {\n      // this refresh is intended for redisplaying the SVG during zooming\n      defs.parentNode.insertBefore(defs, defs);\n      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG\n      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that\n      // are located under any other element(s).\n      window.setTimeout(function() {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  }\n\n  /**\n   * Instantiate an SVGPoint object with given event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}     point\n   */\n, getEventPoint: function(evt, svg) {\n    var point = svg.createSVGPoint()\n\n    Utils.mouseAndTouchNormalize(evt, svg)\n\n    point.x = evt.clientX\n    point.y = evt.clientY\n\n    return point\n  }\n\n  /**\n   * Get SVG center point\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}\n   */\n, getSvgCenterPoint: function(svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2)\n  }\n\n  /**\n   * Create a SVGPoint with given x and y\n   *\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {SVGPoint}\n   */\n, createSVGPoint: function(svg, x, y) {\n    var point = svg.createSVGPoint()\n    point.x = x\n    point.y = y\n\n    return point\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9zdmctdXRpbGl0aWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N2Zy1wYW4tem9vbS9zcmMvc3ZnLXV0aWxpdGllcy5qcz8zNTgzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJylcbiAgLCBfYnJvd3NlciA9ICd1bmtub3duJ1xuICA7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTg0NzU4MC9ob3ctdG8tZGV0ZWN0LXNhZmFyaS1jaHJvbWUtaWUtZmlyZWZveC1hbmQtb3BlcmEtYnJvd3NlclxuaWYgKC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7IC8vIGludGVybmV0IGV4cGxvcmVyXG4gIF9icm93c2VyID0gJ2llJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN2Z05TOiAgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuLCB4bWxOUzogICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4sIHhtbG5zTlM6ICAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4sIHhsaW5rTlM6ICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbiwgZXZOUzogICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMnXG5cbiAgLyoqXG4gICAqIEdldCBzdmcgZGltZW5zaW9uczogd2lkdGggYW5kIGhlaWdodFxuICAgKlxuICAgKiBAcGFyYW0gIHtTVkdTVkdFbGVtZW50fSBzdmdcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAge3dpZHRoOiAwLCBoZWlnaHQ6IDB9XG4gICAqL1xuLCBnZXRCb3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkOiBmdW5jdGlvbihzdmcpIHtcbiAgICBpZiAoc3ZnLmNsaWVudFdpZHRoICYmIHN2Zy5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybiB7d2lkdGg6IHN2Zy5jbGllbnRXaWR0aCwgaGVpZ2h0OiBzdmcuY2xpZW50SGVpZ2h0fVxuICAgIH0gZWxzZSBpZiAoISFzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHtcbiAgICAgIHJldHVybiBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBCb3VuZGluZ0NsaWVudFJlY3QgZm9yIFNWRy4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBnIGVsZW1lbnQgd2l0aCBjbGFzcyBvZiBcInZpZXdwb3J0XCIgb3IgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSAgICAgZyAoZ3JvdXApIGVsZW1lbnRcbiAgICovXG4sIGdldE9yQ3JlYXRlVmlld3BvcnQ6IGZ1bmN0aW9uKHN2Zywgc2VsZWN0b3IpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBudWxsXG5cbiAgICBpZiAoVXRpbHMuaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgdmlld3BvcnQgPSBzZWxlY3RvclxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3cG9ydCA9IHN2Zy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGp1c3Qgb25lIG1haW4gZ3JvdXAgaW4gU1ZHXG4gICAgaWYgKCF2aWV3cG9ydCkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzdmcuY2hpbGROb2RlcyB8fCBzdmcuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBlbC5ub2RlTmFtZSAhPT0gJ2RlZnMnICYmIGVsLm5vZGVOYW1lICE9PSAnI3RleHQnXG4gICAgICB9KVxuXG4gICAgICAvLyBOb2RlIG5hbWUgc2hvdWxkIGJlIFNWR0dFbGVtZW50IGFuZCBzaG91bGQgaGF2ZSBubyB0cmFuc2Zvcm0gYXR0cmlidXRlXG4gICAgICAvLyBHcm91cHMgd2l0aCB0cmFuc2Zvcm0gYXJlIG5vdCB1c2VkIGFzIHZpZXdwb3J0IGJlY2F1c2UgaXQgaW52b2x2ZXMgcGFyc2luZyBvZiBhbGwgdHJhbnNmb3JtIHBvc3NpYmlsaXRpZXNcbiAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBjaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09PSAnZycgJiYgY2hpbGROb2Rlc1swXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpID09PSBudWxsKSB7XG4gICAgICAgIHZpZXdwb3J0ID0gY2hpbGROb2Rlc1swXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIGZhdm9yYWJsZSBncm91cCBlbGVtZW50IGV4aXN0cyB0aGVuIGNyZWF0ZSBvbmVcbiAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICB2YXIgdmlld3BvcnRJZCA9ICd2aWV3cG9ydC0nICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICB2aWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnN2Z05TLCAnZycpO1xuICAgICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCdpZCcsIHZpZXdwb3J0SWQpO1xuXG4gICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciAoYWxsIHZlcnNpb25zPykgY2FuJ3QgdXNlIGNoaWxkTm9kZXMsIGJ1dCBvdGhlciBicm93c2VycyBwcmVmZXIgKHJlcXVpcmU/KSB1c2luZyBjaGlsZE5vZGVzXG4gICAgICB2YXIgc3ZnQ2hpbGRyZW4gPSBzdmcuY2hpbGROb2RlcyB8fCBzdmcuY2hpbGRyZW47XG4gICAgICBpZiAoISFzdmdDaGlsZHJlbiAmJiBzdmdDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdmdDaGlsZHJlbi5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZXJ5dGhpbmcgaW50byB2aWV3cG9ydCBleGNlcHQgZGVmc1xuICAgICAgICAgIGlmIChzdmdDaGlsZHJlbltzdmdDaGlsZHJlbi5sZW5ndGggLSBpXS5ub2RlTmFtZSAhPT0gJ2RlZnMnKSB7XG4gICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChzdmdDaGlsZHJlbltzdmdDaGlsZHJlbi5sZW5ndGggLSBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQodmlld3BvcnQpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGNsYXNzIG5hbWVzXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICBpZiAodmlld3BvcnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpKSB7XG4gICAgICBjbGFzc05hbWVzID0gdmlld3BvcnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNwbGl0KCcgJylcbiAgICB9XG5cbiAgICAvLyBTZXQgY2xhc3MgKGlmIG5vdCBzZXQgYWxyZWFkeSlcbiAgICBpZiAoIX5jbGFzc05hbWVzLmluZGV4T2YoJ3N2Zy1wYW4tem9vbV92aWV3cG9ydCcpKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ3N2Zy1wYW4tem9vbV92aWV3cG9ydCcpXG4gICAgICB2aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lcy5qb2luKCcgJykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0XG4gIH1cblxuICAvKipcbiAgICogU2V0IFNWRyBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKi9cbiAgLCBzZXR1cFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHN2Zykge1xuICAgIC8vIFNldHRpbmcgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCB0aGlzLnN2Z05TKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlTlModGhpcy54bWxuc05TLCAneG1sbnM6eGxpbmsnLCB0aGlzLnhsaW5rTlMpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyh0aGlzLnhtbG5zTlMsICd4bWxuczpldicsIHRoaXMuZXZOUyk7XG5cbiAgICAvLyBOZWVkZWQgZm9yIEludGVybmV0IEV4cGxvcmVyLCBvdGhlcndpc2UgdGhlIHZpZXdwb3J0IG92ZXJmbG93c1xuICAgIGlmIChzdmcucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHN0eWxlID0gc3ZnLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcbiAgICAgIGlmIChzdHlsZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ292ZXJmbG93JykgPT09IC0xKSB7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ292ZXJmbG93OiBoaWRkZW47ICcgKyBzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbi8qKlxuICogSG93IGxvbmcgSW50ZXJuZXQgRXhwbG9yZXIgdGFrZXMgdG8gZmluaXNoIHVwZGF0aW5nIGl0cyBkaXNwbGF5IChtcykuXG4gKi9cbiwgaW50ZXJuZXRFeHBsb3JlclJlZGlzcGxheUludGVydmFsOiAzMDBcblxuLyoqXG4gKiBGb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVkaXNwbGF5IGFsbCBTVkcgZWxlbWVudHMgdGhhdCByZWx5IG9uIGFuXG4gKiBlbGVtZW50IGRlZmluZWQgaW4gYSAnZGVmcycgc2VjdGlvbi4gSXQgd29ya3MgZ2xvYmFsbHksIGZvciBldmVyeVxuICogYXZhaWxhYmxlIGRlZnMgZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqIFRoZSB0aHJvdHRsaW5nIGlzIGludGVudGlvbmFsbHkgZ2xvYmFsLlxuICpcbiAqIFRoaXMgaXMgb25seSBuZWVkZWQgZm9yIElFLiBJdCBpcyBhcyBhIGhhY2sgdG8gbWFrZSBtYXJrZXJzIChhbmQgJ3VzZScgZWxlbWVudHM/KVxuICogdmlzaWJsZSBhZnRlciBwYW4vem9vbSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBTVkdzIG9uIHRoZSBwYWdlLlxuICogU2VlIGJ1ZyByZXBvcnQ6IGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzgxOTY0L1xuICogYWxzbyBzZWUgc3ZnLXBhbi16b29tIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYXJpdXR0YS9zdmctcGFuLXpvb20vaXNzdWVzLzYyXG4gKi9cbiwgcmVmcmVzaERlZnNHbG9iYWw6IFV0aWxzLnRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbGxEZWZzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZGVmcycpO1xuICAgIHZhciBhbGxEZWZzQ291bnQgPSBhbGxEZWZzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERlZnNDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgdGhpc0RlZnMgPSBhbGxEZWZzW2ldO1xuICAgICAgdGhpc0RlZnMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc0RlZnMsIHRoaXNEZWZzKTtcbiAgICB9XG4gIH0sIHRoaXMgPyB0aGlzLmludGVybmV0RXhwbG9yZXJSZWRpc3BsYXlJbnRlcnZhbCA6IG51bGwpXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIG1hdHJpeCBvZiBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1NWR01hdHJpeH0gbWF0cml4ICBDVE1cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBkZWZzXG4gICAqL1xuLCBzZXRDVE06IGZ1bmN0aW9uKGVsZW1lbnQsIG1hdHJpeCwgZGVmcykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBzID0gJ21hdHJpeCgnICsgbWF0cml4LmEgKyAnLCcgKyBtYXRyaXguYiArICcsJyArIG1hdHJpeC5jICsgJywnICsgbWF0cml4LmQgKyAnLCcgKyBtYXRyaXguZSArICcsJyArIG1hdHJpeC5mICsgJyknO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgcyk7XG4gICAgaWYgKCd0cmFuc2Zvcm0nIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gcztcbiAgICB9IGVsc2UgaWYgKCctbXMtdHJhbnNmb3JtJyBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlWyctbXMtdHJhbnNmb3JtJ10gPSBzO1xuICAgIH0gZWxzZSBpZiAoJy13ZWJraXQtdHJhbnNmb3JtJyBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID0gcztcbiAgICB9XG5cbiAgICAvLyBJRSBoYXMgYSBidWcgdGhhdCBtYWtlcyBtYXJrZXJzIGRpc2FwcGVhciBvbiB6b29tICh3aGVuIHRoZSBtYXRyaXggXCJhXCIgYW5kL29yIFwiZFwiIGVsZW1lbnRzIGNoYW5nZSlcbiAgICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzY1NDU3OC9zdmctbWFya2VyLWRvZXMtbm90LXdvcmstaW4taWU5LTEwXG4gICAgLy8gYW5kIGh0dHA6Ly9zcm5kb2xoYS53b3JkcHJlc3MuY29tLzIwMTMvMTEvMjUvc3ZnLWxpbmUtbWFya2Vycy1tYXktZGlzYXBwZWFyLWluLWludGVybmV0LWV4cGxvcmVyLTExL1xuICAgIGlmIChfYnJvd3NlciA9PT0gJ2llJyAmJiAhIWRlZnMpIHtcbiAgICAgIC8vIHRoaXMgcmVmcmVzaCBpcyBpbnRlbmRlZCBmb3IgcmVkaXNwbGF5aW5nIHRoZSBTVkcgZHVyaW5nIHpvb21pbmdcbiAgICAgIGRlZnMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGVmcywgZGVmcyk7XG4gICAgICAvLyB0aGlzIHJlZnJlc2ggaXMgaW50ZW5kZWQgZm9yIHJlZGlzcGxheWluZyB0aGUgb3RoZXIgU1ZHcyBvbiBhIHBhZ2Ugd2hlbiBwYW5uaW5nIGEgZ2l2ZW4gU1ZHXG4gICAgICAvLyBpdCBpcyBhbHNvIG5lZWRlZCBmb3IgdGhlIGdpdmVuIFNWRyBpdHNlbGYsIG9uIHpvb21FbmQsIGlmIHRoZSBTVkcgY29udGFpbnMgYW55IG1hcmtlcnMgdGhhdFxuICAgICAgLy8gYXJlIGxvY2F0ZWQgdW5kZXIgYW55IG90aGVyIGVsZW1lbnQocykuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5yZWZyZXNoRGVmc0dsb2JhbCgpO1xuICAgICAgfSwgdGhhdC5pbnRlcm5ldEV4cGxvcmVyUmVkaXNwbGF5SW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhbiBTVkdQb2ludCBvYmplY3Qgd2l0aCBnaXZlbiBldmVudCBjb29yZGluYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHBhcmFtICB7U1ZHU1ZHRWxlbWVudH0gc3ZnXG4gICAqIEByZXR1cm4ge1NWR1BvaW50fSAgICAgcG9pbnRcbiAgICovXG4sIGdldEV2ZW50UG9pbnQ6IGZ1bmN0aW9uKGV2dCwgc3ZnKSB7XG4gICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KClcblxuICAgIFV0aWxzLm1vdXNlQW5kVG91Y2hOb3JtYWxpemUoZXZ0LCBzdmcpXG5cbiAgICBwb2ludC54ID0gZXZ0LmNsaWVudFhcbiAgICBwb2ludC55ID0gZXZ0LmNsaWVudFlcblxuICAgIHJldHVybiBwb2ludFxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBTVkcgY2VudGVyIHBvaW50XG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKiBAcmV0dXJuIHtTVkdQb2ludH1cbiAgICovXG4sIGdldFN2Z0NlbnRlclBvaW50OiBmdW5jdGlvbihzdmcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTVkdQb2ludChzdmcsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTVkdQb2ludCB3aXRoIGdpdmVuIHggYW5kIHlcbiAgICpcbiAgICogQHBhcmFtICB7U1ZHU1ZHRWxlbWVudH0gc3ZnXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7U1ZHUG9pbnR9XG4gICAqL1xuLCBjcmVhdGVTVkdQb2ludDogZnVuY3Rpb24oc3ZnLCB4LCB5KSB7XG4gICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KClcbiAgICBwb2ludC54ID0geFxuICAgIHBvaW50LnkgPSB5XG5cbiAgICByZXR1cm4gcG9pbnRcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/svg-utilities.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/uniwheel.js":
/*!***************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/uniwheel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// uniwheel 0.1.2 (customized)\n// A unified cross browser mouse wheel event handler\n// https://github.com/teemualap/uniwheel\n\nmodule.exports = (function(){\n\n  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel\n\n  var prefix = \"\", _addEventListener, _removeEventListener, onwheel, support, fns = [];\n\n  // detect event model\n  if ( window.addEventListener ) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  // detect available wheel event\n  support = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n            document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n            \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\n\n  function createCallback(element,callback,capture) {\n\n    var fn = function(originalEvent) {\n\n      !originalEvent && ( originalEvent = window.event );\n\n      // create a normalized event object\n      var event = {\n        // keep a ref to the original event object\n        originalEvent: originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function() {\n          originalEvent.preventDefault ?\n            originalEvent.preventDefault() :\n            originalEvent.returnValue = false;\n        }\n      };\n\n      // calculate deltaY (and deltaX) according to the event\n      if ( support == \"mousewheel\" ) {\n        event.deltaY = - 1/40 * originalEvent.wheelDelta;\n        // Webkit also support wheelDeltaX\n        originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      // it's time to fire the callback\n      return callback( event );\n\n    };\n\n    fns.push({\n      element: element,\n      fn: fn,\n      capture: capture\n    });\n\n    return fn;\n  }\n\n  function getCallback(element,capture) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element && fns[i].capture === capture) {\n        return fns[i].fn;\n      }\n    }\n    return function(){};\n  }\n\n  function removeCallback(element,capture) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element && fns[i].capture === capture) {\n        return fns.splice(i,1);\n      }\n    }\n  }\n\n  function _addWheelListener( elem, eventName, callback, useCapture ) {\n\n    var cb;\n\n    if (support === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem,callback,useCapture);\n    }\n\n    elem[ _addEventListener ]( prefix + eventName, cb, useCapture || false );\n\n  }\n\n  function _removeWheelListener( elem, eventName, callback, useCapture ) {\n\n    var cb;\n\n    if (support === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem,useCapture);\n    }\n\n    elem[ _removeEventListener ]( prefix + eventName, cb, useCapture || false );\n\n    removeCallback(elem,useCapture);\n\n  }\n\n  function addWheelListener( elem, callback, useCapture ) {\n    _addWheelListener( elem, support, callback, useCapture );\n\n    // handle MozMousePixelScroll in older Firefox\n    if( support == \"DOMMouseScroll\" ) {\n        _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture);\n    }\n  }\n\n  function removeWheelListener(elem,callback,useCapture){\n    _removeWheelListener(elem,support,callback,useCapture);\n\n    // handle MozMousePixelScroll in older Firefox\n    if( support == \"DOMMouseScroll\" ) {\n        _removeWheelListener(elem, \"MozMousePixelScroll\", callback, useCapture);\n    }\n  }\n\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy91bml3aGVlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdmctcGFuLXpvb20vc3JjL3VuaXdoZWVsLmpzP2I1ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdW5pd2hlZWwgMC4xLjIgKGN1c3RvbWl6ZWQpXG4vLyBBIHVuaWZpZWQgY3Jvc3MgYnJvd3NlciBtb3VzZSB3aGVlbCBldmVudCBoYW5kbGVyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGVlbXVhbGFwL3VuaXdoZWVsXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCl7XG5cbiAgLy9GdWxsIGRldGFpbHM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1JlZmVyZW5jZS9FdmVudHMvd2hlZWxcblxuICB2YXIgcHJlZml4ID0gXCJcIiwgX2FkZEV2ZW50TGlzdGVuZXIsIF9yZW1vdmVFdmVudExpc3RlbmVyLCBvbndoZWVsLCBzdXBwb3J0LCBmbnMgPSBbXTtcblxuICAvLyBkZXRlY3QgZXZlbnQgbW9kZWxcbiAgaWYgKCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICBfYWRkRXZlbnRMaXN0ZW5lciA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiO1xuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyID0gXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gIH0gZWxzZSB7XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIgPSBcImF0dGFjaEV2ZW50XCI7XG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIgPSBcImRldGFjaEV2ZW50XCI7XG4gICAgcHJlZml4ID0gXCJvblwiO1xuICB9XG5cbiAgLy8gZGV0ZWN0IGF2YWlsYWJsZSB3aGVlbCBldmVudFxuICBzdXBwb3J0ID0gXCJvbndoZWVsXCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSA/IFwid2hlZWxcIiA6IC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyBcIm1vdXNld2hlZWxcIiA6IC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuICAgICAgICAgICAgXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBsZXQncyBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrKGVsZW1lbnQsY2FsbGJhY2ssY2FwdHVyZSkge1xuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCkge1xuXG4gICAgICAhb3JpZ2luYWxFdmVudCAmJiAoIG9yaWdpbmFsRXZlbnQgPSB3aW5kb3cuZXZlbnQgKTtcblxuICAgICAgLy8gY3JlYXRlIGEgbm9ybWFsaXplZCBldmVudCBvYmplY3RcbiAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgLy8ga2VlcCBhIHJlZiB0byB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgICAgIHRhcmdldDogb3JpZ2luYWxFdmVudC50YXJnZXQgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICB0eXBlOiBcIndoZWVsXCIsXG4gICAgICAgIGRlbHRhTW9kZTogb3JpZ2luYWxFdmVudC50eXBlID09IFwiTW96TW91c2VQaXhlbFNjcm9sbFwiID8gMCA6IDEsXG4gICAgICAgIGRlbHRhWDogMCxcbiAgICAgICAgZGVsYXRaOiAwLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCA/XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCkgOlxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxjdWxhdGUgZGVsdGFZIChhbmQgZGVsdGFYKSBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50XG4gICAgICBpZiAoIHN1cHBvcnQgPT0gXCJtb3VzZXdoZWVsXCIgKSB7XG4gICAgICAgIGV2ZW50LmRlbHRhWSA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YTtcbiAgICAgICAgLy8gV2Via2l0IGFsc28gc3VwcG9ydCB3aGVlbERlbHRhWFxuICAgICAgICBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYICYmICggZXZlbnQuZGVsdGFYID0gLSAxLzQwICogb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQuZGVsdGFZID0gb3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0J3MgdGltZSB0byBmaXJlIHRoZSBjYWxsYmFja1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCBldmVudCApO1xuXG4gICAgfTtcblxuICAgIGZucy5wdXNoKHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBmbjogZm4sXG4gICAgICBjYXB0dXJlOiBjYXB0dXJlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYWxsYmFjayhlbGVtZW50LGNhcHR1cmUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZuc1tpXS5lbGVtZW50ID09PSBlbGVtZW50ICYmIGZuc1tpXS5jYXB0dXJlID09PSBjYXB0dXJlKSB7XG4gICAgICAgIHJldHVybiBmbnNbaV0uZm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDYWxsYmFjayhlbGVtZW50LGNhcHR1cmUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZuc1tpXS5lbGVtZW50ID09PSBlbGVtZW50ICYmIGZuc1tpXS5jYXB0dXJlID09PSBjYXB0dXJlKSB7XG4gICAgICAgIHJldHVybiBmbnMuc3BsaWNlKGksMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FkZFdoZWVsTGlzdGVuZXIoIGVsZW0sIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgKSB7XG5cbiAgICB2YXIgY2I7XG5cbiAgICBpZiAoc3VwcG9ydCA9PT0gXCJ3aGVlbFwiKSB7XG4gICAgICBjYiA9IGNhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYiA9IGNyZWF0ZUNhbGxiYWNrKGVsZW0sY2FsbGJhY2ssdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgZWxlbVsgX2FkZEV2ZW50TGlzdGVuZXIgXSggcHJlZml4ICsgZXZlbnROYW1lLCBjYiwgdXNlQ2FwdHVyZSB8fCBmYWxzZSApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBfcmVtb3ZlV2hlZWxMaXN0ZW5lciggZWxlbSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSApIHtcblxuICAgIHZhciBjYjtcblxuICAgIGlmIChzdXBwb3J0ID09PSBcIndoZWVsXCIpIHtcbiAgICAgIGNiID0gY2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiID0gZ2V0Q2FsbGJhY2soZWxlbSx1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBlbGVtWyBfcmVtb3ZlRXZlbnRMaXN0ZW5lciBdKCBwcmVmaXggKyBldmVudE5hbWUsIGNiLCB1c2VDYXB0dXJlIHx8IGZhbHNlICk7XG5cbiAgICByZW1vdmVDYWxsYmFjayhlbGVtLHVzZUNhcHR1cmUpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRXaGVlbExpc3RlbmVyKCBlbGVtLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSApIHtcbiAgICBfYWRkV2hlZWxMaXN0ZW5lciggZWxlbSwgc3VwcG9ydCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgKTtcblxuICAgIC8vIGhhbmRsZSBNb3pNb3VzZVBpeGVsU2Nyb2xsIGluIG9sZGVyIEZpcmVmb3hcbiAgICBpZiggc3VwcG9ydCA9PSBcIkRPTU1vdXNlU2Nyb2xsXCIgKSB7XG4gICAgICAgIF9hZGRXaGVlbExpc3RlbmVyKCBlbGVtLCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIiwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVdoZWVsTGlzdGVuZXIoZWxlbSxjYWxsYmFjayx1c2VDYXB0dXJlKXtcbiAgICBfcmVtb3ZlV2hlZWxMaXN0ZW5lcihlbGVtLHN1cHBvcnQsY2FsbGJhY2ssdXNlQ2FwdHVyZSk7XG5cbiAgICAvLyBoYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgaWYoIHN1cHBvcnQgPT0gXCJET01Nb3VzZVNjcm9sbFwiICkge1xuICAgICAgICBfcmVtb3ZlV2hlZWxMaXN0ZW5lcihlbGVtLCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIiwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb246IGFkZFdoZWVsTGlzdGVuZXIsXG4gICAgb2ZmOiByZW1vdmVXaGVlbExpc3RlbmVyXG4gIH07XG5cbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/uniwheel.js\n");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/utilities.js":
/*!****************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/utilities.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function(target, source) {\n    target = target || {};\n    for (var prop in source) {\n      // Go recursively\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop])\n      } else {\n        target[prop] = source[prop]\n      }\n    }\n    return target;\n  }\n\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n, isElement: function(o){\n    return (\n      o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || //DOM2\n      (o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string')\n    );\n  }\n\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n, isObject: function(o){\n    return Object.prototype.toString.call(o) === '[object Object]';\n  }\n\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n, isNumber: function(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n, getSvg: function(elementOrSelector) {\n    var element\n      , svg;\n\n    if (!this.isElement(elementOrSelector)) {\n      // If selector provided\n      if (typeof elementOrSelector === 'string' || elementOrSelector instanceof String) {\n        // Try to find the element\n        element = document.querySelector(elementOrSelector)\n\n        if (!element) {\n          throw new Error('Provided selector did not find any elements. Selector: ' + elementOrSelector)\n          return null\n        }\n      } else {\n        throw new Error('Provided selector is not an HTML object nor String')\n        return null\n      }\n    } else {\n      element = elementOrSelector\n    }\n\n    if (element.tagName.toLowerCase() === 'svg') {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === 'object') {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === 'embed') {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === 'img') {\n            throw new Error('Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.');\n          } else {\n            throw new Error('Cannot get SVG.');\n          }\n          return null\n        }\n      }\n    }\n\n    return svg\n  }\n\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n, proxy: function(fn, context) {\n    return function() {\n      return fn.apply(context, arguments)\n    }\n  }\n\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n, getType: function(o) {\n    return Object.prototype.toString.apply(o).replace(/^\\[object\\s/, '').replace(/\\]$/, '')\n  }\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n, mouseAndTouchNormalize: function(evt, svg) {\n    // If no clientX then fallback\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      // Fallback\n      evt.clientX = 0\n      evt.clientY = 0\n\n      // If it is a touch event\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX\n          evt.clientY = evt.touches[0].clientY\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n\n          evt.clientX = evt.touches[0].pageX - rect.left\n          evt.clientY = evt.touches[0].pageY - rect.top\n        }\n      // If it is a custom event\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX\n          evt.clientY = evt.originalEvent.clientY\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n, isDblClick: function(evt, prevEvt) {\n    // Double click detected by browser\n    if (evt.detail === 2) {\n      return true;\n    }\n    // Try to compare events\n    else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp // should be lower than 250 ms\n        , touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2))\n\n      return timeStampDiff < 250 && touchesDistance < 10\n    }\n\n    // Nothing found\n    return false;\n  }\n\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n, now: Date.now || function() {\n    return new Date().getTime();\n  }\n\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n// jscs:disable\n// jshint ignore:start\n, throttle: function(func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = that.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  }\n// jshint ignore:end\n// jscs:enable\n\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n, createRequestAnimationFrame: function(refreshRate) {\n    var timeout = null\n\n    // Convert refreshRate to timeout\n    if (refreshRate !== 'auto' && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1000 / refreshRate)\n    }\n\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33)\n    } else {\n      return requestTimeout(timeout)\n    }\n  }\n}\n\n/**\n * Create a callback that will execute after a given timeout\n *\n * @param  {Function} timeout\n * @return {Function}\n */\nfunction requestTimeout(timeout) {\n  return function(callback) {\n    window.setTimeout(callback, timeout)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy91dGlsaXRpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy91dGlsaXRpZXMuanM/NGNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEV4dGVuZHMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0IG9iamVjdCB0byBleHRlbmRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2Ugb2JqZWN0IHRvIHRha2UgcHJvcGVydGllcyBmcm9tXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIGV4dGVuZGVkIG9iamVjdFxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgLy8gR28gcmVjdXJzaXZlbHlcbiAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHNvdXJjZVtwcm9wXSkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdGhpcy5leHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgbyBIVE1MIGVsZW1lbnQgb3IgU3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgcmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50XG4gICAqL1xuLCBpc0VsZW1lbnQ6IGZ1bmN0aW9uKG8pe1xuICAgIHJldHVybiAoXG4gICAgICBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgbyBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgfHwgbyBpbnN0YW5jZW9mIFNWR1NWR0VsZW1lbnQgfHwgLy9ET00yXG4gICAgICAobyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYW4gT2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG8gT2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgcmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhbiBPYmplY3RcbiAgICovXG4sIGlzT2JqZWN0OiBmdW5jdGlvbihvKXtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdmFyaWFibGUgaXMgTnVtYmVyXG4gICAqXG4gICAqIEBwYXJhbSAge0ludGVnZXJ8RmxvYXR9ICBuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgcmV0dXJucyB0cnVlIGlmIHZhcmlhYmxlIGlzIE51bWJlclxuICAgKi9cbiwgaXNOdW1iZXI6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgYW4gU1ZHIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gZWxlbWVudE9yU2VsZWN0b3IgRE9NIEVsZW1lbnQgb3Igc2VsZWN0b3IgU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdHxOdWxsfSAgICAgICAgICAgICAgICAgICBTVkcgb3IgbnVsbFxuICAgKi9cbiwgZ2V0U3ZnOiBmdW5jdGlvbihlbGVtZW50T3JTZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50XG4gICAgICAsIHN2ZztcblxuICAgIGlmICghdGhpcy5pc0VsZW1lbnQoZWxlbWVudE9yU2VsZWN0b3IpKSB7XG4gICAgICAvLyBJZiBzZWxlY3RvciBwcm92aWRlZFxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50T3JTZWxlY3RvciA9PT0gJ3N0cmluZycgfHwgZWxlbWVudE9yU2VsZWN0b3IgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGVsZW1lbnRcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudE9yU2VsZWN0b3IpXG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBzZWxlY3RvciBkaWQgbm90IGZpbmQgYW55IGVsZW1lbnRzLiBTZWxlY3RvcjogJyArIGVsZW1lbnRPclNlbGVjdG9yKVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc2VsZWN0b3IgaXMgbm90IGFuIEhUTUwgb2JqZWN0IG5vciBTdHJpbmcnKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudE9yU2VsZWN0b3JcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICBzdmcgPSBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHN2ZyA9IGVsZW1lbnQuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2VtYmVkJykge1xuICAgICAgICAgIHN2ZyA9IGVsZW1lbnQuZ2V0U1ZHRG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2NyaXB0IGFuIFNWRyBpbiBhbiBcImltZ1wiIGVsZW1lbnQuIFBsZWFzZSB1c2UgYW4gXCJvYmplY3RcIiBlbGVtZW50IG9yIGFuIGluLWxpbmUgU1ZHLicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgU1ZHLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN2Z1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGdpdmVuIGNvbnRleHQgdG8gYSBmdW5jdGlvblxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICBGdW5jdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgY29udGV4dCBDb250ZXh0XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgRnVuY3Rpb24gd2l0aCBjZXJ0YWluIGNvbnRleHRcbiAgICovXG4sIHByb3h5OiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IHR5cGVcbiAgICogVXNlcyB0b1N0cmluZyB0aGF0IHJldHVybnMgW29iamVjdCBTVkdQb2ludF1cbiAgICogQW5kIHRoYW4gcGFyc2VzIG9iamVjdCB0eXBlIGZyb20gc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbyBBbnkgb2JqZWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICBPYmplY3QgdHlwZVxuICAgKi9cbiwgZ2V0VHlwZTogZnVuY3Rpb24obykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG8pLnJlcGxhY2UoL15cXFtvYmplY3RcXHMvLCAnJykucmVwbGFjZSgvXFxdJC8sICcnKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGl0IGlzIGEgdG91Y2ggZXZlbnQgdGhhbiBhZGQgY2xpZW50WCBhbmQgY2xpZW50WSB0byBldmVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtICB7RXZlbnR9IGV2dFxuICAgKiBAcGFyYW0gIHtTVkdTVkdFbGVtZW50fSBzdmdcbiAgICovXG4sIG1vdXNlQW5kVG91Y2hOb3JtYWxpemU6IGZ1bmN0aW9uKGV2dCwgc3ZnKSB7XG4gICAgLy8gSWYgbm8gY2xpZW50WCB0aGVuIGZhbGxiYWNrXG4gICAgaWYgKGV2dC5jbGllbnRYID09PSB2b2lkIDAgfHwgZXZ0LmNsaWVudFggPT09IG51bGwpIHtcbiAgICAgIC8vIEZhbGxiYWNrXG4gICAgICBldnQuY2xpZW50WCA9IDBcbiAgICAgIGV2dC5jbGllbnRZID0gMFxuXG4gICAgICAvLyBJZiBpdCBpcyBhIHRvdWNoIGV2ZW50XG4gICAgICBpZiAoZXZ0LnRvdWNoZXMgIT09IHZvaWQgMCAmJiBldnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGV2dC50b3VjaGVzWzBdLmNsaWVudFggIT09IHZvaWQgMCkge1xuICAgICAgICAgIGV2dC5jbGllbnRYID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WFxuICAgICAgICAgIGV2dC5jbGllbnRZID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICB9IGVsc2UgaWYgKGV2dC50b3VjaGVzWzBdLnBhZ2VYICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IHN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIGV2dC5jbGllbnRYID0gZXZ0LnRvdWNoZXNbMF0ucGFnZVggLSByZWN0LmxlZnRcbiAgICAgICAgICBldnQuY2xpZW50WSA9IGV2dC50b3VjaGVzWzBdLnBhZ2VZIC0gcmVjdC50b3BcbiAgICAgICAgfVxuICAgICAgLy8gSWYgaXQgaXMgYSBjdXN0b20gZXZlbnRcbiAgICAgIH0gZWxzZSBpZiAoZXZ0Lm9yaWdpbmFsRXZlbnQgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoZXZ0Lm9yaWdpbmFsRXZlbnQuY2xpZW50WCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXZ0LmNsaWVudFggPSBldnQub3JpZ2luYWxFdmVudC5jbGllbnRYXG4gICAgICAgICAgZXZ0LmNsaWVudFkgPSBldnQub3JpZ2luYWxFdmVudC5jbGllbnRZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgYSBkb3VibGUgY2xpY2svdGFwXG4gICAqIFRPRE86IEZvciB0b3VjaCBnZXN0dXJlcyB1c2UgYSBsaWJyYXJ5IChoYW1tZXIuanMpIHRoYXQgdGFrZXMgaW4gYWNjb3VudCBvdGhlciBldmVudHNcbiAgICogKHRvdWNobW92ZSBhbmQgdG91Y2hlbmQpLiBJdCBzaG91bGQgdGFrZSBpbiBhY2NvdW50IHRhcCBkdXJhdGlvbiBhbmQgdHJhdmVsZWQgZGlzdGFuY2VcbiAgICpcbiAgICogQHBhcmFtICB7RXZlbnR9ICBldnRcbiAgICogQHBhcmFtICB7RXZlbnR9ICBwcmV2RXZ0IFByZXZpb3VzIEV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuLCBpc0RibENsaWNrOiBmdW5jdGlvbihldnQsIHByZXZFdnQpIHtcbiAgICAvLyBEb3VibGUgY2xpY2sgZGV0ZWN0ZWQgYnkgYnJvd3NlclxuICAgIGlmIChldnQuZGV0YWlsID09PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGNvbXBhcmUgZXZlbnRzXG4gICAgZWxzZSBpZiAocHJldkV2dCAhPT0gdm9pZCAwICYmIHByZXZFdnQgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aW1lU3RhbXBEaWZmID0gZXZ0LnRpbWVTdGFtcCAtIHByZXZFdnQudGltZVN0YW1wIC8vIHNob3VsZCBiZSBsb3dlciB0aGFuIDI1MCBtc1xuICAgICAgICAsIHRvdWNoZXNEaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhldnQuY2xpZW50WCAtIHByZXZFdnQuY2xpZW50WCwgMikgKyBNYXRoLnBvdyhldnQuY2xpZW50WSAtIHByZXZFdnQuY2xpZW50WSwgMikpXG5cbiAgICAgIHJldHVybiB0aW1lU3RhbXBEaWZmIDwgMjUwICYmIHRvdWNoZXNEaXN0YW5jZSA8IDEwXG4gICAgfVxuXG4gICAgLy8gTm90aGluZyBmb3VuZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXJcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiwgbm93OiBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxuICAvLyBGcm9tIHVuZGVyc2NvcmUuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbi8vIGpzY3M6ZGlzYWJsZVxuLy8ganNoaW50IGlnbm9yZTpzdGFydFxuLCB0aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IHRoYXQubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSB0aGF0Lm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbi8vIGpzaGludCBpZ25vcmU6ZW5kXG4vLyBqc2NzOmVuYWJsZVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgc2ltdWxhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSByZWZyZXNoUmF0ZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4sIGNyZWF0ZVJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24ocmVmcmVzaFJhdGUpIHtcbiAgICB2YXIgdGltZW91dCA9IG51bGxcblxuICAgIC8vIENvbnZlcnQgcmVmcmVzaFJhdGUgdG8gdGltZW91dFxuICAgIGlmIChyZWZyZXNoUmF0ZSAhPT0gJ2F1dG8nICYmIHJlZnJlc2hSYXRlIDwgNjAgJiYgcmVmcmVzaFJhdGUgPiAxKSB7XG4gICAgICB0aW1lb3V0ID0gTWF0aC5mbG9vcigxMDAwIC8gcmVmcmVzaFJhdGUpXG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RUaW1lb3V0KDMzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVxdWVzdFRpbWVvdXQodGltZW91dClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWxsYmFjayB0aGF0IHdpbGwgZXhlY3V0ZSBhZnRlciBhIGdpdmVuIHRpbWVvdXRcbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gdGltZW91dFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RUaW1lb3V0KHRpbWVvdXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpXG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svg-pan-zoom/src/utilities.js\n");

/***/ }),

/***/ "./node_modules/topojson/dist/topojson.js":
/*!************************************************!*\
  !*** ./node_modules/topojson/dist/topojson.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://github.com/topojson/topojson Version 2.2.0. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n// Computes the bounding box of the specified hash of GeoJSON objects.\nvar bounds = function(objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },\n    Point: function(o) { boundPoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },\n    LineString: function(o) { boundLine(o.coordinates); },\n    MultiLineString: function(o) { o.coordinates.forEach(boundLine); },\n    Polygon: function(o) { o.coordinates.forEach(boundLine); },\n    MultiPolygon: function(o) { o.coordinates.forEach(boundMultiLine); }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n};\n\nvar hashset = function(size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = (index + 1) & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = (index + 1) & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n};\n\nvar hashmap = function(size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n};\n\nvar equalPoint = function(pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n};\n\n// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16);\nvar floats = new Float64Array(buffer);\nvar uints = new Uint32Array(buffer);\n\nvar hashPoint = function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n};\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point A’s adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nvar join = function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0, // upper bound on number of junctions\n      i, n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)\n        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n};\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nvar cut = function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n};\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n\n// Given a cut topology, combines duplicate arcs.\nvar dedup = function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n};\n\n// Given a TopoJSON topology in absolute (quantized) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given topology!\nvar delta = function(topology) {\n  var arcs = topology.arcs,\n      i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n    while (++j < m) {\n      point = arc[j];\n      x1 = point[0];\n      y1 = point[1];\n      arc[j] = [x1 - x0, y1 - y0];\n      x0 = x1;\n      y0 = y1;\n    }\n  }\n\n  return topology;\n};\n\n// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nvar extract = function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.coordinates); delete o.coordinates; },\n    MultiLineString: function(o) { o.arcs = o.coordinates.map(extractLine); delete o.coordinates; },\n    Polygon: function(o) { o.arcs = o.coordinates.map(extractRing); delete o.coordinates; },\n    MultiPolygon: function(o) { o.arcs = o.coordinates.map(extractMultiRing); delete o.coordinates; }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n};\n\n// Given a hash of GeoJSON objects, replaces Features with geometry objects.\n// This is a destructive operation that modifies the input objects!\nvar geometry = function(objects) {\n  var key;\n  for (key in objects) objects[key] = geomifyObject(objects[key]);\n  return objects;\n};\n\nfunction geomifyObject(object) {\n  return (object && geomifyObjectType.hasOwnProperty(object.type)\n      ? geomifyObjectType[object.type]\n      : geomifyGeometry)(object);\n}\n\nfunction geomifyFeature(feature) {\n  var geometry = feature.geometry;\n  if (geometry == null) {\n    feature.type = null;\n  } else {\n    geomifyGeometry(geometry);\n    feature.type = geometry.type;\n    if (geometry.geometries) feature.geometries = geometry.geometries;\n    else if (geometry.coordinates) feature.coordinates = geometry.coordinates;\n    if (geometry.bbox) feature.bbox = geometry.bbox;\n  }\n  delete feature.geometry;\n  return feature;\n}\n\nfunction geomifyGeometry(geometry) {\n  if (!geometry) return {type: null};\n  if (geomifyGeometryType.hasOwnProperty(geometry.type)) geomifyGeometryType[geometry.type](geometry);\n  return geometry;\n}\n\nvar geomifyObjectType = {\n  Feature: geomifyFeature,\n  FeatureCollection: function(collection) {\n    collection.type = \"GeometryCollection\";\n    collection.geometries = collection.features;\n    collection.features.forEach(geomifyFeature);\n    delete collection.features;\n    return collection;\n  }\n};\n\nvar geomifyGeometryType = {\n  GeometryCollection: function(o) {\n    var geometries = o.geometries, i = -1, n = geometries.length;\n    while (++i < n) geometries[i] = geomifyGeometry(geometries[i]);\n  },\n  MultiPoint: function(o) {\n    if (!o.coordinates.length) {\n      o.type = null;\n      delete o.coordinates;\n    } else if (o.coordinates.length < 2) {\n      o.type = \"Point\";\n      o.coordinates = o.coordinates[0];\n    }\n  },\n  LineString: function(o) {\n    if (!o.coordinates.length) {\n      o.type = null;\n      delete o.coordinates;\n    }\n  },\n  MultiLineString: function(o) {\n    for (var lines = o.coordinates, i = 0, N = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i];\n      if (line.length) lines[N++] = line;\n    }\n    if (!N) {\n      o.type = null;\n      delete o.coordinates;\n    } else if (N < 2) {\n      o.type = \"LineString\";\n      o.coordinates = lines[0];\n    } else {\n      o.coordinates.length = N;\n    }\n  },\n  Polygon: function(o) {\n    for (var rings = o.coordinates, i = 0, N = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i];\n      if (ring.length) rings[N++] = ring;\n    }\n    if (!N) {\n      o.type = null;\n      delete o.coordinates;\n    } else {\n      o.coordinates.length = N;\n    }\n  },\n  MultiPolygon: function(o) {\n    for (var polygons = o.coordinates, j = 0, M = 0, m = polygons.length; j < m; ++j) {\n      for (var rings = polygons[j], i = 0, N = 0, n = rings.length; i < n; ++i) {\n        var ring = rings[i];\n        if (ring.length) rings[N++] = ring;\n      }\n      if (N) {\n        rings.length = N;\n        polygons[M++] = rings;\n      }\n    }\n    if (!M) {\n      o.type = null;\n      delete o.coordinates;\n    } else if (M < 2) {\n      o.type = \"Polygon\";\n      o.coordinates = polygons[0];\n    } else {\n      polygons.length = M;\n    }\n  }\n};\n\nvar prequantize = function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(coordinates) {\n    coordinates[0] = Math.round((coordinates[0] - x0) * kx);\n    coordinates[1] = Math.round((coordinates[1] - y0) * ky);\n    return coordinates;\n  }\n\n  function quantizeLine(coordinates) {\n    var i = 0,\n        j = 1,\n        n = coordinates.length,\n        pi = quantizePoint(coordinates[0]),\n        pj,\n        px = pi[0],\n        py = pi[1],\n        x,\n        y;\n\n    while (++i < n) {\n      pi = quantizePoint(coordinates[i]);\n      x = pi[0];\n      y = pi[1];\n      if (x !== px || y !== py) { // skip coincident points\n        pj = coordinates[j++];\n        pj[0] = px = x;\n        pj[1] = py = y;\n      }\n    }\n\n    coordinates.length = j;\n  }\n\n  function quantizeGeometry(o) {\n    if (o && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) {\n      o.geometries.forEach(quantizeGeometry);\n    },\n    Point: function(o) {\n      quantizePoint(o.coordinates);\n    },\n    MultiPoint: function(o) {\n      o.coordinates.forEach(quantizePoint);\n    },\n    LineString: function(o) {\n      var line = o.coordinates;\n      quantizeLine(line);\n      if (line.length < 2) line[1] = line[0]; // must have 2+\n    },\n    MultiLineString: function(o) {\n      for (var lines = o.coordinates, i = 0, n = lines.length; i < n; ++i) {\n        var line = lines[i];\n        quantizeLine(line);\n        if (line.length < 2) line[1] = line[0]; // must have 2+\n      }\n    },\n    Polygon: function(o) {\n      for (var rings = o.coordinates, i = 0, n = rings.length; i < n; ++i) {\n        var ring = rings[i];\n        quantizeLine(ring);\n        while (ring.length < 4) ring.push(ring[0]); // must have 4+\n      }\n    },\n    MultiPolygon: function(o) {\n      for (var polygons = o.coordinates, i = 0, n = polygons.length; i < n; ++i) {\n        for (var rings = polygons[i], j = 0, m = rings.length; j < m; ++j) {\n          var ring = rings[j];\n          quantizeLine(ring);\n          while (ring.length < 4) ring.push(ring[0]); // must have 4+\n        }\n      }\n    }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n};\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nvar topology = function(objects, quantization) {\n  var bbox = bounds(geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry$$1) {\n    if (geometry$$1 && indexGeometryType.hasOwnProperty(geometry$$1.type)) indexGeometryType[geometry$$1.type](geometry$$1);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    delta(topology);\n  }\n\n  return topology;\n};\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n\nvar prune = function(topology) {\n  var oldArcs = topology.arcs,\n      newArcs = topology.arcs = [],\n      newArcIndex = -1,\n      newIndexByOldIndex = new Array(oldArcs.length),\n      name;\n\n  function pruneGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(pruneGeometry); break;\n      case \"LineString\": pruneArcs(o.arcs); break;\n      case \"MultiLineString\": o.arcs.forEach(pruneArcs); break;\n      case \"Polygon\": o.arcs.forEach(pruneArcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(pruneMultiArcs); break;\n    }\n  }\n\n  function pruneArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i) {\n      var oldIndex = arcs[i],\n          oldReverse = oldIndex < 0 && (oldIndex = ~oldIndex, true),\n          newIndex;\n\n      // If this is the first instance of this arc,\n      // record it under its new index.\n      if ((newIndex = newIndexByOldIndex[oldIndex]) == null) {\n        newIndexByOldIndex[oldIndex] = newIndex = ++newArcIndex;\n        newArcs[newIndex] = oldArcs[oldIndex];\n      }\n\n      arcs[i] = oldReverse ? ~newIndex : newIndex;\n    }\n  }\n\n  function pruneMultiArcs(arcs) {\n    arcs.forEach(pruneArcs);\n  }\n\n  for (name in topology.objects) {\n    pruneGeometry(topology.objects[name]);\n  }\n\n  return topology;\n};\n\nvar filter = function(topology, filter) {\n  var name;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(o) {\n    switch (o.type) {\n      case \"Polygon\": {\n        o.arcs = filterRings(o.arcs);\n        if (!o.arcs) o.type = null, delete o.arcs;\n        break;\n      }\n      case \"MultiPolygon\": {\n        o.arcs = o.arcs.map(filterRings).filter(filterIdentity);\n        if (!o.arcs.length) o.type = null, delete o.arcs;\n        break;\n      }\n      case \"GeometryCollection\": {\n        o.geometries.forEach(filterGeometry);\n        o.geometries = o.geometries.filter(filterNotNull);\n        if (!o.geometries.length) o.type = null, delete o.geometries;\n        break;\n      }\n    }\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs.shift()].concat(arcs.filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (name in topology.objects) {\n    filterGeometry(topology.objects[name]);\n  }\n\n  return prune(topology);\n};\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n\nvar filterAttached = function(topology) {\n  var uniqueRingByArc = {}, // arc index -> index of unique associated ring, or -1 if used by multiple rings\n      ringIndex = 0,\n      name;\n\n  function testGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(testGeometry); break;\n      case \"Polygon\": testArcs(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(testArcs); break;\n    }\n  }\n\n  function testArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i, ++ringIndex) {\n      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n        var arc = ring[j];\n        if (arc < 0) arc = ~arc;\n        var uniqueRing = uniqueRingByArc[arc];\n        if (uniqueRing >= 0 && uniqueRing !== ringIndex) uniqueRingByArc[arc] = -1;\n        else uniqueRingByArc[arc] = ringIndex;\n      }\n    }\n  }\n\n  for (name in topology.objects) {\n    testGeometry(topology.objects[name]);\n  }\n\n  return function(ring) {\n    for (var j = 0, m = ring.length, arc; j < m; ++j) {\n      if (arc = ring[j], uniqueRingByArc[arc < 0 ? ~arc : arc] < 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform = function(topology) {\n  if ((transform = topology.transform) == null) return identity;\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) x0 = y0 = 0;\n    point[0] = (x0 += point[0]) * kx + dx;\n    point[1] = (y0 += point[1]) * ky + dy;\n    return point;\n  };\n};\n\nvar bbox = function(topology) {\n  var bbox = topology.bbox;\n\n  function bboxPoint(p0) {\n    p1[0] = p0[0], p1[1] = p0[1], t(p1);\n    if (p1[0] < x0) x0 = p1[0];\n    if (p1[0] > x1) x1 = p1[0];\n    if (p1[1] < y0) y0 = p1[1];\n    if (p1[1] > y1) y1 = p1[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  if (!bbox) {\n    var t = transform(topology), p0, p1 = new Array(2), name,\n        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n    topology.arcs.forEach(function(arc) {\n      var i = -1, n = arc.length;\n      while (++i < n) {\n        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);\n        if (p1[0] < x0) x0 = p1[0];\n        if (p1[0] > x1) x1 = p1[0];\n        if (p1[1] < y0) y0 = p1[1];\n        if (p1[1] > y1) y1 = p1[1];\n      }\n    });\n\n    for (name in topology.objects) {\n      bboxGeometry(topology.objects[name]);\n    }\n\n    bbox = topology.bbox = [x0, y0, x1, y1];\n  }\n\n  return bbox;\n};\n\nvar reverse$1 = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k].slice(), k));\n    }\n    if (i < 0) reverse$1(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p.slice());\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0].slice());\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0].slice());\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n};\n\nvar mesh = function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n};\n\nfunction meshArcs(topology, object$$1, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar merge = function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n};\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n};\n\nvar neighbors = function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n};\n\nvar quantize = function(topology, n) {\n  if (!((n = Math.floor(n)) >= 2)) throw new Error(\"n must be \\u22652\");\n  if (topology.transform) throw new Error(\"already quantized\");\n  var bb = bbox(topology), name,\n      dx = bb[0], kx = (bb[2] - dx) / (n - 1) || 1,\n      dy = bb[1], ky = (bb[3] - dy) / (n - 1) || 1;\n\n  function quantizePoint(p) {\n    p[0] = Math.round((p[0] - dx) / kx);\n    p[1] = Math.round((p[1] - dy) / ky);\n  }\n\n  function quantizeGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(quantizeGeometry); break;\n      case \"Point\": quantizePoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(quantizePoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = 1,\n        j = 1,\n        n = arc.length,\n        pi = arc[0],\n        x0 = pi[0] = Math.round((pi[0] - dx) / kx),\n        y0 = pi[1] = Math.round((pi[1] - dy) / ky),\n        pj,\n        x1,\n        y1;\n\n    for (; i < n; ++i) {\n      pi = arc[i];\n      x1 = Math.round((pi[0] - dx) / kx);\n      y1 = Math.round((pi[1] - dy) / ky);\n      if (x1 !== x0 || y1 !== y0) {\n        pj = arc[j++];\n        pj[0] = x1 - x0, x0 = x1;\n        pj[1] = y1 - y0, y0 = y1;\n      }\n    }\n\n    if (j < 2) {\n      pj = arc[j++];\n      pj[0] = 0;\n      pj[1] = 0;\n    }\n\n    arc.length = j;\n  });\n\n  for (name in topology.objects) {\n    quantizeGeometry(topology.objects[name]);\n  }\n\n  topology.transform = {\n    scale: [kx, ky],\n    translate: [dx, dy]\n  };\n\n  return topology;\n};\n\nvar untransform = function(topology) {\n  if ((transform = topology.transform) == null) return identity;\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) x0 = y0 = 0;\n    var x1 = Math.round((point[0] - dx) / kx),\n        y1 = Math.round((point[1] - dy) / ky);\n    point[0] = x1 - x0, x0 = x1;\n    point[1] = y1 - y0, y0 = y1;\n    return point;\n  };\n};\n\nfunction planarTriangleArea(triangle) {\n  var a = triangle[0], b = triangle[1], c = triangle[2];\n  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n}\n\nfunction planarRingArea$1(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area) / 2;\n}\n\nvar filterWeight = function(topology, minWeight, weight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  if (weight == null) weight = planarRingArea$1;\n\n  return function(ring, interior) {\n    return weight(feature(topology, {type: \"Polygon\", arcs: [ring]}).geometry.coordinates[0], interior) >= minWeight;\n  };\n};\n\nfunction compare(a, b) {\n  return a[1][2] - b[1][2];\n}\n\nvar newHeap = function() {\n  var heap = {},\n      array = [],\n      size = 0;\n\n  heap.push = function(object) {\n    up(array[object._ = size] = object, size++);\n    return size;\n  };\n\n  heap.pop = function() {\n    if (size <= 0) return;\n    var removed = array[0], object;\n    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n    return removed;\n  };\n\n  heap.remove = function(removed) {\n    var i = removed._, object;\n    if (array[i] !== removed) return; // invalid request\n    if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n    return i;\n  };\n\n  function up(object, i) {\n    while (i > 0) {\n      var j = ((i + 1) >> 1) - 1,\n          parent = array[j];\n      if (compare(object, parent) >= 0) break;\n      array[parent._ = i] = parent;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  function down(object, i) {\n    while (true) {\n      var r = (i + 1) << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n      if (l < size && compare(array[l], child) < 0) child = array[j = l];\n      if (r < size && compare(array[r], child) < 0) child = array[j = r];\n      if (j === i) break;\n      array[child._ = i] = child;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  return heap;\n};\n\nvar presimplify = function(topology, weight) {\n  var absolute = transform(topology),\n      relative = untransform(topology),\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  topology.arcs.forEach(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc.forEach(absolute);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = arc.slice(i - 1, i + 2);\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    arc.forEach(relative);\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return topology;\n};\n\nvar quantile = function(topology, p) {\n  var array = [];\n\n  topology.arcs.forEach(function(arc) {\n    arc.forEach(function(point) {\n      if (isFinite(point[2])) { // Ignore endpoints, whose weight is Infinity.\n        array.push(point[2]);\n      }\n    });\n  });\n\n  return array.length && quantile$1(array.sort(descending), p);\n};\n\nfunction quantile$1(array, p) {\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return array[0];\n  if (p >= 1) return array[n - 1];\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = array[i],\n      b = array[i + 1];\n  return a + (b - a) * (h - i);\n}\n\nfunction descending(a, b) {\n  return b - a;\n}\n\nvar simplify = function(topology, minWeight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  // Remove points whose weight is less than the minimum weight.\n  topology.arcs.forEach(topology.transform ? function(arc) {\n    var dx = 0,\n        dy = 0, // accumulate removed points\n        i = -1,\n        j = -1,\n        n = arc.length,\n        source,\n        target;\n\n    while (++i < n) {\n      source = arc[i];\n      if (source[2] >= minWeight) {\n        target = arc[++j];\n        target[0] = source[0] + dx;\n        target[1] = source[1] + dy;\n        dx = dy = 0;\n      } else {\n        dx += source[0];\n        dy += source[1];\n      }\n    }\n\n    arc.length = ++j;\n  } : function(arc) {\n    var i = -1,\n        j = -1,\n        n = arc.length,\n        point;\n\n    while (++i < n) {\n      point = arc[i];\n      if (point[2] >= minWeight) {\n        arc[++j] = point;\n      }\n    }\n\n    arc.length = ++j;\n  });\n\n  // Remove the computed weight for each point, and remove coincident points.\n  // This is done as a separate pass because some coordinates may be shared\n  // between arcs (such as the last point and first point of a cut line).\n  // If the entire arc is empty, retain at least two points (per spec).\n  topology.arcs.forEach(topology.transform ? function(arc) {\n    var i = 0,\n        j = 0,\n        n = arc.length,\n        p = arc[0];\n    p.length = 2;\n    while (++i < n) {\n      p = arc[i];\n      p.length = 2;\n      if (p[0] || p[1]) arc[++j] = p;\n    }\n    arc.length = (j || 1) + 1;\n  } : function(arc) {\n    var i = 0,\n        j = 0,\n        n = arc.length,\n        p = arc[0],\n        x0 = p[0],\n        y0 = p[1],\n        x1,\n        y1;\n    p.length = 2;\n    while (++i < n) {\n      p = arc[i], x1 = p[0], y1 = p[1];\n      p.length = 2;\n      if (x0 !== x1 || y0 !== y1) arc[++j] = p, x0 = x1, y0 = y1;\n    }\n    arc.length = (j || 1) + 1;\n  });\n\n  return topology;\n};\n\nvar pi = Math.PI;\nvar tau = 2 * pi;\nvar fourPi = 4 * pi;\nvar radians = pi / 180;\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar max = Math.max;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\n\nfunction sphericalRingArea(ring, interior) {\n  if (!ring.length) return 0;\n  var sum = 0,\n      point = ring[0],\n      lambda0, lambda1 = point[0] * radians, delta,\n      phi1 = (point[1] * radians + tau) / 2,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1),\n      i, n, k;\n\n  for (i = 1, n = ring.length; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians, delta = lambda1 - lambda0;\n    phi1 = (point[1] * radians + tau) / 2;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point. Uses a formula derived from Cagnoli’s\n    // theorem. See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    k = sinPhi0 * sinPhi1;\n    sum += atan2(k * sin(delta), cosPhi0 * cosPhi1 + k * cos(delta));\n  }\n\n  sum = 2 * (sum > pi ? sum - tau : sum < -pi ? sum + tau : sum);\n  if (interior) sum *= -1;\n  return sum < 0 ? sum + fourPi : sum;\n}\n\nfunction sphericalTriangleArea(t) {\n  var lambda0 = t[0][0] * radians, phi0 = t[0][1] * radians, cosPhi0 = cos(phi0), sinPhi0 = sin(phi0),\n      lambda1 = t[1][0] * radians, phi1 = t[1][1] * radians, cosPhi1 = cos(phi1), sinPhi1 = sin(phi1),\n      lambda2 = t[2][0] * radians, phi2 = t[2][1] * radians, cosPhi2 = cos(phi2), sinPhi2 = sin(phi2),\n      a = distance(lambda0, cosPhi0, sinPhi0, lambda1, cosPhi1, sinPhi1),\n      b = distance(lambda1, cosPhi1, sinPhi1, lambda2, cosPhi2, sinPhi2),\n      c = distance(lambda2, cosPhi2, sinPhi2, lambda0, cosPhi0, sinPhi0),\n      s = (a + b + c) / 2;\n  return 4 * atan(sqrt(max(0, tan(s / 2) * tan((s - a) / 2) * tan((s - b) / 2) * tan((s - c) / 2))));\n}\n\nfunction distance(lambda0, sinPhi0, cosPhi0, lambda1, sinPhi1, cosPhi1) {\n  var delta = abs(lambda1 - lambda0),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi1 * sinDelta,\n      y = cosPhi0 * sinPhi1 - sinPhi0 * cosPhi1 * cosDelta,\n      z = sinPhi0 * sinPhi1 + cosPhi0 * cosPhi1 * cosDelta;\n  return atan2(sqrt(x * x + y * y), z);\n}\n\nexports.topology = topology;\nexports.filter = filter;\nexports.filterAttached = filterAttached;\nexports.filterWeight = filterWeight;\nexports.planarRingArea = planarRingArea$1;\nexports.planarTriangleArea = planarTriangleArea;\nexports.presimplify = presimplify;\nexports.quantile = quantile;\nexports.simplify = simplify;\nexports.sphericalRingArea = sphericalRingArea;\nexports.sphericalTriangleArea = sphericalTriangleArea;\nexports.bbox = bbox;\nexports.feature = feature;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9wb2pzb24vZGlzdC90b3BvanNvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b3BvanNvbi9kaXN0L3RvcG9qc29uLmpzP2JjZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RvcG9qc29uL3RvcG9qc29uIFZlcnNpb24gMi4yLjAuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC50b3BvanNvbiA9IGdsb2JhbC50b3BvanNvbiB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc3BlY2lmaWVkIGhhc2ggb2YgR2VvSlNPTiBvYmplY3RzLlxudmFyIGJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICBmdW5jdGlvbiBib3VuZEdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKGdlb21ldHJ5ICYmIGJvdW5kR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSBib3VuZEdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSk7XG4gIH1cblxuICB2YXIgYm91bmRHZW9tZXRyeVR5cGUgPSB7XG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvKSB7IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJvdW5kR2VvbWV0cnkpOyB9LFxuICAgIFBvaW50OiBmdW5jdGlvbihvKSB7IGJvdW5kUG9pbnQoby5jb29yZGluYXRlcyk7IH0sXG4gICAgTXVsdGlQb2ludDogZnVuY3Rpb24obykgeyBvLmNvb3JkaW5hdGVzLmZvckVhY2goYm91bmRQb2ludCk7IH0sXG4gICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyBib3VuZExpbmUoby5jb29yZGluYXRlcyk7IH0sXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IG8uY29vcmRpbmF0ZXMuZm9yRWFjaChib3VuZExpbmUpOyB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG8pIHsgby5jb29yZGluYXRlcy5mb3JFYWNoKGJvdW5kTGluZSk7IH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IG8uY29vcmRpbmF0ZXMuZm9yRWFjaChib3VuZE11bHRpTGluZSk7IH1cbiAgfTtcblxuICBmdW5jdGlvbiBib3VuZFBvaW50KGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIHggPSBjb29yZGluYXRlc1swXSxcbiAgICAgICAgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvdW5kTGluZShjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2goYm91bmRQb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiBib3VuZE11bHRpTGluZShjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2goYm91bmRMaW5lKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3RzKSB7XG4gICAgYm91bmRHZW9tZXRyeShvYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIHgxID49IHgwICYmIHkxID49IHkwID8gW3gwLCB5MCwgeDEsIHkxXSA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBoYXNoc2V0ID0gZnVuY3Rpb24oc2l6ZSwgaGFzaCwgZXF1YWwsIHR5cGUsIGVtcHR5KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdHlwZSA9IEFycmF5O1xuICAgIGVtcHR5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzdG9yZSA9IG5ldyB0eXBlKHNpemUgPSAxIDw8IE1hdGgubWF4KDQsIE1hdGguY2VpbChNYXRoLmxvZyhzaXplKSAvIE1hdGguTE4yKSkpLFxuICAgICAgbWFzayA9IHNpemUgLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgc3RvcmVbaV0gPSBlbXB0eTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IGhhc2godmFsdWUpICYgbWFzayxcbiAgICAgICAgbWF0Y2ggPSBzdG9yZVtpbmRleF0sXG4gICAgICAgIGNvbGxpc2lvbnMgPSAwO1xuICAgIHdoaWxlIChtYXRjaCAhPSBlbXB0eSkge1xuICAgICAgaWYgKGVxdWFsKG1hdGNoLCB2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCsrY29sbGlzaW9ucyA+PSBzaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJmdWxsIGhhc2hzZXRcIik7XG4gICAgICBtYXRjaCA9IHN0b3JlW2luZGV4ID0gKGluZGV4ICsgMSkgJiBtYXNrXTtcbiAgICB9XG4gICAgc3RvcmVbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBoYXModmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBoYXNoKHZhbHVlKSAmIG1hc2ssXG4gICAgICAgIG1hdGNoID0gc3RvcmVbaW5kZXhdLFxuICAgICAgICBjb2xsaXNpb25zID0gMDtcbiAgICB3aGlsZSAobWF0Y2ggIT0gZW1wdHkpIHtcbiAgICAgIGlmIChlcXVhbChtYXRjaCwgdmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICgrK2NvbGxpc2lvbnMgPj0gc2l6ZSkgYnJlYWs7XG4gICAgICBtYXRjaCA9IHN0b3JlW2luZGV4ID0gKGluZGV4ICsgMSkgJiBtYXNrXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0b3JlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG1hdGNoID0gc3RvcmVbaV07XG4gICAgICBpZiAobWF0Y2ggIT0gZW1wdHkpIHZhbHVlcy5wdXNoKG1hdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkOiBhZGQsXG4gICAgaGFzOiBoYXMsXG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfTtcbn07XG5cbnZhciBoYXNobWFwID0gZnVuY3Rpb24oc2l6ZSwgaGFzaCwgZXF1YWwsIGtleVR5cGUsIGtleUVtcHR5LCB2YWx1ZVR5cGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBrZXlUeXBlID0gdmFsdWVUeXBlID0gQXJyYXk7XG4gICAga2V5RW1wdHkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGtleXN0b3JlID0gbmV3IGtleVR5cGUoc2l6ZSA9IDEgPDwgTWF0aC5tYXgoNCwgTWF0aC5jZWlsKE1hdGgubG9nKHNpemUpIC8gTWF0aC5MTjIpKSksXG4gICAgICB2YWxzdG9yZSA9IG5ldyB2YWx1ZVR5cGUoc2l6ZSksXG4gICAgICBtYXNrID0gc2l6ZSAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICBrZXlzdG9yZVtpXSA9IGtleUVtcHR5O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBoYXNoKGtleSkgJiBtYXNrLFxuICAgICAgICBtYXRjaEtleSA9IGtleXN0b3JlW2luZGV4XSxcbiAgICAgICAgY29sbGlzaW9ucyA9IDA7XG4gICAgd2hpbGUgKG1hdGNoS2V5ICE9IGtleUVtcHR5KSB7XG4gICAgICBpZiAoZXF1YWwobWF0Y2hLZXksIGtleSkpIHJldHVybiB2YWxzdG9yZVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIGlmICgrK2NvbGxpc2lvbnMgPj0gc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiZnVsbCBoYXNobWFwXCIpO1xuICAgICAgbWF0Y2hLZXkgPSBrZXlzdG9yZVtpbmRleCA9IChpbmRleCArIDEpICYgbWFza107XG4gICAgfVxuICAgIGtleXN0b3JlW2luZGV4XSA9IGtleTtcbiAgICB2YWxzdG9yZVtpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gaGFzaChrZXkpICYgbWFzayxcbiAgICAgICAgbWF0Y2hLZXkgPSBrZXlzdG9yZVtpbmRleF0sXG4gICAgICAgIGNvbGxpc2lvbnMgPSAwO1xuICAgIHdoaWxlIChtYXRjaEtleSAhPSBrZXlFbXB0eSkge1xuICAgICAgaWYgKGVxdWFsKG1hdGNoS2V5LCBrZXkpKSByZXR1cm4gdmFsc3RvcmVbaW5kZXhdO1xuICAgICAgaWYgKCsrY29sbGlzaW9ucyA+PSBzaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJmdWxsIGhhc2htYXBcIik7XG4gICAgICBtYXRjaEtleSA9IGtleXN0b3JlW2luZGV4ID0gKGluZGV4ICsgMSkgJiBtYXNrXTtcbiAgICB9XG4gICAga2V5c3RvcmVbaW5kZXhdID0ga2V5O1xuICAgIHZhbHN0b3JlW2luZGV4XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldChrZXksIG1pc3NpbmdWYWx1ZSkge1xuICAgIHZhciBpbmRleCA9IGhhc2goa2V5KSAmIG1hc2ssXG4gICAgICAgIG1hdGNoS2V5ID0ga2V5c3RvcmVbaW5kZXhdLFxuICAgICAgICBjb2xsaXNpb25zID0gMDtcbiAgICB3aGlsZSAobWF0Y2hLZXkgIT0ga2V5RW1wdHkpIHtcbiAgICAgIGlmIChlcXVhbChtYXRjaEtleSwga2V5KSkgcmV0dXJuIHZhbHN0b3JlW2luZGV4XTtcbiAgICAgIGlmICgrK2NvbGxpc2lvbnMgPj0gc2l6ZSkgYnJlYWs7XG4gICAgICBtYXRjaEtleSA9IGtleXN0b3JlW2luZGV4ID0gKGluZGV4ICsgMSkgJiBtYXNrXTtcbiAgICB9XG4gICAgcmV0dXJuIG1pc3NpbmdWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGtleXN0b3JlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG1hdGNoS2V5ID0ga2V5c3RvcmVbaV07XG4gICAgICBpZiAobWF0Y2hLZXkgIT0ga2V5RW1wdHkpIGtleXMucHVzaChtYXRjaEtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXQ6IHNldCxcbiAgICBtYXliZVNldDogbWF5YmVTZXQsIC8vIHNldCBpZiB1bnNldFxuICAgIGdldDogZ2V0LFxuICAgIGtleXM6IGtleXNcbiAgfTtcbn07XG5cbnZhciBlcXVhbFBvaW50ID0gZnVuY3Rpb24ocG9pbnRBLCBwb2ludEIpIHtcbiAgcmV0dXJuIHBvaW50QVswXSA9PT0gcG9pbnRCWzBdICYmIHBvaW50QVsxXSA9PT0gcG9pbnRCWzFdO1xufTtcblxuLy8gVE9ETyBpZiBxdWFudGl6ZWQsIHVzZSBzaW1wbGVyIEludDMyIGhhc2hpbmc/XG5cbnZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xudmFyIGZsb2F0cyA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbnZhciB1aW50cyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuXG52YXIgaGFzaFBvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgZmxvYXRzWzBdID0gcG9pbnRbMF07XG4gIGZsb2F0c1sxXSA9IHBvaW50WzFdO1xuICB2YXIgaGFzaCA9IHVpbnRzWzBdIF4gdWludHNbMV07XG4gIGhhc2ggPSBoYXNoIDw8IDUgXiBoYXNoID4+IDcgXiB1aW50c1syXSBeIHVpbnRzWzNdO1xuICByZXR1cm4gaGFzaCAmIDB4N2ZmZmZmZmY7XG59O1xuXG4vLyBHaXZlbiBhbiBleHRyYWN0ZWQgKHByZS0pdG9wb2xvZ3ksIGlkZW50aWZpZXMgYWxsIG9mIHRoZSBqdW5jdGlvbnMuIFRoZXNlIGFyZVxuLy8gdGhlIHBvaW50cyBhdCB3aGljaCBhcmNzIChsaW5lcyBvciByaW5ncykgd2lsbCBuZWVkIHRvIGJlIGN1dCBzbyB0aGF0IGVhY2hcbi8vIGFyYyBpcyByZXByZXNlbnRlZCB1bmlxdWVseS5cbi8vXG4vLyBBIGp1bmN0aW9uIGlzIGEgcG9pbnQgd2hlcmUgYXQgbGVhc3Qgb25lIGFyYyBkZXZpYXRlcyBmcm9tIGFub3RoZXIgYXJjIGdvaW5nXG4vLyB0aHJvdWdoIHRoZSBzYW1lIHBvaW50LiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhlIHBvaW50IEIuIElmIHRoZXJlIGlzIGEgYXJjXG4vLyB0aHJvdWdoIEFCQyBhbmQgYW5vdGhlciBhcmMgdGhyb3VnaCBDQkEsIHRoZW4gQiBpcyBub3QgYSBqdW5jdGlvbiBiZWNhdXNlIGluXG4vLyBib3RoIGNhc2VzIHRoZSBhZGphY2VudCBwb2ludCBwYWlycyBhcmUge0EsQ30uIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIGFuXG4vLyBhZGRpdGlvbmFsIGFyYyBBQkQsIHRoZW4ge0EsRH0gIT0ge0EsQ30sIGFuZCB0aHVzIEIgYmVjb21lcyBhIGp1bmN0aW9uLlxuLy9cbi8vIEZvciBhIGNsb3NlZCByaW5nIEFCQ0EsIHRoZSBmaXJzdCBwb2ludCBB4oCZcyBhZGphY2VudCBwb2ludHMgYXJlIHRoZSBzZWNvbmRcbi8vIGFuZCBsYXN0IHBvaW50IHtCLEN9LiBGb3IgYSBsaW5lLCB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIGFsd2F5c1xuLy8gY29uc2lkZXJlZCBqdW5jdGlvbnMsIGV2ZW4gaWYgdGhlIGxpbmUgaXMgY2xvc2VkOyB0aGlzIGVuc3VyZXMgdGhhdCBhIGNsb3NlZFxuLy8gbGluZSBpcyBuZXZlciByb3RhdGVkLlxudmFyIGpvaW4gPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgY29vcmRpbmF0ZXMgPSB0b3BvbG9neS5jb29yZGluYXRlcyxcbiAgICAgIGxpbmVzID0gdG9wb2xvZ3kubGluZXMsXG4gICAgICByaW5ncyA9IHRvcG9sb2d5LnJpbmdzLFxuICAgICAgaW5kZXhlcyA9IGluZGV4KCksXG4gICAgICB2aXNpdGVkQnlJbmRleCA9IG5ldyBJbnQzMkFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCksXG4gICAgICBsZWZ0QnlJbmRleCA9IG5ldyBJbnQzMkFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCksXG4gICAgICByaWdodEJ5SW5kZXggPSBuZXcgSW50MzJBcnJheShjb29yZGluYXRlcy5sZW5ndGgpLFxuICAgICAganVuY3Rpb25CeUluZGV4ID0gbmV3IEludDhBcnJheShjb29yZGluYXRlcy5sZW5ndGgpLFxuICAgICAganVuY3Rpb25Db3VudCA9IDAsIC8vIHVwcGVyIGJvdW5kIG9uIG51bWJlciBvZiBqdW5jdGlvbnNcbiAgICAgIGksIG4sXG4gICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgY3VycmVudEluZGV4LFxuICAgICAgbmV4dEluZGV4O1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2aXNpdGVkQnlJbmRleFtpXSA9IGxlZnRCeUluZGV4W2ldID0gcmlnaHRCeUluZGV4W2ldID0gLTE7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXSxcbiAgICAgICAgbGluZVN0YXJ0ID0gbGluZVswXSxcbiAgICAgICAgbGluZUVuZCA9IGxpbmVbMV07XG4gICAgY3VycmVudEluZGV4ID0gaW5kZXhlc1tsaW5lU3RhcnRdO1xuICAgIG5leHRJbmRleCA9IGluZGV4ZXNbKytsaW5lU3RhcnRdO1xuICAgICsranVuY3Rpb25Db3VudCwganVuY3Rpb25CeUluZGV4W2N1cnJlbnRJbmRleF0gPSAxOyAvLyBzdGFydFxuICAgIHdoaWxlICgrK2xpbmVTdGFydCA8PSBsaW5lRW5kKSB7XG4gICAgICBzZXF1ZW5jZShpLCBwcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggPSBuZXh0SW5kZXgsIG5leHRJbmRleCA9IGluZGV4ZXNbbGluZVN0YXJ0XSk7XG4gICAgfVxuICAgICsranVuY3Rpb25Db3VudCwganVuY3Rpb25CeUluZGV4W25leHRJbmRleF0gPSAxOyAvLyBlbmRcbiAgfVxuXG4gIGZvciAoaSA9IDAsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2aXNpdGVkQnlJbmRleFtpXSA9IC0xO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbiA9IHJpbmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHZhciByaW5nID0gcmluZ3NbaV0sXG4gICAgICAgIHJpbmdTdGFydCA9IHJpbmdbMF0gKyAxLFxuICAgICAgICByaW5nRW5kID0gcmluZ1sxXTtcbiAgICBwcmV2aW91c0luZGV4ID0gaW5kZXhlc1tyaW5nRW5kIC0gMV07XG4gICAgY3VycmVudEluZGV4ID0gaW5kZXhlc1tyaW5nU3RhcnQgLSAxXTtcbiAgICBuZXh0SW5kZXggPSBpbmRleGVzW3JpbmdTdGFydF07XG4gICAgc2VxdWVuY2UoaSwgcHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4LCBuZXh0SW5kZXgpO1xuICAgIHdoaWxlICgrK3JpbmdTdGFydCA8PSByaW5nRW5kKSB7XG4gICAgICBzZXF1ZW5jZShpLCBwcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggPSBuZXh0SW5kZXgsIG5leHRJbmRleCA9IGluZGV4ZXNbcmluZ1N0YXJ0XSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VxdWVuY2UoaSwgcHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4LCBuZXh0SW5kZXgpIHtcbiAgICBpZiAodmlzaXRlZEJ5SW5kZXhbY3VycmVudEluZGV4XSA9PT0gaSkgcmV0dXJuOyAvLyBpZ25vcmUgc2VsZi1pbnRlcnNlY3Rpb25cbiAgICB2aXNpdGVkQnlJbmRleFtjdXJyZW50SW5kZXhdID0gaTtcbiAgICB2YXIgbGVmdEluZGV4ID0gbGVmdEJ5SW5kZXhbY3VycmVudEluZGV4XTtcbiAgICBpZiAobGVmdEluZGV4ID49IDApIHtcbiAgICAgIHZhciByaWdodEluZGV4ID0gcmlnaHRCeUluZGV4W2N1cnJlbnRJbmRleF07XG4gICAgICBpZiAoKGxlZnRJbmRleCAhPT0gcHJldmlvdXNJbmRleCB8fCByaWdodEluZGV4ICE9PSBuZXh0SW5kZXgpXG4gICAgICAgICYmIChsZWZ0SW5kZXggIT09IG5leHRJbmRleCB8fCByaWdodEluZGV4ICE9PSBwcmV2aW91c0luZGV4KSkge1xuICAgICAgICArK2p1bmN0aW9uQ291bnQsIGp1bmN0aW9uQnlJbmRleFtjdXJyZW50SW5kZXhdID0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdEJ5SW5kZXhbY3VycmVudEluZGV4XSA9IHByZXZpb3VzSW5kZXg7XG4gICAgICByaWdodEJ5SW5kZXhbY3VycmVudEluZGV4XSA9IG5leHRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleCgpIHtcbiAgICB2YXIgaW5kZXhCeVBvaW50ID0gaGFzaG1hcChjb29yZGluYXRlcy5sZW5ndGggKiAxLjQsIGhhc2hJbmRleCwgZXF1YWxJbmRleCwgSW50MzJBcnJheSwgLTEsIEludDMyQXJyYXkpLFxuICAgICAgICBpbmRleGVzID0gbmV3IEludDMyQXJyYXkoY29vcmRpbmF0ZXMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpbmRleGVzW2ldID0gaW5kZXhCeVBvaW50Lm1heWJlU2V0KGksIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEluZGV4KGkpIHtcbiAgICByZXR1cm4gaGFzaFBvaW50KGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFsSW5kZXgoaSwgaikge1xuICAgIHJldHVybiBlcXVhbFBvaW50KGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tqXSk7XG4gIH1cblxuICB2aXNpdGVkQnlJbmRleCA9IGxlZnRCeUluZGV4ID0gcmlnaHRCeUluZGV4ID0gbnVsbDtcblxuICB2YXIganVuY3Rpb25CeVBvaW50ID0gaGFzaHNldChqdW5jdGlvbkNvdW50ICogMS40LCBoYXNoUG9pbnQsIGVxdWFsUG9pbnQpLCBqO1xuXG4gIC8vIENvbnZlcnQgYmFjayB0byBhIHN0YW5kYXJkIGhhc2hzZXQgYnkgcG9pbnQgZm9yIGNhbGxlciBjb252ZW5pZW5jZS5cbiAgZm9yIChpID0gMCwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmIChqdW5jdGlvbkJ5SW5kZXhbaiA9IGluZGV4ZXNbaV1dKSB7XG4gICAgICBqdW5jdGlvbkJ5UG9pbnQuYWRkKGNvb3JkaW5hdGVzW2pdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ganVuY3Rpb25CeVBvaW50O1xufTtcblxuLy8gR2l2ZW4gYW4gZXh0cmFjdGVkIChwcmUtKXRvcG9sb2d5LCBjdXRzIChvciByb3RhdGVzKSBhcmNzIHNvIHRoYXQgYWxsIHNoYXJlZFxuLy8gcG9pbnQgc2VxdWVuY2VzIGFyZSBpZGVudGlmaWVkLiBUaGUgdG9wb2xvZ3kgY2FuIHRoZW4gYmUgc3Vic2VxdWVudGx5IGRlZHVwZWRcbi8vIHRvIHJlbW92ZSBleGFjdCBkdXBsaWNhdGUgYXJjcy5cbnZhciBjdXQgPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIganVuY3Rpb25zID0gam9pbih0b3BvbG9neSksXG4gICAgICBjb29yZGluYXRlcyA9IHRvcG9sb2d5LmNvb3JkaW5hdGVzLFxuICAgICAgbGluZXMgPSB0b3BvbG9neS5saW5lcyxcbiAgICAgIHJpbmdzID0gdG9wb2xvZ3kucmluZ3MsXG4gICAgICBuZXh0LFxuICAgICAgaSwgbjtcblxuICBmb3IgKGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXSxcbiAgICAgICAgbGluZU1pZCA9IGxpbmVbMF0sXG4gICAgICAgIGxpbmVFbmQgPSBsaW5lWzFdO1xuICAgIHdoaWxlICgrK2xpbmVNaWQgPCBsaW5lRW5kKSB7XG4gICAgICBpZiAoanVuY3Rpb25zLmhhcyhjb29yZGluYXRlc1tsaW5lTWlkXSkpIHtcbiAgICAgICAgbmV4dCA9IHswOiBsaW5lTWlkLCAxOiBsaW5lWzFdfTtcbiAgICAgICAgbGluZVsxXSA9IGxpbmVNaWQ7XG4gICAgICAgIGxpbmUgPSBsaW5lLm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDAsIG4gPSByaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2YXIgcmluZyA9IHJpbmdzW2ldLFxuICAgICAgICByaW5nU3RhcnQgPSByaW5nWzBdLFxuICAgICAgICByaW5nTWlkID0gcmluZ1N0YXJ0LFxuICAgICAgICByaW5nRW5kID0gcmluZ1sxXSxcbiAgICAgICAgcmluZ0ZpeGVkID0ganVuY3Rpb25zLmhhcyhjb29yZGluYXRlc1tyaW5nU3RhcnRdKTtcbiAgICB3aGlsZSAoKytyaW5nTWlkIDwgcmluZ0VuZCkge1xuICAgICAgaWYgKGp1bmN0aW9ucy5oYXMoY29vcmRpbmF0ZXNbcmluZ01pZF0pKSB7XG4gICAgICAgIGlmIChyaW5nRml4ZWQpIHtcbiAgICAgICAgICBuZXh0ID0gezA6IHJpbmdNaWQsIDE6IHJpbmdbMV19O1xuICAgICAgICAgIHJpbmdbMV0gPSByaW5nTWlkO1xuICAgICAgICAgIHJpbmcgPSByaW5nLm5leHQgPSBuZXh0O1xuICAgICAgICB9IGVsc2UgeyAvLyBGb3IgdGhlIGZpcnN0IGp1bmN0aW9uLCB3ZSBjYW4gcm90YXRlIHJhdGhlciB0aGFuIGN1dC5cbiAgICAgICAgICByb3RhdGVBcnJheShjb29yZGluYXRlcywgcmluZ1N0YXJ0LCByaW5nRW5kLCByaW5nRW5kIC0gcmluZ01pZCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbcmluZ0VuZF0gPSBjb29yZGluYXRlc1tyaW5nU3RhcnRdO1xuICAgICAgICAgIHJpbmdGaXhlZCA9IHRydWU7XG4gICAgICAgICAgcmluZ01pZCA9IHJpbmdTdGFydDsgLy8gcmVzdGFydDsgd2UgbWF5IGhhdmUgc2tpcHBlZCBqdW5jdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b3BvbG9neTtcbn07XG5cbmZ1bmN0aW9uIHJvdGF0ZUFycmF5KGFycmF5LCBzdGFydCwgZW5kLCBvZmZzZXQpIHtcbiAgcmV2ZXJzZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gIHJldmVyc2UoYXJyYXksIHN0YXJ0LCBzdGFydCArIG9mZnNldCk7XG4gIHJldmVyc2UoYXJyYXksIHN0YXJ0ICsgb2Zmc2V0LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIGZvciAodmFyIG1pZCA9IHN0YXJ0ICsgKChlbmQtLSAtIHN0YXJ0KSA+PiAxKSwgdDsgc3RhcnQgPCBtaWQ7ICsrc3RhcnQsIC0tZW5kKSB7XG4gICAgdCA9IGFycmF5W3N0YXJ0XSwgYXJyYXlbc3RhcnRdID0gYXJyYXlbZW5kXSwgYXJyYXlbZW5kXSA9IHQ7XG4gIH1cbn1cblxuLy8gR2l2ZW4gYSBjdXQgdG9wb2xvZ3ksIGNvbWJpbmVzIGR1cGxpY2F0ZSBhcmNzLlxudmFyIGRlZHVwID0gZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIGNvb3JkaW5hdGVzID0gdG9wb2xvZ3kuY29vcmRpbmF0ZXMsXG4gICAgICBsaW5lcyA9IHRvcG9sb2d5LmxpbmVzLCBsaW5lLFxuICAgICAgcmluZ3MgPSB0b3BvbG9neS5yaW5ncywgcmluZyxcbiAgICAgIGFyY0NvdW50ID0gbGluZXMubGVuZ3RoICsgcmluZ3MubGVuZ3RoLFxuICAgICAgaSwgbjtcblxuICBkZWxldGUgdG9wb2xvZ3kubGluZXM7XG4gIGRlbGV0ZSB0b3BvbG9neS5yaW5ncztcblxuICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIChub24tdW5pcXVlKSBhcmNzIHRvIGluaXRpYWxpemUgdGhlIGhhc2htYXAgc2FmZWx5LlxuICBmb3IgKGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldOyB3aGlsZSAobGluZSA9IGxpbmUubmV4dCkgKythcmNDb3VudDtcbiAgfVxuICBmb3IgKGkgPSAwLCBuID0gcmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgcmluZyA9IHJpbmdzW2ldOyB3aGlsZSAocmluZyA9IHJpbmcubmV4dCkgKythcmNDb3VudDtcbiAgfVxuXG4gIHZhciBhcmNzQnlFbmQgPSBoYXNobWFwKGFyY0NvdW50ICogMiAqIDEuNCwgaGFzaFBvaW50LCBlcXVhbFBvaW50KSxcbiAgICAgIGFyY3MgPSB0b3BvbG9neS5hcmNzID0gW107XG5cbiAgZm9yIChpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBkbyB7XG4gICAgICBkZWR1cExpbmUobGluZSk7XG4gICAgfSB3aGlsZSAobGluZSA9IGxpbmUubmV4dCk7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBuID0gcmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgcmluZyA9IHJpbmdzW2ldO1xuICAgIGlmIChyaW5nLm5leHQpIHsgLy8gYXJjIGlzIG5vIGxvbmdlciBjbG9zZWRcbiAgICAgIGRvIHtcbiAgICAgICAgZGVkdXBMaW5lKHJpbmcpO1xuICAgICAgfSB3aGlsZSAocmluZyA9IHJpbmcubmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZHVwUmluZyhyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWR1cExpbmUoYXJjKSB7XG4gICAgdmFyIHN0YXJ0UG9pbnQsXG4gICAgICAgIGVuZFBvaW50LFxuICAgICAgICBzdGFydEFyY3MsIHN0YXJ0QXJjLFxuICAgICAgICBlbmRBcmNzLCBlbmRBcmMsXG4gICAgICAgIGksIG47XG5cbiAgICAvLyBEb2VzIHRoaXMgYXJjIG1hdGNoIGFuIGV4aXN0aW5nIGFyYyBpbiBvcmRlcj9cbiAgICBpZiAoc3RhcnRBcmNzID0gYXJjc0J5RW5kLmdldChzdGFydFBvaW50ID0gY29vcmRpbmF0ZXNbYXJjWzBdXSkpIHtcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBzdGFydEFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN0YXJ0QXJjID0gc3RhcnRBcmNzW2ldO1xuICAgICAgICBpZiAoZXF1YWxMaW5lKHN0YXJ0QXJjLCBhcmMpKSB7XG4gICAgICAgICAgYXJjWzBdID0gc3RhcnRBcmNbMF07XG4gICAgICAgICAgYXJjWzFdID0gc3RhcnRBcmNbMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9lcyB0aGlzIGFyYyBtYXRjaCBhbiBleGlzdGluZyBhcmMgaW4gcmV2ZXJzZSBvcmRlcj9cbiAgICBpZiAoZW5kQXJjcyA9IGFyY3NCeUVuZC5nZXQoZW5kUG9pbnQgPSBjb29yZGluYXRlc1thcmNbMV1dKSkge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGVuZEFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGVuZEFyYyA9IGVuZEFyY3NbaV07XG4gICAgICAgIGlmIChyZXZlcnNlRXF1YWxMaW5lKGVuZEFyYywgYXJjKSkge1xuICAgICAgICAgIGFyY1sxXSA9IGVuZEFyY1swXTtcbiAgICAgICAgICBhcmNbMF0gPSBlbmRBcmNbMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0QXJjcykgc3RhcnRBcmNzLnB1c2goYXJjKTsgZWxzZSBhcmNzQnlFbmQuc2V0KHN0YXJ0UG9pbnQsIFthcmNdKTtcbiAgICBpZiAoZW5kQXJjcykgZW5kQXJjcy5wdXNoKGFyYyk7IGVsc2UgYXJjc0J5RW5kLnNldChlbmRQb2ludCwgW2FyY10pO1xuICAgIGFyY3MucHVzaChhcmMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVkdXBSaW5nKGFyYykge1xuICAgIHZhciBlbmRQb2ludCxcbiAgICAgICAgZW5kQXJjcyxcbiAgICAgICAgZW5kQXJjLFxuICAgICAgICBpLCBuO1xuXG4gICAgLy8gRG9lcyB0aGlzIGFyYyBtYXRjaCBhbiBleGlzdGluZyBsaW5lIGluIG9yZGVyLCBvciByZXZlcnNlIG9yZGVyP1xuICAgIC8vIFJpbmdzIGFyZSBjbG9zZWQsIHNvIHRoZWlyIHN0YXJ0IHBvaW50IGFuZCBlbmQgcG9pbnQgaXMgdGhlIHNhbWUuXG4gICAgaWYgKGVuZEFyY3MgPSBhcmNzQnlFbmQuZ2V0KGVuZFBvaW50ID0gY29vcmRpbmF0ZXNbYXJjWzBdXSkpIHtcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlbmRBcmNzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBlbmRBcmMgPSBlbmRBcmNzW2ldO1xuICAgICAgICBpZiAoZXF1YWxSaW5nKGVuZEFyYywgYXJjKSkge1xuICAgICAgICAgIGFyY1swXSA9IGVuZEFyY1swXTtcbiAgICAgICAgICBhcmNbMV0gPSBlbmRBcmNbMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXZlcnNlRXF1YWxSaW5nKGVuZEFyYywgYXJjKSkge1xuICAgICAgICAgIGFyY1swXSA9IGVuZEFyY1sxXTtcbiAgICAgICAgICBhcmNbMV0gPSBlbmRBcmNbMF07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkb2VzIHRoaXMgYXJjIG1hdGNoIGFuIGV4aXN0aW5nIHJpbmcgaW4gb3JkZXIsIG9yIHJldmVyc2Ugb3JkZXI/XG4gICAgaWYgKGVuZEFyY3MgPSBhcmNzQnlFbmQuZ2V0KGVuZFBvaW50ID0gY29vcmRpbmF0ZXNbYXJjWzBdICsgZmluZE1pbmltdW1PZmZzZXQoYXJjKV0pKSB7XG4gICAgICBmb3IgKGkgPSAwLCBuID0gZW5kQXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZW5kQXJjID0gZW5kQXJjc1tpXTtcbiAgICAgICAgaWYgKGVxdWFsUmluZyhlbmRBcmMsIGFyYykpIHtcbiAgICAgICAgICBhcmNbMF0gPSBlbmRBcmNbMF07XG4gICAgICAgICAgYXJjWzFdID0gZW5kQXJjWzFdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2ZXJzZUVxdWFsUmluZyhlbmRBcmMsIGFyYykpIHtcbiAgICAgICAgICBhcmNbMF0gPSBlbmRBcmNbMV07XG4gICAgICAgICAgYXJjWzFdID0gZW5kQXJjWzBdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmRBcmNzKSBlbmRBcmNzLnB1c2goYXJjKTsgZWxzZSBhcmNzQnlFbmQuc2V0KGVuZFBvaW50LCBbYXJjXSk7XG4gICAgYXJjcy5wdXNoKGFyYyk7XG4gIH1cblxuICBmdW5jdGlvbiBlcXVhbExpbmUoYXJjQSwgYXJjQikge1xuICAgIHZhciBpYSA9IGFyY0FbMF0sIGliID0gYXJjQlswXSxcbiAgICAgICAgamEgPSBhcmNBWzFdLCBqYiA9IGFyY0JbMV07XG4gICAgaWYgKGlhIC0gamEgIT09IGliIC0gamIpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKDsgaWEgPD0gamE7ICsraWEsICsraWIpIGlmICghZXF1YWxQb2ludChjb29yZGluYXRlc1tpYV0sIGNvb3JkaW5hdGVzW2liXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VFcXVhbExpbmUoYXJjQSwgYXJjQikge1xuICAgIHZhciBpYSA9IGFyY0FbMF0sIGliID0gYXJjQlswXSxcbiAgICAgICAgamEgPSBhcmNBWzFdLCBqYiA9IGFyY0JbMV07XG4gICAgaWYgKGlhIC0gamEgIT09IGliIC0gamIpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKDsgaWEgPD0gamE7ICsraWEsIC0tamIpIGlmICghZXF1YWxQb2ludChjb29yZGluYXRlc1tpYV0sIGNvb3JkaW5hdGVzW2piXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFsUmluZyhhcmNBLCBhcmNCKSB7XG4gICAgdmFyIGlhID0gYXJjQVswXSwgaWIgPSBhcmNCWzBdLFxuICAgICAgICBqYSA9IGFyY0FbMV0sIGpiID0gYXJjQlsxXSxcbiAgICAgICAgbiA9IGphIC0gaWE7XG4gICAgaWYgKG4gIT09IGpiIC0gaWIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIga2EgPSBmaW5kTWluaW11bU9mZnNldChhcmNBKSxcbiAgICAgICAga2IgPSBmaW5kTWluaW11bU9mZnNldChhcmNCKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCFlcXVhbFBvaW50KGNvb3JkaW5hdGVzW2lhICsgKGkgKyBrYSkgJSBuXSwgY29vcmRpbmF0ZXNbaWIgKyAoaSArIGtiKSAlIG5dKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VFcXVhbFJpbmcoYXJjQSwgYXJjQikge1xuICAgIHZhciBpYSA9IGFyY0FbMF0sIGliID0gYXJjQlswXSxcbiAgICAgICAgamEgPSBhcmNBWzFdLCBqYiA9IGFyY0JbMV0sXG4gICAgICAgIG4gPSBqYSAtIGlhO1xuICAgIGlmIChuICE9PSBqYiAtIGliKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGthID0gZmluZE1pbmltdW1PZmZzZXQoYXJjQSksXG4gICAgICAgIGtiID0gbiAtIGZpbmRNaW5pbXVtT2Zmc2V0KGFyY0IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoIWVxdWFsUG9pbnQoY29vcmRpbmF0ZXNbaWEgKyAoaSArIGthKSAlIG5dLCBjb29yZGluYXRlc1tqYiAtIChpICsga2IpICUgbl0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gUmluZ3MgYXJlIHJvdGF0ZWQgdG8gYSBjb25zaXN0ZW50LCBidXQgYXJiaXRyYXJ5LCBzdGFydCBwb2ludC5cbiAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gZGV0ZWN0IHdoZW4gYSByaW5nIGFuZCBhIHJvdGF0ZWQgY29weSBhcmUgZHVwZXMuXG4gIGZ1bmN0aW9uIGZpbmRNaW5pbXVtT2Zmc2V0KGFyYykge1xuICAgIHZhciBzdGFydCA9IGFyY1swXSxcbiAgICAgICAgZW5kID0gYXJjWzFdLFxuICAgICAgICBtaWQgPSBzdGFydCxcbiAgICAgICAgbWluaW11bSA9IG1pZCxcbiAgICAgICAgbWluaW11bVBvaW50ID0gY29vcmRpbmF0ZXNbbWlkXTtcbiAgICB3aGlsZSAoKyttaWQgPCBlbmQpIHtcbiAgICAgIHZhciBwb2ludCA9IGNvb3JkaW5hdGVzW21pZF07XG4gICAgICBpZiAocG9pbnRbMF0gPCBtaW5pbXVtUG9pbnRbMF0gfHwgcG9pbnRbMF0gPT09IG1pbmltdW1Qb2ludFswXSAmJiBwb2ludFsxXSA8IG1pbmltdW1Qb2ludFsxXSkge1xuICAgICAgICBtaW5pbXVtID0gbWlkO1xuICAgICAgICBtaW5pbXVtUG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmltdW0gLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0b3BvbG9neTtcbn07XG5cbi8vIEdpdmVuIGEgVG9wb0pTT04gdG9wb2xvZ3kgaW4gYWJzb2x1dGUgKHF1YW50aXplZCkgY29vcmRpbmF0ZXMsXG4vLyBjb252ZXJ0cyB0byBmaXhlZC1wb2ludCBkZWx0YSBlbmNvZGluZy5cbi8vIFRoaXMgaXMgYSBkZXN0cnVjdGl2ZSBvcGVyYXRpb24gdGhhdCBtb2RpZmllcyB0aGUgZ2l2ZW4gdG9wb2xvZ3khXG52YXIgZGVsdGEgPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgYXJjcyA9IHRvcG9sb2d5LmFyY3MsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gYXJjcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICB2YXIgYXJjID0gYXJjc1tpXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIG0gPSBhcmMubGVuZ3RoLFxuICAgICAgICBwb2ludCA9IGFyY1swXSxcbiAgICAgICAgeDAgPSBwb2ludFswXSxcbiAgICAgICAgeTAgPSBwb2ludFsxXSxcbiAgICAgICAgeDEsXG4gICAgICAgIHkxO1xuICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICBwb2ludCA9IGFyY1tqXTtcbiAgICAgIHgxID0gcG9pbnRbMF07XG4gICAgICB5MSA9IHBvaW50WzFdO1xuICAgICAgYXJjW2pdID0gW3gxIC0geDAsIHkxIC0geTBdO1xuICAgICAgeDAgPSB4MTtcbiAgICAgIHkwID0geTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvcG9sb2d5O1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIGxpbmVzIGFuZCByaW5ncyBmcm9tIHRoZSBzcGVjaWZpZWQgaGFzaCBvZiBnZW9tZXRyeSBvYmplY3RzLlxuLy9cbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhyZWUgcHJvcGVydGllczpcbi8vXG4vLyAqIGNvb3JkaW5hdGVzIC0gc2hhcmVkIGJ1ZmZlciBvZiBbeCwgeV0gY29vcmRpbmF0ZXNcbi8vICogbGluZXMgLSBsaW5lcyBleHRyYWN0ZWQgZnJvbSB0aGUgaGFzaCwgb2YgdGhlIGZvcm0gW3N0YXJ0LCBlbmRdXG4vLyAqIHJpbmdzIC0gcmluZ3MgZXh0cmFjdGVkIGZyb20gdGhlIGhhc2gsIG9mIHRoZSBmb3JtIFtzdGFydCwgZW5kXVxuLy9cbi8vIEZvciBlYWNoIHJpbmcgb3IgbGluZSwgc3RhcnQgYW5kIGVuZCByZXByZXNlbnQgaW5jbHVzaXZlIGluZGV4ZXMgaW50byB0aGVcbi8vIGNvb3JkaW5hdGVzIGJ1ZmZlci4gRm9yIHJpbmdzIChhbmQgY2xvc2VkIGxpbmVzKSwgY29vcmRpbmF0ZXNbc3RhcnRdIGVxdWFsc1xuLy8gY29vcmRpbmF0ZXNbZW5kXS5cbi8vXG4vLyBGb3IgZWFjaCBsaW5lIG9yIHBvbHlnb24gZ2VvbWV0cnkgaW4gdGhlIGlucHV0IGhhc2gsIGluY2x1ZGluZyBuZXN0ZWRcbi8vIGdlb21ldHJpZXMgYXMgaW4gZ2VvbWV0cnkgY29sbGVjdGlvbnMsIHRoZSBgY29vcmRpbmF0ZXNgIGFycmF5IGlzIHJlcGxhY2VkXG4vLyB3aXRoIGFuIGVxdWl2YWxlbnQgYGFyY3NgIGFycmF5IHRoYXQsIGZvciBlYWNoIGxpbmUgKGZvciBsaW5lIHN0cmluZ1xuLy8gZ2VvbWV0cmllcykgb3IgcmluZyAoZm9yIHBvbHlnb24gZ2VvbWV0cmllcyksIHBvaW50cyB0byBvbmUgb2YgdGhlIGFib3ZlXG4vLyBsaW5lcyBvciByaW5ncy5cbnZhciBleHRyYWN0ID0gZnVuY3Rpb24ob2JqZWN0cykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxpbmVzID0gW10sXG4gICAgICByaW5ncyA9IFtdLFxuICAgICAgY29vcmRpbmF0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBleHRyYWN0R2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICBpZiAoZ2VvbWV0cnkgJiYgZXh0cmFjdEdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkgZXh0cmFjdEdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSk7XG4gIH1cblxuICB2YXIgZXh0cmFjdEdlb21ldHJ5VHlwZSA9IHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG8pIHsgby5nZW9tZXRyaWVzLmZvckVhY2goZXh0cmFjdEdlb21ldHJ5KTsgfSxcbiAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IG8uYXJjcyA9IGV4dHJhY3RMaW5lKG8uY29vcmRpbmF0ZXMpOyBkZWxldGUgby5jb29yZGluYXRlczsgfSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG8pIHsgby5hcmNzID0gby5jb29yZGluYXRlcy5tYXAoZXh0cmFjdExpbmUpOyBkZWxldGUgby5jb29yZGluYXRlczsgfSxcbiAgICBQb2x5Z29uOiBmdW5jdGlvbihvKSB7IG8uYXJjcyA9IG8uY29vcmRpbmF0ZXMubWFwKGV4dHJhY3RSaW5nKTsgZGVsZXRlIG8uY29vcmRpbmF0ZXM7IH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IG8uYXJjcyA9IG8uY29vcmRpbmF0ZXMubWFwKGV4dHJhY3RNdWx0aVJpbmcpOyBkZWxldGUgby5jb29yZGluYXRlczsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lKGxpbmUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmUubGVuZ3RoOyBpIDwgbjsgKytpKSBjb29yZGluYXRlc1srK2luZGV4XSA9IGxpbmVbaV07XG4gICAgdmFyIGFyYyA9IHswOiBpbmRleCAtIG4gKyAxLCAxOiBpbmRleH07XG4gICAgbGluZXMucHVzaChhcmMpO1xuICAgIHJldHVybiBhcmM7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0UmluZyhyaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aDsgaSA8IG47ICsraSkgY29vcmRpbmF0ZXNbKytpbmRleF0gPSByaW5nW2ldO1xuICAgIHZhciBhcmMgPSB7MDogaW5kZXggLSBuICsgMSwgMTogaW5kZXh9O1xuICAgIHJpbmdzLnB1c2goYXJjKTtcbiAgICByZXR1cm4gYXJjO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdE11bHRpUmluZyhyaW5ncykge1xuICAgIHJldHVybiByaW5ncy5tYXAoZXh0cmFjdFJpbmcpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdHMpIHtcbiAgICBleHRyYWN0R2VvbWV0cnkob2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BvbG9neVwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyxcbiAgICBsaW5lczogbGluZXMsXG4gICAgcmluZ3M6IHJpbmdzLFxuICAgIG9iamVjdHM6IG9iamVjdHNcbiAgfTtcbn07XG5cbi8vIEdpdmVuIGEgaGFzaCBvZiBHZW9KU09OIG9iamVjdHMsIHJlcGxhY2VzIEZlYXR1cmVzIHdpdGggZ2VvbWV0cnkgb2JqZWN0cy5cbi8vIFRoaXMgaXMgYSBkZXN0cnVjdGl2ZSBvcGVyYXRpb24gdGhhdCBtb2RpZmllcyB0aGUgaW5wdXQgb2JqZWN0cyFcbnZhciBnZW9tZXRyeSA9IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb2JqZWN0cykgb2JqZWN0c1trZXldID0gZ2VvbWlmeU9iamVjdChvYmplY3RzW2tleV0pO1xuICByZXR1cm4gb2JqZWN0cztcbn07XG5cbmZ1bmN0aW9uIGdlb21pZnlPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAob2JqZWN0ICYmIGdlb21pZnlPYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKVxuICAgICAgPyBnZW9taWZ5T2JqZWN0VHlwZVtvYmplY3QudHlwZV1cbiAgICAgIDogZ2VvbWlmeUdlb21ldHJ5KShvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBnZW9taWZ5RmVhdHVyZShmZWF0dXJlKSB7XG4gIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gIGlmIChnZW9tZXRyeSA9PSBudWxsKSB7XG4gICAgZmVhdHVyZS50eXBlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBnZW9taWZ5R2VvbWV0cnkoZ2VvbWV0cnkpO1xuICAgIGZlYXR1cmUudHlwZSA9IGdlb21ldHJ5LnR5cGU7XG4gICAgaWYgKGdlb21ldHJ5Lmdlb21ldHJpZXMpIGZlYXR1cmUuZ2VvbWV0cmllcyA9IGdlb21ldHJ5Lmdlb21ldHJpZXM7XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpIGZlYXR1cmUuY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBpZiAoZ2VvbWV0cnkuYmJveCkgZmVhdHVyZS5iYm94ID0gZ2VvbWV0cnkuYmJveDtcbiAgfVxuICBkZWxldGUgZmVhdHVyZS5nZW9tZXRyeTtcbiAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmZ1bmN0aW9uIGdlb21pZnlHZW9tZXRyeShnZW9tZXRyeSkge1xuICBpZiAoIWdlb21ldHJ5KSByZXR1cm4ge3R5cGU6IG51bGx9O1xuICBpZiAoZ2VvbWlmeUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkgZ2VvbWlmeUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSk7XG4gIHJldHVybiBnZW9tZXRyeTtcbn1cblxudmFyIGdlb21pZnlPYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBnZW9taWZ5RmVhdHVyZSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uLnR5cGUgPSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiO1xuICAgIGNvbGxlY3Rpb24uZ2VvbWV0cmllcyA9IGNvbGxlY3Rpb24uZmVhdHVyZXM7XG4gICAgY29sbGVjdGlvbi5mZWF0dXJlcy5mb3JFYWNoKGdlb21pZnlGZWF0dXJlKTtcbiAgICBkZWxldGUgY29sbGVjdGlvbi5mZWF0dXJlcztcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxufTtcblxudmFyIGdlb21pZnlHZW9tZXRyeVR5cGUgPSB7XG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24obykge1xuICAgIHZhciBnZW9tZXRyaWVzID0gby5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgZ2VvbWV0cmllc1tpXSA9IGdlb21pZnlHZW9tZXRyeShnZW9tZXRyaWVzW2ldKTtcbiAgfSxcbiAgTXVsdGlQb2ludDogZnVuY3Rpb24obykge1xuICAgIGlmICghby5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgIG8udHlwZSA9IG51bGw7XG4gICAgICBkZWxldGUgby5jb29yZGluYXRlcztcbiAgICB9IGVsc2UgaWYgKG8uY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgby50eXBlID0gXCJQb2ludFwiO1xuICAgICAgby5jb29yZGluYXRlcyA9IG8uY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFvLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgby50eXBlID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBvLmNvb3JkaW5hdGVzO1xuICAgIH1cbiAgfSxcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7XG4gICAgZm9yICh2YXIgbGluZXMgPSBvLmNvb3JkaW5hdGVzLCBpID0gMCwgTiA9IDAsIG4gPSBsaW5lcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICBpZiAobGluZS5sZW5ndGgpIGxpbmVzW04rK10gPSBsaW5lO1xuICAgIH1cbiAgICBpZiAoIU4pIHtcbiAgICAgIG8udHlwZSA9IG51bGw7XG4gICAgICBkZWxldGUgby5jb29yZGluYXRlcztcbiAgICB9IGVsc2UgaWYgKE4gPCAyKSB7XG4gICAgICBvLnR5cGUgPSBcIkxpbmVTdHJpbmdcIjtcbiAgICAgIG8uY29vcmRpbmF0ZXMgPSBsaW5lc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgby5jb29yZGluYXRlcy5sZW5ndGggPSBOO1xuICAgIH1cbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24obykge1xuICAgIGZvciAodmFyIHJpbmdzID0gby5jb29yZGluYXRlcywgaSA9IDAsIE4gPSAwLCBuID0gcmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgaWYgKHJpbmcubGVuZ3RoKSByaW5nc1tOKytdID0gcmluZztcbiAgICB9XG4gICAgaWYgKCFOKSB7XG4gICAgICBvLnR5cGUgPSBudWxsO1xuICAgICAgZGVsZXRlIG8uY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG8uY29vcmRpbmF0ZXMubGVuZ3RoID0gTjtcbiAgICB9XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24obykge1xuICAgIGZvciAodmFyIHBvbHlnb25zID0gby5jb29yZGluYXRlcywgaiA9IDAsIE0gPSAwLCBtID0gcG9seWdvbnMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciByaW5ncyA9IHBvbHlnb25zW2pdLCBpID0gMCwgTiA9IDAsIG4gPSByaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoKSByaW5nc1tOKytdID0gcmluZztcbiAgICAgIH1cbiAgICAgIGlmIChOKSB7XG4gICAgICAgIHJpbmdzLmxlbmd0aCA9IE47XG4gICAgICAgIHBvbHlnb25zW00rK10gPSByaW5ncztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFNKSB7XG4gICAgICBvLnR5cGUgPSBudWxsO1xuICAgICAgZGVsZXRlIG8uY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIGlmIChNIDwgMikge1xuICAgICAgby50eXBlID0gXCJQb2x5Z29uXCI7XG4gICAgICBvLmNvb3JkaW5hdGVzID0gcG9seWdvbnNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvbHlnb25zLmxlbmd0aCA9IE07XG4gICAgfVxuICB9XG59O1xuXG52YXIgcHJlcXVhbnRpemUgPSBmdW5jdGlvbihvYmplY3RzLCBiYm94LCBuKSB7XG4gIHZhciB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM10sXG4gICAgICBreCA9IHgxIC0geDAgPyAobiAtIDEpIC8gKHgxIC0geDApIDogMSxcbiAgICAgIGt5ID0geTEgLSB5MCA/IChuIC0gMSkgLyAoeTEgLSB5MCkgOiAxO1xuXG4gIGZ1bmN0aW9uIHF1YW50aXplUG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlc1swXSA9IE1hdGgucm91bmQoKGNvb3JkaW5hdGVzWzBdIC0geDApICoga3gpO1xuICAgIGNvb3JkaW5hdGVzWzFdID0gTWF0aC5yb3VuZCgoY29vcmRpbmF0ZXNbMV0gLSB5MCkgKiBreSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVMaW5lKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMSxcbiAgICAgICAgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgcGkgPSBxdWFudGl6ZVBvaW50KGNvb3JkaW5hdGVzWzBdKSxcbiAgICAgICAgcGosXG4gICAgICAgIHB4ID0gcGlbMF0sXG4gICAgICAgIHB5ID0gcGlbMV0sXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcGkgPSBxdWFudGl6ZVBvaW50KGNvb3JkaW5hdGVzW2ldKTtcbiAgICAgIHggPSBwaVswXTtcbiAgICAgIHkgPSBwaVsxXTtcbiAgICAgIGlmICh4ICE9PSBweCB8fCB5ICE9PSBweSkgeyAvLyBza2lwIGNvaW5jaWRlbnQgcG9pbnRzXG4gICAgICAgIHBqID0gY29vcmRpbmF0ZXNbaisrXTtcbiAgICAgICAgcGpbMF0gPSBweCA9IHg7XG4gICAgICAgIHBqWzFdID0gcHkgPSB5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvb3JkaW5hdGVzLmxlbmd0aCA9IGo7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KG8pIHtcbiAgICBpZiAobyAmJiBxdWFudGl6ZUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShvLnR5cGUpKSBxdWFudGl6ZUdlb21ldHJ5VHlwZVtvLnR5cGVdKG8pO1xuICB9XG5cbiAgdmFyIHF1YW50aXplR2VvbWV0cnlUeXBlID0ge1xuICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24obykge1xuICAgICAgby5nZW9tZXRyaWVzLmZvckVhY2gocXVhbnRpemVHZW9tZXRyeSk7XG4gICAgfSxcbiAgICBQb2ludDogZnVuY3Rpb24obykge1xuICAgICAgcXVhbnRpemVQb2ludChvLmNvb3JkaW5hdGVzKTtcbiAgICB9LFxuICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIG8uY29vcmRpbmF0ZXMuZm9yRWFjaChxdWFudGl6ZVBvaW50KTtcbiAgICB9LFxuICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBsaW5lID0gby5jb29yZGluYXRlcztcbiAgICAgIHF1YW50aXplTGluZShsaW5lKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8IDIpIGxpbmVbMV0gPSBsaW5lWzBdOyAvLyBtdXN0IGhhdmUgMitcbiAgICB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24obykge1xuICAgICAgZm9yICh2YXIgbGluZXMgPSBvLmNvb3JkaW5hdGVzLCBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBxdWFudGl6ZUxpbmUobGluZSk7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IDIpIGxpbmVbMV0gPSBsaW5lWzBdOyAvLyBtdXN0IGhhdmUgMitcbiAgICAgIH1cbiAgICB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG8pIHtcbiAgICAgIGZvciAodmFyIHJpbmdzID0gby5jb29yZGluYXRlcywgaSA9IDAsIG4gPSByaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgcXVhbnRpemVMaW5lKHJpbmcpO1xuICAgICAgICB3aGlsZSAocmluZy5sZW5ndGggPCA0KSByaW5nLnB1c2gocmluZ1swXSk7IC8vIG11c3QgaGF2ZSA0K1xuICAgICAgfVxuICAgIH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7XG4gICAgICBmb3IgKHZhciBwb2x5Z29ucyA9IG8uY29vcmRpbmF0ZXMsIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmdzID0gcG9seWdvbnNbaV0sIGogPSAwLCBtID0gcmluZ3MubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tqXTtcbiAgICAgICAgICBxdWFudGl6ZUxpbmUocmluZyk7XG4gICAgICAgICAgd2hpbGUgKHJpbmcubGVuZ3RoIDwgNCkgcmluZy5wdXNoKHJpbmdbMF0pOyAvLyBtdXN0IGhhdmUgNCtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0cykge1xuICAgIHF1YW50aXplR2VvbWV0cnkob2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2NhbGU6IFsxIC8ga3gsIDEgLyBreV0sXG4gICAgdHJhbnNsYXRlOiBbeDAsIHkwXVxuICB9O1xufTtcblxuLy8gQ29uc3RydWN0cyB0aGUgVG9wb0pTT04gVG9wb2xvZ3kgZm9yIHRoZSBzcGVjaWZpZWQgaGFzaCBvZiBmZWF0dXJlcy5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzcGVjaWZpZWQgaGFzaCBtdXN0IGJlIGEgR2VvSlNPTiBvYmplY3QsXG4vLyBtZWFuaW5nIEZlYXR1cmVDb2xsZWN0aW9uLCBhIEZlYXR1cmUgb3IgYSBnZW9tZXRyeSBvYmplY3QuXG52YXIgdG9wb2xvZ3kgPSBmdW5jdGlvbihvYmplY3RzLCBxdWFudGl6YXRpb24pIHtcbiAgdmFyIGJib3ggPSBib3VuZHMoZ2VvbWV0cnkob2JqZWN0cykpLFxuICAgICAgdHJhbnNmb3JtID0gcXVhbnRpemF0aW9uID4gMCAmJiBiYm94ICYmIHByZXF1YW50aXplKG9iamVjdHMsIGJib3gsIHF1YW50aXphdGlvbiksXG4gICAgICB0b3BvbG9neSA9IGRlZHVwKGN1dChleHRyYWN0KG9iamVjdHMpKSksXG4gICAgICBjb29yZGluYXRlcyA9IHRvcG9sb2d5LmNvb3JkaW5hdGVzLFxuICAgICAgaW5kZXhCeUFyYyA9IGhhc2htYXAodG9wb2xvZ3kuYXJjcy5sZW5ndGggKiAxLjQsIGhhc2hBcmMsIGVxdWFsQXJjKTtcblxuICBvYmplY3RzID0gdG9wb2xvZ3kub2JqZWN0czsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICB0b3BvbG9neS5iYm94ID0gYmJveDtcbiAgdG9wb2xvZ3kuYXJjcyA9IHRvcG9sb2d5LmFyY3MubWFwKGZ1bmN0aW9uKGFyYywgaSkge1xuICAgIGluZGV4QnlBcmMuc2V0KGFyYywgaSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzLnNsaWNlKGFyY1swXSwgYXJjWzFdICsgMSk7XG4gIH0pO1xuXG4gIGRlbGV0ZSB0b3BvbG9neS5jb29yZGluYXRlcztcbiAgY29vcmRpbmF0ZXMgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGluZGV4R2VvbWV0cnkoZ2VvbWV0cnkkJDEpIHtcbiAgICBpZiAoZ2VvbWV0cnkkJDEgJiYgaW5kZXhHZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkkJDEudHlwZSkpIGluZGV4R2VvbWV0cnlUeXBlW2dlb21ldHJ5JCQxLnR5cGVdKGdlb21ldHJ5JCQxKTtcbiAgfVxuXG4gIHZhciBpbmRleEdlb21ldHJ5VHlwZSA9IHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG8pIHsgby5nZW9tZXRyaWVzLmZvckVhY2goaW5kZXhHZW9tZXRyeSk7IH0sXG4gICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyBvLmFyY3MgPSBpbmRleEFyY3Moby5hcmNzKTsgfSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG8pIHsgby5hcmNzID0gby5hcmNzLm1hcChpbmRleEFyY3MpOyB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG8pIHsgby5hcmNzID0gby5hcmNzLm1hcChpbmRleEFyY3MpOyB9LFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24obykgeyBvLmFyY3MgPSBvLmFyY3MubWFwKGluZGV4TXVsdGlBcmNzKTsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGluZGV4QXJjcyhhcmMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4QnlBcmMuZ2V0KGFyYyk7XG4gICAgICBpbmRleGVzLnB1c2goYXJjWzBdIDwgYXJjWzFdID8gaW5kZXggOiB+aW5kZXgpO1xuICAgIH0gd2hpbGUgKGFyYyA9IGFyYy5uZXh0KTtcbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4TXVsdGlBcmNzKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAoaW5kZXhBcmNzKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3RzKSB7XG4gICAgaW5kZXhHZW9tZXRyeShvYmplY3RzW2tleV0pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHRvcG9sb2d5LnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBkZWx0YSh0b3BvbG9neSk7XG4gIH1cblxuICByZXR1cm4gdG9wb2xvZ3k7XG59O1xuXG5mdW5jdGlvbiBoYXNoQXJjKGFyYykge1xuICB2YXIgaSA9IGFyY1swXSwgaiA9IGFyY1sxXSwgdDtcbiAgaWYgKGogPCBpKSB0ID0gaSwgaSA9IGosIGogPSB0O1xuICByZXR1cm4gaSArIDMxICogajtcbn1cblxuZnVuY3Rpb24gZXF1YWxBcmMoYXJjQSwgYXJjQikge1xuICB2YXIgaWEgPSBhcmNBWzBdLCBqYSA9IGFyY0FbMV0sXG4gICAgICBpYiA9IGFyY0JbMF0sIGpiID0gYXJjQlsxXSwgdDtcbiAgaWYgKGphIDwgaWEpIHQgPSBpYSwgaWEgPSBqYSwgamEgPSB0O1xuICBpZiAoamIgPCBpYikgdCA9IGliLCBpYiA9IGpiLCBqYiA9IHQ7XG4gIHJldHVybiBpYSA9PT0gaWIgJiYgamEgPT09IGpiO1xufVxuXG52YXIgcHJ1bmUgPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgb2xkQXJjcyA9IHRvcG9sb2d5LmFyY3MsXG4gICAgICBuZXdBcmNzID0gdG9wb2xvZ3kuYXJjcyA9IFtdLFxuICAgICAgbmV3QXJjSW5kZXggPSAtMSxcbiAgICAgIG5ld0luZGV4QnlPbGRJbmRleCA9IG5ldyBBcnJheShvbGRBcmNzLmxlbmd0aCksXG4gICAgICBuYW1lO1xuXG4gIGZ1bmN0aW9uIHBydW5lR2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKHBydW5lR2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IHBydW5lQXJjcyhvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogby5hcmNzLmZvckVhY2gocHJ1bmVBcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9seWdvblwiOiBvLmFyY3MuZm9yRWFjaChwcnVuZUFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2gocHJ1bmVNdWx0aUFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUFyY3MoYXJjcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGFyY3NbaV0sXG4gICAgICAgICAgb2xkUmV2ZXJzZSA9IG9sZEluZGV4IDwgMCAmJiAob2xkSW5kZXggPSB+b2xkSW5kZXgsIHRydWUpLFxuICAgICAgICAgIG5ld0luZGV4O1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGlzIGFyYyxcbiAgICAgIC8vIHJlY29yZCBpdCB1bmRlciBpdHMgbmV3IGluZGV4LlxuICAgICAgaWYgKChuZXdJbmRleCA9IG5ld0luZGV4QnlPbGRJbmRleFtvbGRJbmRleF0pID09IG51bGwpIHtcbiAgICAgICAgbmV3SW5kZXhCeU9sZEluZGV4W29sZEluZGV4XSA9IG5ld0luZGV4ID0gKytuZXdBcmNJbmRleDtcbiAgICAgICAgbmV3QXJjc1tuZXdJbmRleF0gPSBvbGRBcmNzW29sZEluZGV4XTtcbiAgICAgIH1cblxuICAgICAgYXJjc1tpXSA9IG9sZFJldmVyc2UgPyB+bmV3SW5kZXggOiBuZXdJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZU11bHRpQXJjcyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKHBydW5lQXJjcyk7XG4gIH1cblxuICBmb3IgKG5hbWUgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIHBydW5lR2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1tuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gdG9wb2xvZ3k7XG59O1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24odG9wb2xvZ3ksIGZpbHRlcikge1xuICB2YXIgbmFtZTtcblxuICBpZiAoZmlsdGVyID09IG51bGwpIGZpbHRlciA9IGZpbHRlclRydWU7XG5cbiAgZnVuY3Rpb24gZmlsdGVyR2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiUG9seWdvblwiOiB7XG4gICAgICAgIG8uYXJjcyA9IGZpbHRlclJpbmdzKG8uYXJjcyk7XG4gICAgICAgIGlmICghby5hcmNzKSBvLnR5cGUgPSBudWxsLCBkZWxldGUgby5hcmNzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjoge1xuICAgICAgICBvLmFyY3MgPSBvLmFyY3MubWFwKGZpbHRlclJpbmdzKS5maWx0ZXIoZmlsdGVySWRlbnRpdHkpO1xuICAgICAgICBpZiAoIW8uYXJjcy5sZW5ndGgpIG8udHlwZSA9IG51bGwsIGRlbGV0ZSBvLmFyY3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiB7XG4gICAgICAgIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZpbHRlckdlb21ldHJ5KTtcbiAgICAgICAgby5nZW9tZXRyaWVzID0gby5nZW9tZXRyaWVzLmZpbHRlcihmaWx0ZXJOb3ROdWxsKTtcbiAgICAgICAgaWYgKCFvLmdlb21ldHJpZXMubGVuZ3RoKSBvLnR5cGUgPSBudWxsLCBkZWxldGUgby5nZW9tZXRyaWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJSaW5ncyhhcmNzKSB7XG4gICAgcmV0dXJuIGFyY3MubGVuZ3RoICYmIGZpbHRlckV4dGVyaW9yUmluZyhhcmNzWzBdKSAvLyBpZiB0aGUgZXh0ZXJpb3IgaXMgc21hbGwsIGlnbm9yZSBhbnkgaG9sZXNcbiAgICAgICAgPyBbYXJjcy5zaGlmdCgpXS5jb25jYXQoYXJjcy5maWx0ZXIoZmlsdGVySW50ZXJpb3JSaW5nKSlcbiAgICAgICAgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyRXh0ZXJpb3JSaW5nKHJpbmcpIHtcbiAgICByZXR1cm4gZmlsdGVyKHJpbmcsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckludGVyaW9yUmluZyhyaW5nKSB7XG4gICAgcmV0dXJuIGZpbHRlcihyaW5nLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAobmFtZSBpbiB0b3BvbG9neS5vYmplY3RzKSB7XG4gICAgZmlsdGVyR2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1tuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gcHJ1bmUodG9wb2xvZ3kpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcklkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5vdE51bGwoZ2VvbWV0cnkpIHtcbiAgcmV0dXJuIGdlb21ldHJ5LnR5cGUgIT0gbnVsbDtcbn1cblxudmFyIGZpbHRlckF0dGFjaGVkID0gZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIHVuaXF1ZVJpbmdCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gaW5kZXggb2YgdW5pcXVlIGFzc29jaWF0ZWQgcmluZywgb3IgLTEgaWYgdXNlZCBieSBtdWx0aXBsZSByaW5nc1xuICAgICAgcmluZ0luZGV4ID0gMCxcbiAgICAgIG5hbWU7XG5cbiAgZnVuY3Rpb24gdGVzdEdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaCh0ZXN0R2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IHRlc3RBcmNzKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBvLmFyY3MuZm9yRWFjaCh0ZXN0QXJjcyk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RBcmNzKGFyY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpLCArK3JpbmdJbmRleCkge1xuICAgICAgZm9yICh2YXIgcmluZyA9IGFyY3NbaV0sIGogPSAwLCBtID0gcmluZy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgdmFyIGFyYyA9IHJpbmdbal07XG4gICAgICAgIGlmIChhcmMgPCAwKSBhcmMgPSB+YXJjO1xuICAgICAgICB2YXIgdW5pcXVlUmluZyA9IHVuaXF1ZVJpbmdCeUFyY1thcmNdO1xuICAgICAgICBpZiAodW5pcXVlUmluZyA+PSAwICYmIHVuaXF1ZVJpbmcgIT09IHJpbmdJbmRleCkgdW5pcXVlUmluZ0J5QXJjW2FyY10gPSAtMTtcbiAgICAgICAgZWxzZSB1bmlxdWVSaW5nQnlBcmNbYXJjXSA9IHJpbmdJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKG5hbWUgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIHRlc3RHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihyaW5nKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSByaW5nLmxlbmd0aCwgYXJjOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoYXJjID0gcmluZ1tqXSwgdW5pcXVlUmluZ0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgaWYgKCh0cmFuc2Zvcm0gPSB0b3BvbG9neS50cmFuc2Zvcm0pID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgdmFyIHRyYW5zZm9ybSxcbiAgICAgIHgwLFxuICAgICAgeTAsXG4gICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcbiAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgIHBvaW50WzBdID0gKHgwICs9IHBvaW50WzBdKSAqIGt4ICsgZHg7XG4gICAgcG9pbnRbMV0gPSAoeTAgKz0gcG9pbnRbMV0pICoga3kgKyBkeTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG59O1xuXG52YXIgYmJveCA9IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIHZhciBiYm94ID0gdG9wb2xvZ3kuYmJveDtcblxuICBmdW5jdGlvbiBiYm94UG9pbnQocDApIHtcbiAgICBwMVswXSA9IHAwWzBdLCBwMVsxXSA9IHAwWzFdLCB0KHAxKTtcbiAgICBpZiAocDFbMF0gPCB4MCkgeDAgPSBwMVswXTtcbiAgICBpZiAocDFbMF0gPiB4MSkgeDEgPSBwMVswXTtcbiAgICBpZiAocDFbMV0gPCB5MCkgeTAgPSBwMVsxXTtcbiAgICBpZiAocDFbMV0gPiB5MSkgeTEgPSBwMVsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJib3hHZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goYmJveEdlb21ldHJ5KTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogYmJveFBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IG8uY29vcmRpbmF0ZXMuZm9yRWFjaChiYm94UG9pbnQpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWJib3gpIHtcbiAgICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neSksIHAwLCBwMSA9IG5ldyBBcnJheSgyKSwgbmFtZSxcbiAgICAgICAgeDAgPSBJbmZpbml0eSwgeTAgPSB4MCwgeDEgPSAteDAsIHkxID0gLXgwO1xuXG4gICAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGFyYy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBwMCA9IGFyY1tpXSwgcDFbMF0gPSBwMFswXSwgcDFbMV0gPSBwMFsxXSwgdChwMSwgaSk7XG4gICAgICAgIGlmIChwMVswXSA8IHgwKSB4MCA9IHAxWzBdO1xuICAgICAgICBpZiAocDFbMF0gPiB4MSkgeDEgPSBwMVswXTtcbiAgICAgICAgaWYgKHAxWzFdIDwgeTApIHkwID0gcDFbMV07XG4gICAgICAgIGlmIChwMVsxXSA+IHkxKSB5MSA9IHAxWzFdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yIChuYW1lIGluIHRvcG9sb2d5Lm9iamVjdHMpIHtcbiAgICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW25hbWVdKTtcbiAgICB9XG5cbiAgICBiYm94ID0gdG9wb2xvZ3kuYmJveCA9IFt4MCwgeTAsIHgxLCB5MV07XG4gIH1cblxuICByZXR1cm4gYmJveDtcbn07XG5cbnZhciByZXZlcnNlJDEgPSBmdW5jdGlvbihhcnJheSwgbikge1xuICB2YXIgdCwgaiA9IGFycmF5Lmxlbmd0aCwgaSA9IGogLSBuO1xuICB3aGlsZSAoaSA8IC0taikgdCA9IGFycmF5W2ldLCBhcnJheVtpKytdID0gYXJyYXlbal0sIGFycmF5W2pdID0gdDtcbn07XG5cbnZhciBmZWF0dXJlID0gZnVuY3Rpb24odG9wb2xvZ3ksIG8pIHtcbiAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIlxuICAgICAgPyB7dHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBmZWF0dXJlczogby5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbihvKSB7IHJldHVybiBmZWF0dXJlJDEodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSQxKHRvcG9sb2d5LCBvKTtcbn07XG5cbmZ1bmN0aW9uIGZlYXR1cmUkMSh0b3BvbG9neSwgbykge1xuICB2YXIgaWQgPSBvLmlkLFxuICAgICAgYmJveCA9IG8uYmJveCxcbiAgICAgIHByb3BlcnRpZXMgPSBvLnByb3BlcnRpZXMgPT0gbnVsbCA/IHt9IDogby5wcm9wZXJ0aWVzLFxuICAgICAgZ2VvbWV0cnkgPSBvYmplY3QodG9wb2xvZ3ksIG8pO1xuICByZXR1cm4gaWQgPT0gbnVsbCAmJiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDogYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDoge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIGJib3g6IGJib3gsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX07XG59XG5cbmZ1bmN0aW9uIG9iamVjdCh0b3BvbG9neSwgbykge1xuICB2YXIgdHJhbnNmb3JtUG9pbnQgPSB0cmFuc2Zvcm0odG9wb2xvZ3kpLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLnNsaWNlKCksIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlJDEocG9pbnRzLCBuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50KHApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQocC5zbGljZSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cblxudmFyIHN0aXRjaCA9IGZ1bmN0aW9uKHRvcG9sb2d5LCBhcmNzKSB7XG4gIHZhciBzdGl0Y2hlZEFyY3MgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgZnJhZ21lbnRCeUVuZCA9IHt9LFxuICAgICAgZnJhZ21lbnRzID0gW10sXG4gICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgLy8gU3RpdGNoIGVtcHR5IGFyY3MgZmlyc3QsIHNpbmNlIHRoZXkgbWF5IGJlIHN1YnN1bWVkIGJ5IG90aGVyIGFyY3MuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpLCBqKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgIGlmIChhcmMubGVuZ3RoIDwgMyAmJiAhYXJjWzFdWzBdICYmICFhcmNbMV1bMV0pIHtcbiAgICAgIHQgPSBhcmNzWysrZW1wdHlJbmRleF0sIGFyY3NbZW1wdHlJbmRleF0gPSBpLCBhcmNzW2pdID0gdDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICBzdGFydCA9IGVbMF0sXG4gICAgICAgIGVuZCA9IGVbMV0sXG4gICAgICAgIGYsIGc7XG5cbiAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICBmLnB1c2goaSk7XG4gICAgICBmLmVuZCA9IGVuZDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgdmFyIGZnID0gZyA9PT0gZiA/IGYgOiBmLmNvbmNhdChnKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2ZnLnN0YXJ0ID0gZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2ZnLmVuZCA9IGcuZW5kXSA9IGZnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZi51bnNoaWZ0KGkpO1xuICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG4gICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtnZi5zdGFydCA9IGcuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnZi5lbmQgPSBmLmVuZF0gPSBnZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZiA9IFtpXTtcbiAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0ID0gc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZF0gPSBmO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5kcyhpKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCBwMCA9IGFyY1swXSwgcDE7XG4gICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgZWxzZSBwMSA9IGFyY1thcmMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGkgPCAwID8gW3AxLCBwMF0gOiBbcDAsIHAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCkge1xuICAgIGZvciAodmFyIGsgaW4gZnJhZ21lbnRCeUVuZCkge1xuICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGRlbGV0ZSBmLnN0YXJ0O1xuICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSA9IDE7IH0pO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZik7XG4gICAgfVxuICB9XG5cbiAgZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KTtcbiAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgaWYgKCFzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldKSBmcmFnbWVudHMucHVzaChbaV0pOyB9KTtcblxuICByZXR1cm4gZnJhZ21lbnRzO1xufTtcblxudmFyIG1lc2ggPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvYmplY3QkJDEsIGZpbHRlcikge1xuICB2YXIgYXJjcywgaSwgbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmNzID0gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCQkMSwgZmlsdGVyKTtcbiAgZWxzZSBmb3IgKGkgPSAwLCBhcmNzID0gbmV3IEFycmF5KG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aCk7IGkgPCBuOyArK2kpIGFyY3NbaV0gPSBpO1xuICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaCh0b3BvbG9neSwgYXJjcyl9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0JCQxLCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MgPSBbXSxcbiAgICAgIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgIGdlb207XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDAoaSkge1xuICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QxKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDIoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKGdlb20gPSBvLCBvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGV4dHJhY3QxKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjYXNlIFwiUG9seWdvblwiOiBleHRyYWN0MihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogZXh0cmFjdDMoby5hcmNzKTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZ2VvbWV0cnkob2JqZWN0JCQxKTtcblxuICBnZW9tc0J5QXJjLmZvckVhY2goZmlsdGVyID09IG51bGxcbiAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG5cbiAgcmV0dXJuIGFyY3M7XG59XG5cbmZ1bmN0aW9uIHBsYW5hclJpbmdBcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKTsgLy8gTm90ZTogZG91YmxlZCBhcmVhIVxufVxuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KVxuICB9O1xufVxuXG52YXIgYmlzZWN0ID0gZnVuY3Rpb24oYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59O1xuXG52YXIgbmVpZ2hib3JzID0gZnVuY3Rpb24ob2JqZWN0cykge1xuICB2YXIgaW5kZXhlc0J5QXJjID0ge30sIC8vIGFyYyBpbmRleCAtPiBhcnJheSBvZiBvYmplY3QgaW5kZXhlc1xuICAgICAgbmVpZ2hib3JzID0gb2JqZWN0cy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmIChhIDwgMCkgYSA9IH5hO1xuICAgICAgdmFyIG8gPSBpbmRleGVzQnlBcmNbYV07XG4gICAgICBpZiAobykgby5wdXNoKGkpO1xuICAgICAgZWxzZSBpbmRleGVzQnlBcmNbYV0gPSBbaV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IGxpbmUoYXJjLCBpKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvLCBpKSB7XG4gICAgaWYgKG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIikgby5nZW9tZXRyaWVzLmZvckVhY2goZnVuY3Rpb24obykgeyBnZW9tZXRyeShvLCBpKTsgfSk7XG4gICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzLCBpKTtcbiAgfVxuXG4gIHZhciBnZW9tZXRyeVR5cGUgPSB7XG4gICAgTGluZVN0cmluZzogbGluZSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgUG9seWdvbjogcG9seWdvbixcbiAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MsIGkpIHsgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBwb2x5Z29uKGFyYywgaSk7IH0pOyB9XG4gIH07XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmb3IgKHZhciBpIGluIGluZGV4ZXNCeUFyYykge1xuICAgIGZvciAodmFyIGluZGV4ZXMgPSBpbmRleGVzQnlBcmNbaV0sIG0gPSBpbmRleGVzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG07ICsraykge1xuICAgICAgICB2YXIgaWogPSBpbmRleGVzW2pdLCBpayA9IGluZGV4ZXNba10sIG47XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpal0pW2kgPSBiaXNlY3QobiwgaWspXSAhPT0gaWspIG4uc3BsaWNlKGksIDAsIGlrKTtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lrXSlbaSA9IGJpc2VjdChuLCBpaildICE9PSBpaikgbi5zcGxpY2UoaSwgMCwgaWopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG52YXIgcXVhbnRpemUgPSBmdW5jdGlvbih0b3BvbG9neSwgbikge1xuICBpZiAoISgobiA9IE1hdGguZmxvb3IobikpID49IDIpKSB0aHJvdyBuZXcgRXJyb3IoXCJuIG11c3QgYmUgXFx1MjI2NTJcIik7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuICB2YXIgYmIgPSBiYm94KHRvcG9sb2d5KSwgbmFtZSxcbiAgICAgIGR4ID0gYmJbMF0sIGt4ID0gKGJiWzJdIC0gZHgpIC8gKG4gLSAxKSB8fCAxLFxuICAgICAgZHkgPSBiYlsxXSwga3kgPSAoYmJbM10gLSBkeSkgLyAobiAtIDEpIHx8IDE7XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVQb2ludChwKSB7XG4gICAgcFswXSA9IE1hdGgucm91bmQoKHBbMF0gLSBkeCkgLyBreCk7XG4gICAgcFsxXSA9IE1hdGgucm91bmQoKHBbMV0gLSBkeSkgLyBreSk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChxdWFudGl6ZUdlb21ldHJ5KTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogcXVhbnRpemVQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2gocXVhbnRpemVQb2ludCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgaSA9IDEsXG4gICAgICAgIGogPSAxLFxuICAgICAgICBuID0gYXJjLmxlbmd0aCxcbiAgICAgICAgcGkgPSBhcmNbMF0sXG4gICAgICAgIHgwID0gcGlbMF0gPSBNYXRoLnJvdW5kKChwaVswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTAgPSBwaVsxXSA9IE1hdGgucm91bmQoKHBpWzFdIC0gZHkpIC8ga3kpLFxuICAgICAgICBwaixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHBpID0gYXJjW2ldO1xuICAgICAgeDEgPSBNYXRoLnJvdW5kKChwaVswXSAtIGR4KSAvIGt4KTtcbiAgICAgIHkxID0gTWF0aC5yb3VuZCgocGlbMV0gLSBkeSkgLyBreSk7XG4gICAgICBpZiAoeDEgIT09IHgwIHx8IHkxICE9PSB5MCkge1xuICAgICAgICBwaiA9IGFyY1tqKytdO1xuICAgICAgICBwalswXSA9IHgxIC0geDAsIHgwID0geDE7XG4gICAgICAgIHBqWzFdID0geTEgLSB5MCwgeTAgPSB5MTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaiA8IDIpIHtcbiAgICAgIHBqID0gYXJjW2orK107XG4gICAgICBwalswXSA9IDA7XG4gICAgICBwalsxXSA9IDA7XG4gICAgfVxuXG4gICAgYXJjLmxlbmd0aCA9IGo7XG4gIH0pO1xuXG4gIGZvciAobmFtZSBpbiB0b3BvbG9neS5vYmplY3RzKSB7XG4gICAgcXVhbnRpemVHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW25hbWVdKTtcbiAgfVxuXG4gIHRvcG9sb2d5LnRyYW5zZm9ybSA9IHtcbiAgICBzY2FsZTogW2t4LCBreV0sXG4gICAgdHJhbnNsYXRlOiBbZHgsIGR5XVxuICB9O1xuXG4gIHJldHVybiB0b3BvbG9neTtcbn07XG5cbnZhciB1bnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIGlmICgodHJhbnNmb3JtID0gdG9wb2xvZ3kudHJhbnNmb3JtKSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB0cmFuc2Zvcm0sXG4gICAgICB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgeDEgPSBNYXRoLnJvdW5kKChwb2ludFswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTEgPSBNYXRoLnJvdW5kKChwb2ludFsxXSAtIGR5KSAvIGt5KTtcbiAgICBwb2ludFswXSA9IHgxIC0geDAsIHgwID0geDE7XG4gICAgcG9pbnRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHJldHVybiBwb2ludDtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHBsYW5hclRyaWFuZ2xlQXJlYSh0cmlhbmdsZSkge1xuICB2YXIgYSA9IHRyaWFuZ2xlWzBdLCBiID0gdHJpYW5nbGVbMV0sIGMgPSB0cmlhbmdsZVsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGFbMV0pIC0gKGFbMF0gLSBiWzBdKSAqIChjWzFdIC0gYVsxXSkpO1xufVxuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYSQxKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XG59XG5cbnZhciBmaWx0ZXJXZWlnaHQgPSBmdW5jdGlvbih0b3BvbG9neSwgbWluV2VpZ2h0LCB3ZWlnaHQpIHtcbiAgbWluV2VpZ2h0ID0gbWluV2VpZ2h0ID09IG51bGwgPyBOdW1iZXIuTUlOX1ZBTFVFIDogK21pbldlaWdodDtcblxuICBpZiAod2VpZ2h0ID09IG51bGwpIHdlaWdodCA9IHBsYW5hclJpbmdBcmVhJDE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHJpbmcsIGludGVyaW9yKSB7XG4gICAgcmV0dXJuIHdlaWdodChmZWF0dXJlKHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBpbnRlcmlvcikgPj0gbWluV2VpZ2h0O1xuICB9O1xufTtcblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhWzFdWzJdIC0gYlsxXVsyXTtcbn1cblxudmFyIG5ld0hlYXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhlYXAgPSB7fSxcbiAgICAgIGFycmF5ID0gW10sXG4gICAgICBzaXplID0gMDtcblxuICBoZWFwLnB1c2ggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB1cChhcnJheVtvYmplY3QuXyA9IHNpemVdID0gb2JqZWN0LCBzaXplKyspO1xuICAgIHJldHVybiBzaXplO1xuICB9O1xuXG4gIGhlYXAucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNpemUgPD0gMCkgcmV0dXJuO1xuICAgIHZhciByZW1vdmVkID0gYXJyYXlbMF0sIG9iamVjdDtcbiAgICBpZiAoLS1zaXplID4gMCkgb2JqZWN0ID0gYXJyYXlbc2l6ZV0sIGRvd24oYXJyYXlbb2JqZWN0Ll8gPSAwXSA9IG9iamVjdCwgMCk7XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH07XG5cbiAgaGVhcC5yZW1vdmUgPSBmdW5jdGlvbihyZW1vdmVkKSB7XG4gICAgdmFyIGkgPSByZW1vdmVkLl8sIG9iamVjdDtcbiAgICBpZiAoYXJyYXlbaV0gIT09IHJlbW92ZWQpIHJldHVybjsgLy8gaW52YWxpZCByZXF1ZXN0XG4gICAgaWYgKGkgIT09IC0tc2l6ZSkgb2JqZWN0ID0gYXJyYXlbc2l6ZV0sIChjb21wYXJlKG9iamVjdCwgcmVtb3ZlZCkgPCAwID8gdXAgOiBkb3duKShhcnJheVtvYmplY3QuXyA9IGldID0gb2JqZWN0LCBpKTtcbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBmdW5jdGlvbiB1cChvYmplY3QsIGkpIHtcbiAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgIHZhciBqID0gKChpICsgMSkgPj4gMSkgLSAxLFxuICAgICAgICAgIHBhcmVudCA9IGFycmF5W2pdO1xuICAgICAgaWYgKGNvbXBhcmUob2JqZWN0LCBwYXJlbnQpID49IDApIGJyZWFrO1xuICAgICAgYXJyYXlbcGFyZW50Ll8gPSBpXSA9IHBhcmVudDtcbiAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvd24ob2JqZWN0LCBpKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByID0gKGkgKyAxKSA8PCAxLFxuICAgICAgICAgIGwgPSByIC0gMSxcbiAgICAgICAgICBqID0gaSxcbiAgICAgICAgICBjaGlsZCA9IGFycmF5W2pdO1xuICAgICAgaWYgKGwgPCBzaXplICYmIGNvbXBhcmUoYXJyYXlbbF0sIGNoaWxkKSA8IDApIGNoaWxkID0gYXJyYXlbaiA9IGxdO1xuICAgICAgaWYgKHIgPCBzaXplICYmIGNvbXBhcmUoYXJyYXlbcl0sIGNoaWxkKSA8IDApIGNoaWxkID0gYXJyYXlbaiA9IHJdO1xuICAgICAgaWYgKGogPT09IGkpIGJyZWFrO1xuICAgICAgYXJyYXlbY2hpbGQuXyA9IGldID0gY2hpbGQ7XG4gICAgICBhcnJheVtvYmplY3QuXyA9IGkgPSBqXSA9IG9iamVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGVhcDtcbn07XG5cbnZhciBwcmVzaW1wbGlmeSA9IGZ1bmN0aW9uKHRvcG9sb2d5LCB3ZWlnaHQpIHtcbiAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtKHRvcG9sb2d5KSxcbiAgICAgIHJlbGF0aXZlID0gdW50cmFuc2Zvcm0odG9wb2xvZ3kpLFxuICAgICAgaGVhcCA9IG5ld0hlYXAoKTtcblxuICBpZiAod2VpZ2h0ID09IG51bGwpIHdlaWdodCA9IHBsYW5hclRyaWFuZ2xlQXJlYTtcblxuICB0b3BvbG9neS5hcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxuICAgICAgICBtYXhXZWlnaHQgPSAwLFxuICAgICAgICB0cmlhbmdsZSxcbiAgICAgICAgaSxcbiAgICAgICAgbjtcblxuICAgIGFyYy5mb3JFYWNoKGFic29sdXRlKTtcblxuICAgIGZvciAoaSA9IDEsIG4gPSBhcmMubGVuZ3RoIC0gMTsgaSA8IG47ICsraSkge1xuICAgICAgdHJpYW5nbGUgPSBhcmMuc2xpY2UoaSAtIDEsIGkgKyAyKTtcbiAgICAgIHRyaWFuZ2xlWzFdWzJdID0gd2VpZ2h0KHRyaWFuZ2xlKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgIGhlYXAucHVzaCh0cmlhbmdsZSk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGtlZXAgdGhlIGFyYyBlbmRwb2ludHMhXG4gICAgYXJjWzBdWzJdID0gYXJjW25dWzJdID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZXNbaV07XG4gICAgICB0cmlhbmdsZS5wcmV2aW91cyA9IHRyaWFuZ2xlc1tpIC0gMV07XG4gICAgICB0cmlhbmdsZS5uZXh0ID0gdHJpYW5nbGVzW2kgKyAxXTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJpYW5nbGUgPSBoZWFwLnBvcCgpKSB7XG4gICAgICB2YXIgcHJldmlvdXMgPSB0cmlhbmdsZS5wcmV2aW91cyxcbiAgICAgICAgICBuZXh0ID0gdHJpYW5nbGUubmV4dDtcblxuICAgICAgLy8gSWYgdGhlIHdlaWdodCBvZiB0aGUgY3VycmVudCBwb2ludCBpcyBsZXNzIHRoYW4gdGhhdCBvZiB0aGUgcHJldmlvdXNcbiAgICAgIC8vIHBvaW50IHRvIGJlIGVsaW1pbmF0ZWQsIHVzZSB0aGUgbGF0dGVy4oCZcyB3ZWlnaHQgaW5zdGVhZC4gVGhpcyBlbnN1cmVzXG4gICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IHBvaW50IGNhbm5vdCBiZSBlbGltaW5hdGVkIHdpdGhvdXQgZWxpbWluYXRpbmdcbiAgICAgIC8vIHByZXZpb3VzbHktIGVsaW1pbmF0ZWQgcG9pbnRzLlxuICAgICAgaWYgKHRyaWFuZ2xlWzFdWzJdIDwgbWF4V2VpZ2h0KSB0cmlhbmdsZVsxXVsyXSA9IG1heFdlaWdodDtcbiAgICAgIGVsc2UgbWF4V2VpZ2h0ID0gdHJpYW5nbGVbMV1bMl07XG5cbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgcHJldmlvdXNbMl0gPSB0cmlhbmdsZVsyXTtcbiAgICAgICAgdXBkYXRlKHByZXZpb3VzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICBuZXh0WzBdID0gdHJpYW5nbGVbMF07XG4gICAgICAgIHVwZGF0ZShuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcmMuZm9yRWFjaChyZWxhdGl2ZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSh0cmlhbmdsZSkge1xuICAgIGhlYXAucmVtb3ZlKHRyaWFuZ2xlKTtcbiAgICB0cmlhbmdsZVsxXVsyXSA9IHdlaWdodCh0cmlhbmdsZSk7XG4gICAgaGVhcC5wdXNoKHRyaWFuZ2xlKTtcbiAgfVxuXG4gIHJldHVybiB0b3BvbG9neTtcbn07XG5cbnZhciBxdWFudGlsZSA9IGZ1bmN0aW9uKHRvcG9sb2d5LCBwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICBhcmMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKGlzRmluaXRlKHBvaW50WzJdKSkgeyAvLyBJZ25vcmUgZW5kcG9pbnRzLCB3aG9zZSB3ZWlnaHQgaXMgSW5maW5pdHkuXG4gICAgICAgIGFycmF5LnB1c2gocG9pbnRbMl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXkubGVuZ3RoICYmIHF1YW50aWxlJDEoYXJyYXkuc29ydChkZXNjZW5kaW5nKSwgcCk7XG59O1xuXG5mdW5jdGlvbiBxdWFudGlsZSQxKGFycmF5LCBwKSB7XG4gIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gYXJyYXlbMF07XG4gIGlmIChwID49IDEpIHJldHVybiBhcnJheVtuIC0gMV07XG4gIHZhciBuLFxuICAgICAgaCA9IChuIC0gMSkgKiBwLFxuICAgICAgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICBhID0gYXJyYXlbaV0sXG4gICAgICBiID0gYXJyYXlbaSArIDFdO1xuICByZXR1cm4gYSArIChiIC0gYSkgKiAoaCAtIGkpO1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGIgLSBhO1xufVxuXG52YXIgc2ltcGxpZnkgPSBmdW5jdGlvbih0b3BvbG9neSwgbWluV2VpZ2h0KSB7XG4gIG1pbldlaWdodCA9IG1pbldlaWdodCA9PSBudWxsID8gTnVtYmVyLk1JTl9WQUxVRSA6ICttaW5XZWlnaHQ7XG5cbiAgLy8gUmVtb3ZlIHBvaW50cyB3aG9zZSB3ZWlnaHQgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHdlaWdodC5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKHRvcG9sb2d5LnRyYW5zZm9ybSA/IGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBkeCA9IDAsXG4gICAgICAgIGR5ID0gMCwgLy8gYWNjdW11bGF0ZSByZW1vdmVkIHBvaW50c1xuICAgICAgICBpID0gLTEsXG4gICAgICAgIGogPSAtMSxcbiAgICAgICAgbiA9IGFyYy5sZW5ndGgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0O1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHNvdXJjZSA9IGFyY1tpXTtcbiAgICAgIGlmIChzb3VyY2VbMl0gPj0gbWluV2VpZ2h0KSB7XG4gICAgICAgIHRhcmdldCA9IGFyY1srK2pdO1xuICAgICAgICB0YXJnZXRbMF0gPSBzb3VyY2VbMF0gKyBkeDtcbiAgICAgICAgdGFyZ2V0WzFdID0gc291cmNlWzFdICsgZHk7XG4gICAgICAgIGR4ID0gZHkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggKz0gc291cmNlWzBdO1xuICAgICAgICBkeSArPSBzb3VyY2VbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXJjLmxlbmd0aCA9ICsrajtcbiAgfSA6IGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIGogPSAtMSxcbiAgICAgICAgbiA9IGFyYy5sZW5ndGgsXG4gICAgICAgIHBvaW50O1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHBvaW50ID0gYXJjW2ldO1xuICAgICAgaWYgKHBvaW50WzJdID49IG1pbldlaWdodCkge1xuICAgICAgICBhcmNbKytqXSA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyYy5sZW5ndGggPSArK2o7XG4gIH0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgY29tcHV0ZWQgd2VpZ2h0IGZvciBlYWNoIHBvaW50LCBhbmQgcmVtb3ZlIGNvaW5jaWRlbnQgcG9pbnRzLlxuICAvLyBUaGlzIGlzIGRvbmUgYXMgYSBzZXBhcmF0ZSBwYXNzIGJlY2F1c2Ugc29tZSBjb29yZGluYXRlcyBtYXkgYmUgc2hhcmVkXG4gIC8vIGJldHdlZW4gYXJjcyAoc3VjaCBhcyB0aGUgbGFzdCBwb2ludCBhbmQgZmlyc3QgcG9pbnQgb2YgYSBjdXQgbGluZSkuXG4gIC8vIElmIHRoZSBlbnRpcmUgYXJjIGlzIGVtcHR5LCByZXRhaW4gYXQgbGVhc3QgdHdvIHBvaW50cyAocGVyIHNwZWMpLlxuICB0b3BvbG9neS5hcmNzLmZvckVhY2godG9wb2xvZ3kudHJhbnNmb3JtID8gZnVuY3Rpb24oYXJjKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbiA9IGFyYy5sZW5ndGgsXG4gICAgICAgIHAgPSBhcmNbMF07XG4gICAgcC5sZW5ndGggPSAyO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gYXJjW2ldO1xuICAgICAgcC5sZW5ndGggPSAyO1xuICAgICAgaWYgKHBbMF0gfHwgcFsxXSkgYXJjWysral0gPSBwO1xuICAgIH1cbiAgICBhcmMubGVuZ3RoID0gKGogfHwgMSkgKyAxO1xuICB9IDogZnVuY3Rpb24oYXJjKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbiA9IGFyYy5sZW5ndGgsXG4gICAgICAgIHAgPSBhcmNbMF0sXG4gICAgICAgIHgwID0gcFswXSxcbiAgICAgICAgeTAgPSBwWzFdLFxuICAgICAgICB4MSxcbiAgICAgICAgeTE7XG4gICAgcC5sZW5ndGggPSAyO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gYXJjW2ldLCB4MSA9IHBbMF0sIHkxID0gcFsxXTtcbiAgICAgIHAubGVuZ3RoID0gMjtcbiAgICAgIGlmICh4MCAhPT0geDEgfHwgeTAgIT09IHkxKSBhcmNbKytqXSA9IHAsIHgwID0geDEsIHkwID0geTE7XG4gICAgfVxuICAgIGFyYy5sZW5ndGggPSAoaiB8fCAxKSArIDE7XG4gIH0pO1xuXG4gIHJldHVybiB0b3BvbG9neTtcbn07XG5cbnZhciBwaSA9IE1hdGguUEk7XG52YXIgdGF1ID0gMiAqIHBpO1xudmFyIGZvdXJQaSA9IDQgKiBwaTtcbnZhciByYWRpYW5zID0gcGkgLyAxODA7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgYXRhbiA9IE1hdGguYXRhbjtcbnZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciB0YW4gPSBNYXRoLnRhbjtcblxuZnVuY3Rpb24gc3BoZXJpY2FsUmluZ0FyZWEocmluZywgaW50ZXJpb3IpIHtcbiAgaWYgKCFyaW5nLmxlbmd0aCkgcmV0dXJuIDA7XG4gIHZhciBzdW0gPSAwLFxuICAgICAgcG9pbnQgPSByaW5nWzBdLFxuICAgICAgbGFtYmRhMCwgbGFtYmRhMSA9IHBvaW50WzBdICogcmFkaWFucywgZGVsdGEsXG4gICAgICBwaGkxID0gKHBvaW50WzFdICogcmFkaWFucyArIHRhdSkgLyAyLFxuICAgICAgY29zUGhpMCwgY29zUGhpMSA9IGNvcyhwaGkxKSxcbiAgICAgIHNpblBoaTAsIHNpblBoaTEgPSBzaW4ocGhpMSksXG4gICAgICBpLCBuLCBrO1xuXG4gIGZvciAoaSA9IDEsIG4gPSByaW5nLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHBvaW50ID0gcmluZ1tpXTtcbiAgICBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHBvaW50WzBdICogcmFkaWFucywgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMDtcbiAgICBwaGkxID0gKHBvaW50WzFdICogcmFkaWFucyArIHRhdSkgLyAyO1xuICAgIGNvc1BoaTAgPSBjb3NQaGkxLCBjb3NQaGkxID0gY29zKHBoaTEpO1xuICAgIHNpblBoaTAgPSBzaW5QaGkxLCBzaW5QaGkxID0gc2luKHBoaTEpO1xuXG4gICAgLy8gU3BoZXJpY2FsIGV4Y2VzcyBFIGZvciBhIHNwaGVyaWNhbCB0cmlhbmdsZSB3aXRoIHZlcnRpY2VzOiBzb3V0aCBwb2xlLFxuICAgIC8vIHByZXZpb3VzIHBvaW50LCBjdXJyZW50IHBvaW50LiBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgICAvLyB0aGVvcmVtLiBTZWUgVG9kaHVudGVyLCBTcGhlcmljYWwgVHJpZy4gKDE4NzEpLCBTZWMuIDEwMywgRXEuICgyKS5cbiAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG4gICAgc3VtICs9IGF0YW4yKGsgKiBzaW4oZGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoZGVsdGEpKTtcbiAgfVxuXG4gIHN1bSA9IDIgKiAoc3VtID4gcGkgPyBzdW0gLSB0YXUgOiBzdW0gPCAtcGkgPyBzdW0gKyB0YXUgOiBzdW0pO1xuICBpZiAoaW50ZXJpb3IpIHN1bSAqPSAtMTtcbiAgcmV0dXJuIHN1bSA8IDAgPyBzdW0gKyBmb3VyUGkgOiBzdW07XG59XG5cbmZ1bmN0aW9uIHNwaGVyaWNhbFRyaWFuZ2xlQXJlYSh0KSB7XG4gIHZhciBsYW1iZGEwID0gdFswXVswXSAqIHJhZGlhbnMsIHBoaTAgPSB0WzBdWzFdICogcmFkaWFucywgY29zUGhpMCA9IGNvcyhwaGkwKSwgc2luUGhpMCA9IHNpbihwaGkwKSxcbiAgICAgIGxhbWJkYTEgPSB0WzFdWzBdICogcmFkaWFucywgcGhpMSA9IHRbMV1bMV0gKiByYWRpYW5zLCBjb3NQaGkxID0gY29zKHBoaTEpLCBzaW5QaGkxID0gc2luKHBoaTEpLFxuICAgICAgbGFtYmRhMiA9IHRbMl1bMF0gKiByYWRpYW5zLCBwaGkyID0gdFsyXVsxXSAqIHJhZGlhbnMsIGNvc1BoaTIgPSBjb3MocGhpMiksIHNpblBoaTIgPSBzaW4ocGhpMiksXG4gICAgICBhID0gZGlzdGFuY2UobGFtYmRhMCwgY29zUGhpMCwgc2luUGhpMCwgbGFtYmRhMSwgY29zUGhpMSwgc2luUGhpMSksXG4gICAgICBiID0gZGlzdGFuY2UobGFtYmRhMSwgY29zUGhpMSwgc2luUGhpMSwgbGFtYmRhMiwgY29zUGhpMiwgc2luUGhpMiksXG4gICAgICBjID0gZGlzdGFuY2UobGFtYmRhMiwgY29zUGhpMiwgc2luUGhpMiwgbGFtYmRhMCwgY29zUGhpMCwgc2luUGhpMCksXG4gICAgICBzID0gKGEgKyBiICsgYykgLyAyO1xuICByZXR1cm4gNCAqIGF0YW4oc3FydChtYXgoMCwgdGFuKHMgLyAyKSAqIHRhbigocyAtIGEpIC8gMikgKiB0YW4oKHMgLSBiKSAvIDIpICogdGFuKChzIC0gYykgLyAyKSkpKTtcbn1cblxuZnVuY3Rpb24gZGlzdGFuY2UobGFtYmRhMCwgc2luUGhpMCwgY29zUGhpMCwgbGFtYmRhMSwgc2luUGhpMSwgY29zUGhpMSkge1xuICB2YXIgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApLFxuICAgICAgY29zRGVsdGEgPSBjb3MoZGVsdGEpLFxuICAgICAgc2luRGVsdGEgPSBzaW4oZGVsdGEpLFxuICAgICAgeCA9IGNvc1BoaTEgKiBzaW5EZWx0YSxcbiAgICAgIHkgPSBjb3NQaGkwICogc2luUGhpMSAtIHNpblBoaTAgKiBjb3NQaGkxICogY29zRGVsdGEsXG4gICAgICB6ID0gc2luUGhpMCAqIHNpblBoaTEgKyBjb3NQaGkwICogY29zUGhpMSAqIGNvc0RlbHRhO1xuICByZXR1cm4gYXRhbjIoc3FydCh4ICogeCArIHkgKiB5KSwgeik7XG59XG5cbmV4cG9ydHMudG9wb2xvZ3kgPSB0b3BvbG9neTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maWx0ZXJBdHRhY2hlZCA9IGZpbHRlckF0dGFjaGVkO1xuZXhwb3J0cy5maWx0ZXJXZWlnaHQgPSBmaWx0ZXJXZWlnaHQ7XG5leHBvcnRzLnBsYW5hclJpbmdBcmVhID0gcGxhbmFyUmluZ0FyZWEkMTtcbmV4cG9ydHMucGxhbmFyVHJpYW5nbGVBcmVhID0gcGxhbmFyVHJpYW5nbGVBcmVhO1xuZXhwb3J0cy5wcmVzaW1wbGlmeSA9IHByZXNpbXBsaWZ5O1xuZXhwb3J0cy5xdWFudGlsZSA9IHF1YW50aWxlO1xuZXhwb3J0cy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuZXhwb3J0cy5zcGhlcmljYWxSaW5nQXJlYSA9IHNwaGVyaWNhbFJpbmdBcmVhO1xuZXhwb3J0cy5zcGhlcmljYWxUcmlhbmdsZUFyZWEgPSBzcGhlcmljYWxUcmlhbmdsZUFyZWE7XG5leHBvcnRzLmJib3ggPSBiYm94O1xuZXhwb3J0cy5mZWF0dXJlID0gZmVhdHVyZTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubWVyZ2VBcmNzID0gbWVyZ2VBcmNzO1xuZXhwb3J0cy5tZXNoID0gbWVzaDtcbmV4cG9ydHMubWVzaEFyY3MgPSBtZXNoQXJjcztcbmV4cG9ydHMubmVpZ2hib3JzID0gbmVpZ2hib3JzO1xuZXhwb3J0cy5xdWFudGl6ZSA9IHF1YW50aXplO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5leHBvcnRzLnVudHJhbnNmb3JtID0gdW50cmFuc2Zvcm07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/topojson/dist/topojson.js\n");

/***/ })

}]);